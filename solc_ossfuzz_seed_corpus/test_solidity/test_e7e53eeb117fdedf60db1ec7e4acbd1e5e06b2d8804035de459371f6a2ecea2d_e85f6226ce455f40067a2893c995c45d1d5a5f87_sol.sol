
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(uint88 ep0);
struct St0 {
  address payable el0;
  int16 el1;
  bool el2;
}

==== Source: su1.sol ====
contract C0 {
  int8  public s0;
  address payable  public s1 = payable(address(this));
  constructor(int8 i0)   {
    s0 ^= (((int8(127) + int8(127)) & (int8(24) ^ int8(127))) ^ int8(-15));
    {
    }
  }
  struct St1 {
    bytes el0;
    bool el1;
    mapping(bytes11 => address)[5] el2;
    address el3;
  }
  event ev0(bool  ep0) anonymous;
  receive() external   payable
  {
  }
  function f1(address payable i0) public   payable  returns(int216 o0)  {
    return (((-((-(int216(52656145834278593348959013841835216159447547700274555627155488767))))) - ((int216(0) - int216(0)) ** uint64(uint64(14074777813240842970)))));
  }
  event ev1() anonymous;
}
contract C1 {
  fallback() external virtual  
  {
    return;
  }
  uint48 immutable  s2;
  constructor(uint48 i0)   {
    s2 = (uint48(5427879938936) - (((uint48(262209694838039) & uint48(281474976710655)) ^ uint48(189668498334199)) * uint48(0)));
    unchecked {
    }
  }
  error er1();
  type T0 is address;
}
contract C2 is C0 {
  event ev2() anonymous;
  bool   s3 = true;
  address payable   s4 = payable(address(this));
  address payable  public s5 = payable(address(this));
  C1.T0   s6;
  constructor(int8 i0,C1.T0 i1) payable C0((((((~(int8(-67))) % int8(50)) * int8(0)) + int8(34)) % int8(-83)))
  {
    s0 += (false ? int8(0) : int8(127));
    s6 = 0x675cf87631dd99EfdC41238332Da6fe050E84061 f3 /*suffix expr*/;
    {
    }
  }
  fallback() external virtual  
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
struct St2 {
  C0 el0;
}
pragma solidity >= 0.0.0;
function f3(address i0) pure suffix  returns(C1.T0 o0)
{
  for(  C1 l0 = C1(address(0x0000000000000000000000000000000000000002));
;
)
  {
  }
  (o0, o0) = (C1.T0.wrap(address(0x0000000000000000000000000000000000000003)), C1.T0.wrap(address(0x0000000000000000000000000000000000000003)));
  assert(o0 == C1.T0.wrap(address(0x0000000000000000000000000000000000000003)));
  assert(o0 == C1.T0.wrap(address(0x0000000000000000000000000000000000000003)));
}
// ====
// ----
