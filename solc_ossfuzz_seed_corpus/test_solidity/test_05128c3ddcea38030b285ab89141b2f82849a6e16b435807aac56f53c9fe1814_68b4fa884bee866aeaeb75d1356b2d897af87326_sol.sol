
==== Source: su0.sol ====
library L0 {
  error er0();
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33
  }
  modifier m0() 
  {
    for(;
;
)
    {
      _;
      break;
    }
  }
  type T0 is bool;
}
address payable constant cons0 = payable(0xf1D5D5F749525ffACaD11EfaF8De1b38953Ce555);
contract C0 {
  error er1(bytes8 ep0, bool ep1);
  modifier m1(function (bool) external   returns (uint208, bytes memory, uint120) i0,bytes11 i1) virtual
  {
    try i0(false) returns (uint208 l0, bytes memory l1, uint120 l2)
    {
      l0 = (uint208(411376139330301510538742295639337626245683966408394965837152255) & (uint208(0) - ((uint208(0) ** uint216(uint216(0))) % uint208(0))));
      while (false)
      {
        continue;
        _;
      }
    }
    catch
    {
      assembly
      {
        stop()
        let al0 := i1
      }
    }
    catch Error(string memory l3)
    {
    }
  }
  event ev0(L0.T0  ep0);
  modifier m2(uint72 i0,bytes26 i1) virtual
  {
    assembly
    {
      switch i0
      default
      {
        for 
        {
          i1 := xor(mul(115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        }
        i1
        {
        }
        {
          let al1 := i1
          return(0, timestamp())
          invalid()
        }
        function af0(ai0, ai1) -> ao0, ao1, ao2
        {
          ai0 := ai1
        }
      }
    }
    (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000");
    _;
  }
  error er2();
  function f0() external  m2(((((~((uint72(0) << uint208(uint208(209524785679060559532550695597871479400616230093670425896840628))))) * uint72(0)) * uint72(0)) % uint72(0)),bytes26(0xeea3cd815b19bc2d3bb94cacbf905e251ad169b6d2991f4b7b4d))  returns(bool o0)
  {
  }
  mapping(L0.T0 => uint144)   s0;
  constructor()   {
    s0[L0.T0.wrap(false)] -= (((uint144(22300745198530623141535718272648361505980415) << uint184(uint184(1917649168282827677670435636854645810115955144078549070))) >> uint24((uint24(0) * uint24(0)))) + uint144(22300745198530623141535718272648361505980415));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("00000000000000000f0635e7427bbf64bdb4172cd59978aac74ba710f08e");
    }
  }
  type T1 is uint232;
  function f1() internal virtual m2(((((uint72(176848451971379620781) % (uint72(0) % uint72(0))) >> uint8(uint8(255))) & uint72(0)) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))),bytes26(0x38a4914a2168d35bf6bc1b8851c3fa9137161a85e5a6be4c04c9))  returns(address o0,bool o1)
  {
    (bool l0, bytes memory l1) = address(this).call("f740c548c698a3134d000000000000000000000000000000000000");
    (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffd8864ab2e04117c135f1b4b29564a3ec8877d8c8ef66"));
    (bool l4, bytes memory l5) = address(this).call(bytes("ffffffffffffffffffffffffffffffff"));
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
bool constant cons1 = ((((uint24(1252544) ** uint72((uint72(4159479487277210480147) % uint72(2800051167718877881191)))) ** uint48(uint48(281474976710655))) ** uint88(uint88(161293090969121902282342804))) < uint24(16777215));
type T2 is bytes24;
import "su0.sol";
function f2(uint216 i0,address payable i1)    
{
  bytes15 l0 = bytes15(0x000000000000000000000000000000);
}
pragma solidity >= 0.0.0;
using L0 for uint;
error er3(int144 ep0, function (bytes28) external   ep1);
// ====
// ----
