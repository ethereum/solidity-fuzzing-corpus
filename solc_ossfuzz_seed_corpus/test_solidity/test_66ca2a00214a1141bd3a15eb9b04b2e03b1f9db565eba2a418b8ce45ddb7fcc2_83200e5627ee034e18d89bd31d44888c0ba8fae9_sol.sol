==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
  }
  function f1(bool i0,address i1,bytes17 i2) public virtual  payable returns(function (bytes24, bool, address payable[1] memory) external   returns (address, int24) o0)
  {
    uint16 l0 = (uint16(65535) >> uint224(((((uint224(20499937015274583693923231980899094892580785417388956954579961268265) ^ uint224(0)) * uint224(26959946667150639794667015087019630673637144422540572481103610249215)) + uint224(26959946667150639794667015087019630673637144422540572481103610249215)) + uint224(0))));
    for(;
;
true)
    {
    }
    unchecked {
      (bool l1, bytes memory l2) = payable(this).call{value: 9366921116037740962}("");
      if (false)
      {
      }
      do
      {
        continue;
        break;
        try o0(bytes24(0x000000000000000000000000000000000000000000000000),(true ? true : true),[payable(address(0x0000000000000000000000000000000000000005))]) returns (address l3, int24 l4)
        {
          continue;
        }
        catch
        {
        }
      }
      while (true);
    }
  }
  bool public constant cons0 = false;
  modifier m0() virtual
  {
    _;
    for(    bytes2 l0 = bytes2(0x0000);
;
)
    {
    }
    int32 l1 = int32(((int32(2147483647) ^ (int32(0) + int32(2147483647))) / int32(-1821772472)));
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20
  }
  function f2(bytes6 i0) public  m0() 
  {
  }
  bytes20 immutable public s0 = bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));
  struct St0 {
    int192 el0;
    bool el1;
    mapping(bytes16 => C0.EN0) el2;
  }
  fallback() external virtual m0() 
  {
    for(    function (address) internal   l0;
;
)
    {
      return;
    }
  }
}
error er0(bytes2 ep0);
library L0 {
  error er1();
  C0.EN0 public constant cons1 = C0.EN0.M0;
  function f4() private    returns(int256 o0)
  {
    int184 l0 = (int184(-4673920562466156861664897530566692366688903177616762987) * int184(11480931577036181799611736585098822478693156734072270670));
    C0.EN0 l1 = C0.EN0.M15;
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111

  }
  event ev0(address  ep0);
  modifier m1(function (string memory, bool) external   returns (C0.EN0) i0,uint192 i1) 
  {
    _;
  }
}
function f5(function (L0.EN1) external   returns (function (bool, bytes memory) external   returns (bool, address payable, bytes memory), uint112, int32[] memory) i0,function (uint16, int40, int224) external   i1)     returns(uint80 o0)
{
  return (((((((uint80(0) + uint80(463350398818309452577502)) - uint80(332532873474184015362438)) ** uint144(uint144(0))) % uint80(0)) - uint80(1208925819614629174706175)) % uint80(1029495587881371560466917)));
  return (uint80(0));
  payable(address(0x0000000000000000000000000000000000000005));
}
pragma solidity >= 0.0.0;
// ----
// Warning 3149: (su0.sol:3121-3227): The result type of the exponentiation operation is equal to the type of the first operand (uint80) ignoring the (larger) type of the second operand (uint144) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:3320-3338): Unreachable code.
// Warning 5740: (su0.sol:3342-3402): Unreachable code.
// Warning 5740: (su0.sol:759-764): Unreachable code.
// Warning 5740: (su0.sol:778-925): Unreachable code.
// Warning 5740: (su0.sol:965-996): Unreachable code.
// Warning 5740: (su0.sol:1019-1030): Unreachable code.
// Warning 6133: (su0.sol:562-566): Statement has no effect.
// Warning 5667: (su0.sol:74-81): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:82-92): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:93-103): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:237-246): Unused local variable.
// Warning 2072: (su0.sol:603-610): Unused local variable.
// Warning 2072: (su0.sol:612-627): Unused local variable.
// Warning 5667: (su0.sol:935-945): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:947-955): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1702-1734): Unused local variable.
// Warning 5667: (su0.sol:1902-1911): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1921-1930): Unused local variable.
// Warning 2072: (su0.sol:2072-2081): Unused local variable.
// Warning 6133: (su0.sol:3342-3402): Statement has no effect.
// Warning 5667: (su0.sol:2880-3033): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3034-3080): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1869-2099): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:2868-3405): Function state mutability can be restricted to pure
