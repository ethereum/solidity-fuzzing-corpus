
==== Source: su0.sol ====
struct St0 {
  mapping(uint176 => bytes14) el0;
  uint152 el1;
  uint24 el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  function f0() private      {
    if (false)
    {
    }
  }
  receive() external   payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 12490180234687520657}("");
    return;
  }
  function f2(uint48 i0,int8 i1) private     returns(bytes7 o0)  {
    (o0) = (((((bytes7(0x04ef381e955e47) | (true ? bytes7(0xfa2141c29dc2d2) : bytes7(0x8273fdced5c594))) | bytes7(0xf4e13ed84416cd)) | bytes7(0x00000000000000)) | bytes7(0x00000000000000)));
    assert(o0 == ((((bytes7(0x04ef381e955e47) | (true ? bytes7(0xfa2141c29dc2d2) : bytes7(0x8273fdced5c594))) | bytes7(0xf4e13ed84416cd)) | bytes7(0x00000000000000)) | bytes7(0x00000000000000)));
    if (i1 > (hex"0000000000000000000000000000000000000000000000000000000000" f3 /*suffix expr*/ - i1))
    {
    }
    (o0) = ((bytes4(0xffffffff) ^ bytes4(0x00000000)));
    assert(o0 == (bytes4(0xffffffff) ^ bytes4(0x00000000)));
  }
  function f4(function (function (int176, address, int88) external   returns (uint200, uint56), uint80) external   returns (uint208, function () external   returns (bytes16[4] memory, bool), address payable) i0) public virtual    returns(bytes memory o0)  {
    return (bytes(string("This is a really long string that must ideally be random but is currently hard coded")));
  }
  function f5(function (address) external   i0) external   payable  returns(function (function (bool, function () external   returns (address, address payable, bool)) external   returns (uint136), bool, bytes12) external   returns (uint160, address payable) o0)  {
    do
    {
      break;
    }
    while (false);
    if (true)
    {
    }
  }
  St0   s0;
  bytes19  public s1;
  bool   s2 = true;
  bool   s3;
  constructor(bytes19 i0,bool i1)   {
    s1 = ((false ? (~((~(bytes19(0x00000000000000000000000000000000000000))))) : bytes19(0x00000000000000000000000000000000000000)) & bytes19(0xffffffffffffffffffffffffffffffffffffff));
    s3 = false;
    unchecked {
    }
  }
}
function f3(bytes29 i0) pure suffix  returns(int8 o0)
{
  address payable[][1] memory l0 = (false ? [new address payable[](7)] : [new address payable[](7)]);
  do
  {
    (o0, l0[(false ? ((uint256(99441815147004999449704256202943019768012139975026662883067756531585482458926) & (uint256(72336952340279192633057888542165669584003602077792177184168700194837089578669) ** uint208(uint208(172668978237027744616995848752608216133844579522927465200875037)))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))], l0[((((uint256(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) + uint256(0)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) - uint256(57873714040693782032458267130205548168881801593478887572681001739338898625875)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]) = (int8(127), new address payable[](7), new address payable[](7));
    assert(o0 == int8(127));
    continue;
  }
  while (false);
  if (i0 >= (~(bytes27(0x000000000000000000000000000000000000000000000000000000))))
  {
    o0 &= (int8(0) * ((((int8(0) % int8(127)) + int8(0)) + int8(0)) ^ int8(0)));
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49
}
// ====
// ----
