
==== Source: su0.sol ====
struct St0 {
  mapping(bool => uint224) el0;
}
function f0(bool i0,address payable i1)     {
  if (i0)
  {
    for(    [string("This is a really long string that must ideally be random but is currently hard coded")];
;
((bytes27(0x40857f1ca421eaf15db30834a6a3dc17bd60b95cba4a3556e9e8a1) & bytes27(((~(bytes16(0x00000000000000000000000000000000))) & bytes16(0x00000000000000000000000000000000)))) | bytes27(0x000000000000000000000000000000000000000000000000000000)))
    {
      if (i1 < payable(address((true ? 0x0000000000000000000000000000000000000000 f1 /*suffix expr*/ : (hex"000000000000000000000000000000000000000000000000000000000000" f2 /*suffix expr*/ & bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))))))
      {
        continue;
      }
    }
  }
}
pragma solidity >= 0.0.0;
function f1(address i0) pure suffix  returns(bytes20 o0)
{
  o0 ^= bytes20(address(0xA1A481c40c3C9c47AE449432fFe79d960A24A6Bb));
}
function f2(bytes30 i0) pure suffix  returns(bytes20 o0)
{
}

==== Source: su1.sol ====
struct St1 {
  bool el0;
}
function f3(int160 i0)    pure suffix returns(St1 memory o0){
  for(;
hex"000000000000000000000000000000000000000000" f4 /*suffix expr*/;
((true == false) ? new address[](1) : new address[](1)))
  {
    return (St1(true));
  }
}
pragma solidity >= 0.0.0;
function f4(bytes21 i0) pure suffix  returns(bool o0)
{
}
// ====
// ----
