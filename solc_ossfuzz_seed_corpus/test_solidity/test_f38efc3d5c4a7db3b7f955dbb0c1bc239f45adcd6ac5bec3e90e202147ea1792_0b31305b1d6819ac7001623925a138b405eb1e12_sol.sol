
==== Source: su0.sol ====
bool constant cons0 = false;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63

}
pragma solidity >= 0.0.0;
library L0 {
  function f0() external   
  {
  }
  modifier m0(bool i0) 
  {
    _;
  }
  function f1(string memory i0,address i1) external    returns(bool o0,address payable o1)
  {
  }
  modifier m1(int216 i0) 
  {
    _;
  }
  error er0();
  int24 public constant cons1 = ((~((((int24(8388607) | int24(-4698452)) ^ int24(0)) ^ int24(8388607)))) | int24(8388607));
  modifier m2() 
  {
    require(false, string("00000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff"));
    bytes("ffffffffffa996");
    _;
  }
}

==== Source: su1.sol ====
uint224 constant cons2 = uint224(26959946667150639794667015087019630673637144422540572481103610249215);
contract C0 {
  int240  public s0 = int240(-402854854565558654833403161830095065053941874051487154079776126920974082);
  bytes2   s1;
  bytes8[2]  public s2 = [bytes8(0x0000000000000000), bytes8(0x0000000000000000)];
  address   s3 = address(this);
  constructor(bytes2 i0) payable  {
    s1 &= bytes2(0xd187);
    unchecked {
      for(;
;
payable(address(this)))
      {
        continue;
      }
      uint232 l0 = (~(uint232(6901746346790563787434755862277025452451108972170386555162524223799295)));
      s2[0] &= s2[0];
      if (((bytes15(0xefc7fd6df0ddd786241ca6d85d2217) != bytes15(0x000000000000000000000000000000)) && ((bytes26(0x0000000000000000000000000000000000000000000000000000) > bytes26(0xd05368682ccdce89b875fb8d500e780df694cfa2756a213bebb3)) || false)))
      {
        (uint80(1208925819614629174706175) >> uint120((uint120(1329227995784915872903807060280344575) & ((uint120(1329227995784915872903807060280344575) & uint120(0)) - uint120(0)))));
        (bool l1, bytes memory l2) = address(this).call("1297fe2a29b6309b4c02f6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      }
    }
  }
  function f2(bytes27 i0) external virtual   returns(uint104 o0)
  {
    if (false)
    {
    }
    else if ((false && (!(false))))
    {
      (s2[1], s2[1]) = (bytes8(0x9f8d4dcccb09a3af), bytes8(0xffffffffffffffff));
    }
    else
    {
      if (true)
      {
        s2[1] ^= bytes8(0xffffffffffffffff);
        (bool l0, bytes memory l1) = address(this).call("d1396370b5e13cc2fb449f8d73fc5b12d786a184c3aa");
      }
      else if ((!(true)))
      {
        s2[1] ^= (s2[1] = bytes8(0x0000000000000000));
      }
      assert((((~(((int136(16913467725378742101843261013391624804479) | int136(0)) ** uint8(uint8(0))))) | int136(0)) >= int136(41269468854658749281940240030706490191479)));
    }
    for(;
;
int80(((((int80(-116633199396843434726575) & (~(int80(-404887082118924656350708)))) & int80(-219107527350922250705434)) ^ int80(604462909807314587353087)) / int80(0))))
    {
      s2[1] = bytes8(0x48bd216b573f7c76);
    }
  }
  bytes20 public constant cons3 = bytes20(address(0x0000000000000000000000000000000000000000));
  fallback() external   
  {
  }
  event ev0(bytes8  ep0);
  event ev1(bytes  ep0, int32  ep1, bytes29 indexed ep2);
  modifier m3() virtual
  {
    _;
  }
  modifier m4() 
  {
    _;
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  string el0;
  uint120 el1;
  address payable[] el2;
}
// ====
// ----
