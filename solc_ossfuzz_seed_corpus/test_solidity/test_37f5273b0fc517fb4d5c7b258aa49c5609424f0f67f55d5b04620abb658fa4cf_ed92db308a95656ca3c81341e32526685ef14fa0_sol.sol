
==== Source: su0.sol ====
contract C0 {
  int112  public s0;
  constructor(int112 i0)   {
    s0 |= int104(0);
    {
    }
  }
  fallback() external   
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("be6cc9334369f9164bbcf13229bb8d81fc17f6282345b3f37c092361276add6dffffffffffffffff"));
  }
  function f1(int112 i0,int112 i1,int112 i2) public virtual     {
    require(true);
  }
  event ev0(function (bool, bool, bytes16) external   returns (int112[] memory, uint192, uint32)  ep0, bytes14 indexed ep1) anonymous;
}
contract C1 is C0 {
  receive() external virtual  payable
  {
  }
  C0 immutable  s1 = C0(address(this));
  constructor(int112 i0) payable C0(int112(2596148429267413814265248164610047))
  {
    s0 -= (-(int112((int112(396549673572600697748917341396889) / ((-((int112(2596148429267413814265248164610047) % int112(0)))) % int112(-2154278105177147941216270611497874))))));
    unchecked {
    }
  }
  error er0(int104 ep0, uint184 ep1);
  function f3() private      {
    s0 -= int112(2596148429267413814265248164610047);
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  function f1(int112 i0,int112 i1,int112 i2) public override  
  {
  }
}
pragma solidity >= 0.0.0;
contract C2 {
  bytes   s2 = bytes("b188f1ffffffffffffffffffffffff");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint120  public s3;
  constructor(uint120 i0)   {
    s3 /= uint120(0);
    unchecked {
    }
  }
  struct St0 {
    bool el0;
    bytes32 el1;
  }
  event ev1(bytes7  ep0, string  ep1, uint224  ep2);
}
function f5()     {
  bool l0 = false;
}

==== Source: su1.sol ====
bytes4 constant cons0 = bytes4(0x7148875a);
pragma solidity >= 0.0.0;
struct St1 {
  address el0;
  mapping(int144 => uint200) el1;
  address el2;
  uint160 el3;
}
// ====
// ----
