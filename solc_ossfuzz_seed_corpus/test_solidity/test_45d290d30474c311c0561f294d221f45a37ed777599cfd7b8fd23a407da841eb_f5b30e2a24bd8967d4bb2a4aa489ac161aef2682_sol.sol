
==== Source: su0.sol ====
contract C0 {
  error er0(address ep0, uint248 ep1);
  address  public s0 = address(this);
  uint184 immutable public s1;
  mapping(address => bool)   s2;
  constructor(uint184 i0)   {
    s1 = uint184(19669793320054063718028930792857198707594158508765513727);
    s2[address(bytes20(address(0x0000000000000000000000000000000000000000)))] = (false ? (payable(address(this)) >= (true ? payable(address(this)) : payable(address(this)))) : false);
    unchecked {
    }
  }
  event ev0(bytes17  ep0);
  function f0(bool i0) external virtual  payable  returns(bytes memory o0)  {
  }
  receive() external   payable
  {
    return;
  }
  bytes14 public constant cons0 = bytes14(0xffffffffffffffffffffffffffff);
  struct St0 {
    function (int80) external   returns (bool, bytes memory, uint48) el0;
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  bool el0;
  bytes27 el1;
}
type T0 is address;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }





function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) | bytes20(T0.unwrap(y)))); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) & bytes20(T0.unwrap(y)))); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) ^ bytes20(T0.unwrap(y)))); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(address(~bytes20(T0.unwrap(x)))); }






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }




==== Source: su1.sol ====
contract C1 {
  error er1(int16 ep0);
  receive() external virtual  payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 4478723621062086762}("");
  }
  type T1 is uint56;
  address   s3;
  bool immutable  s4 = false;
  address payable   s5;
  int152 immutable  s6 = int152(-2273316978372792260287487392889657941334681736);
  constructor(address i0,address payable i1) payable  {
    s3 = msg.sender;
    s5 = 374144419156711147060143317175368453031918731001855 f3 /*suffix expr*/;
    unchecked {
    }
  }
  function f4() external virtual     {
    revert er1(((((-(((int16(0) ** uint216(uint216(105312291668557186697918027683670432318895095400549111254310977535))) | int16(32767)))) + int16(32767)) ^ int16(32767)) & int16(-6891)));
  }
}
pragma solidity >= 0.0.0;
function f3(uint168 i0) pure suffix  returns(address payable o0)
{
}
// ====
// ----
