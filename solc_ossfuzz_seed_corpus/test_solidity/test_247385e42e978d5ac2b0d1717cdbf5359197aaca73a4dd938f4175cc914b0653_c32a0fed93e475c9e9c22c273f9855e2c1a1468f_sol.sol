
==== Source: su0.sol ====
struct St0 {
  int248 el0;
  address payable el1;
  uint200[10] el2;
  int176 el3;
}
struct St1 {
  int216 el0;
  bytes30 el1;
}
contract C0 {
  struct St2 {
    bytes15 el0;
  }
  address payable  public s0 = payable(address(this));
  address  public s1;
  mapping(uint80 => bytes32)  public s2;
  uint8  public s3;
  constructor(address i0,uint8 i1)   {
    s1 = (true ? msg.sender : (false ? address(bytes20(address(0x0000000000000000000000000000000000000000))) : address(this)));
    s3 &= uint8(255);
    s2[uint80(366540827226260829588377)] ^= (hex"0000000000" f0 /*suffix expr*/ & bytes32(0x0000000000000000000000000000000000000000000000000000000000000000));
    {
      do
      {
        if (i0 < (true ? address(this) : address(this)))
        {
          if (i1 < (uint8(((uint8(255) * uint8(255)) / (uint8(241) + uint8(123)))) + uint8(71)))
          {
            break;
          }
          else
          {
            continue;
          }
          (bool l0, bytes memory l1) = payable(this).call{value: 8926805104472762515}("");
          if (i1 > (uint8(0) & uint8(255)))
          {
            (s1) = (address(this));
            assert(s1 == address(this));
            continue;
          }
        }
      }
      while (true);
    }
  }
  receive() external virtual  payable
  {
  }
}
pragma solidity >= 0.0.0;
function f0(bytes5 i0) pure suffix  returns(bytes32 o0)
{
}

==== Source: su1.sol ====
contract C1 {
  error er0(function (address, bool) external  [2] ep0);
  error er1();
  bool immutable public s4 = true;
  address payable  public s5 = payable(address(this));
  mapping(address => bool)   s6;
  function (uint192) external   returns (int128, bool)[]  public s7;

	function compareMemoryAndStorage(function (uint192) external   returns (int128, bool)[] memory v1, function (uint192) external   returns (int128, bool)[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(function (uint192) external   returns (int128, bool)[] memory i0)   {
    s7 = i0;
    s6[address(this)] = ((int160(730750818665451459101842416358141509827966271487) * int160(595113527897697161979681646245672904893615295432)) >= (int160((int160(730750818665451459101842416358141509827966271487) / int160(730750818665451459101842416358141509827966271487))) + int160(730750818665451459101842416358141509827966271487)));
    unchecked {
    }
  }
  function f2() external virtual  payable   {
  }
  type T0 is bytes2;
}
contract C2 {
  bytes5   s8;
  bool  public s9 = false;
  uint248 immutable  s10 = uint248(55963304746917483766362239815726566657846682856314320711552763086367327437);
  mapping(C1 => bytes11[7])[]   s11;
  constructor(bytes5 i0)   {
    s8 |= bytes5(0x0000000000);
    {
    }
  }
  function f3(bool i0,uint248 i1) public virtual    returns(function (C1[] memory, bytes25) external   returns (C1.T0, address, uint8) o0,uint216 o1)  {
    return (o0, (uint216(2363690412704496275331312876594060137480533697206565018506537161) >> uint72((uint72((uint96(9659905636494337362711236973) - uint96(6193781444903288683780271917))) ^ uint72(0)))));
  }
  event ev0(uint112  ep0, bool  ep1);
  function f4() public virtual  payable  returns(bytes22 o0,bool o1,bytes17 o2)  {
    if (false)
    {
      s11.pop();
    }
    if (false)
    {
      s11.push();
      emit ev0((uint64(18446744073709551615) & (((uint112(5192296858534827628530496329220095) & uint112(5192296858534827628530496329220095)) + uint112(5192296858534827628530496329220095)) << uint168(uint168(0)))), false);
    }
    o0 &= bytes22(bytes23(0x0000000000000000000000000000000000000000000000));
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
