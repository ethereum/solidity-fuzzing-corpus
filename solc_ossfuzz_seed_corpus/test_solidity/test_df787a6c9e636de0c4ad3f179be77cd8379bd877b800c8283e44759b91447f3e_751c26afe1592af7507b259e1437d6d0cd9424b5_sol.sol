==== Source:  ====

==== Source: su0.sol ====
function f0(uint120 i0,function (int72, bytes4) external   returns (address, int224[] memory, address) i1,bool[4] memory i2)      returns(bytes28 o0,bool o1){
  if (true)
  {
    try i1((int72(2361183241434822606847) - int72(((((int72(0) - int72(0)) - int72(2361183241434822606847)) % int72(2147329852994711537519)) / int72(0)))),(bytes4(0x00000000) ^ hex"00000000" f1 /*suffix expr*/)) returns (address l0, int224[] memory l1, address l2)
    {
      o1 = i2[uint256(76558835924878531028588189035993887303269397614368787882679878492092723943067)];
      assert(o1 == i2[uint256(76558835924878531028588189035993887303269397614368787882679878492092723943067)]);
    }
    catch
    {
      o0 &= bytes28(0x00000000000000000000000000000000000000000000000000000000);
    }
    catch Panic(uint256 l3)
    {
      o0 |= 0x0000000000000000000000000000000000000006 f2 /*suffix expr*/;
      int72 l4 = (int72(2361183241434822606847) + (int72(-899096388102321367915) & ((int72(0) * int72(2233280985001193559629)) ** uint120(uint120(0)))));
      delete i2[(((uint256((((uint256(0) + uint256(112942578079290157368506452695693633749134656348558960440643178969770213162475)) + uint256(0)) / uint256(0))) ** uint32(uint32(4294967295))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(112313830850181812255096790039826249026933433940253688706280185451170595680854))];
    }
    o0 ^= bytes28(bytes11(0xd3a5a000eef0b65c266577));
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
  }
  int8 public constant cons0 = -42;
  mapping(bool => address)  public s0;
  bool  public s1 = false;
  constructor()   {
    s0[false] = address(this);
    unchecked {
    }
  }
  function f4() private     returns(function () external   returns (bool) o0,uint104 o1)  {
    do
    {
      for(uint solinit0 = 0; solinit0 < ((false ? uint256(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(int256(0))) / uint256(0))) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
      {
        continue;
      }
      break;
    }
    while (false);
  }
  type T0 is bool;
}
uint16 constant cons1 = 65535;
function f1(bytes4 i0) pure suffix  returns(bytes4 o0)
{
}
function f2(address i0) pure suffix  returns(bytes28 o0)
{
}

==== Source: su1.sol ====
type T1 is bool;

using {



eq1 as ==, neq1 as !=

} for T1 global;






function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



function f5(int144 i0)    pure suffix returns(uint24 o0){
  if (i0 >= 1766847064778384329583297500742918515827483896875618958121606201292619775 f6 /*suffix expr*/)
  {
  }
  (o0) = (uint24(0));
  assert(o0 == uint24(0));
}
pragma solidity >= 0.0.0;
contract C1 {
  receive() external virtual  payable
  {
    return;
  }
  bool  public s2 = false;
  address payable  public s3;
  T1  public s4;
  bytes17   s5 = bytes17(0xa3f729803ad3fe157e8e4cafefe38fba87);
  constructor(address payable i0,T1 i1)   {
    s3 = payable(address(this));
    s4 = T1.wrap(false);
    unchecked {
    }
  }
  event ev0(uint232  ep0);
}
function f6(uint240 i0) pure suffix  returns(int144 o0)
{
}
// ----
// Warning 3149: (su0.sol:963-1028): The result type of the exponentiation operation is equal to the type of the first operand (int72) ignoring the (larger) type of the second operand (uint120) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:2197-2202): Unreachable code.
// Warning 5667: (su0.sol:12-22): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:396-406): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:408-426): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:428-438): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:786-796): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:885-893): Unused local variable.
// Warning 5667: (su0.sol:1769-1809): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1810-1820): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:725-743): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:744-749): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1735-2208): Function state mutability can be restricted to pure
