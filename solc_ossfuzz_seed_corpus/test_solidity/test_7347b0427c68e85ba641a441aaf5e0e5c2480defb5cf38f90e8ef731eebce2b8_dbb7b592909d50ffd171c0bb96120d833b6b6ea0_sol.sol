
==== Source: su0.sol ====
type T0 is int88;
library L0 {
  uint72 public constant cons0 = uint72(((((uint72(0) >> uint256((uint256(99293371030229789500179326671658433393589431878487977839715563816518379785692) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))) * uint72(4722366482869645213695)) * uint72(4722366482869645213695)) / uint72(2570614349685994529636)));
  error er0();
  using L0 for *;
  function f0() public   
  {
  }
  type T1 is address payable;
  bytes29 public constant cons1 = bytes29(0x0000000000000000000000000000000000000000000000000000000000);
  modifier m0() 
  {
    for(;
;
)
    {
      continue;
      if ((false ? ((((uint192(0) ^ uint192(5533656053766901608500513618072425997560873799101627248022)) % uint192(6277101735386680763835789423207666416102355444464034512895)) > uint192(3629619872673565978463252765726673731725779186126589636323)) || false) : false))
      {
        _;
      }
      else
      {
      }
    }
    _;
    _;
    if (true)
    {
      while ((true && false))
      {
        assembly
        {
        }
      }
      revert er0();
      assert((false || true));
    }
    else if ((bytes15(bytes28(0xc7a26fb7e458c7f2d7106ad28f209a984bfa89377b287654f619c2dc)) == bytes15(0xe12a1e6fab6e9ab6b97de3555b0705)))
    {
      if (false)
      {
        _;
      }
      else
      {
        _;
        _;
      }
    }
  }
}
contract C0 {
  bytes16[]   s0 = [bytes16(0x7cfd5605ffdd5f7db48bea78f94a000e)];
  bool  public s1;
  bytes24  public s2;
  constructor(bool i0,bytes24 i1)   {
    s1 = false;
    s2 |= bytes24(0x000000000000000000000000000000000000000000000000);
    unchecked {
      if ((false && false))
      {
      }
    }
  }
  event ev0();
  using L0 for *;
  function f1(L0.T1 i0,T0 i1) external virtual  payable
  {
    this.f1({i0: L0.T1.wrap(payable(address(0x0000000000000000000000000000000000000007))), i1: T0.wrap(int88(154742504910672534362390527))});
  }
  function f2() external virtual   returns(function () external   returns (bytes memory, uint80) o0)
  {
  }
  fallback() external   
  {
    revert("74e9b605b7608adca384facdbf4da755955d0489448a5386100d000000000000000000000000000000000000");
    if (true)
    {
      s0.push(bytes16(0x00000000000000000000000000000000));
    }
    else
    {
      if (false)
      {
      }
      else if (((bytes18(0xffffffffffffffffffffffffffffffffffff) != bytes18(0xffffffffffffffffffffffffffffffffffff)) || (s1 = true)))
      {
      }
    }
  }
  event ev1(bool  ep0);
  receive() external   payable
  {
    delete s0[1];
    try this.f1(L0.T1.wrap(payable(address(0x0000000000000000000000000000000000000008))),T0.wrap(int88(0)))
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 8186798822425813279}("");
    }
    catch
    {
    }
    catch Panic(uint256 l2)
    {
      s0.pop();
    }
    try this.f1(L0.T1.wrap(payable(address(0x0000000000000000000000000000000000000001))),T0.wrap(int88(154742504910672534362390527)))
    {
      s0.pop();
      function (bool, function (bytes20, L0.T1) external   returns (uint152, uint120), bytes memory) external   returns (bool, bytes19) l3;
    }
    catch
    {
    }
    if ((uint80((uint80(1208925819614629174706175) / uint80(1208925819614629174706175))) < (uint80(0) ** uint160(uint160(251930323905611122832908285498142798993298254670)))))
    {
      (function () external   returns (bytes memory, uint80) l4) = this.f2();
    }
  }
  type T2 is int112;
  struct St0 {
    bool el0;
    mapping(bool => address) el1;
    mapping(int40 => bytes1) el2;
    address el3;
  }
}
struct St1 {
  function (int216, int120, address) external   returns (uint160) el0;
  address payable el1;
  bool el2;
}
pragma solidity >= 0.0.0;
// ====
// ----
