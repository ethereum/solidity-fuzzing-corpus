
==== Source: su0.sol ====
error er0();
pragma solidity >= 0.0.0;
function f0()      returns(function (bool) external   returns (uint216, bool, address) o0){
  int56 l0 = (int56(((int56(-7780349532526647) ^ int56((int56(0) / int56(36028797018963967)))) / int56(0))) + int56(19482609045413151));
}
struct St0 {
  address payable el0;
  string el1;
  mapping(bool => bool) el2;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bool[1] el0;
  int160 el1;
  bytes25 el2;
}
contract C0 {
  event ev0();
  uint88   s0;
  constructor(uint88 i0) payable  {
    s0 = (uint88((((uint88(137745735335207986452132316) - (true ? uint88(309485009821345068724781055) : uint88(309485009821345068724781055))) % uint88(309485009821345068724781055)) / uint88(33878387022513683610384685))) >> uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)));
    unchecked {
    }
  }
  fallback() external virtual  
  {
    s0 += uint88(0);
    return;
  }
  struct St2 {
    address[7] el0;
    function (bytes27, int152) external   el1;
    uint176 el2;
    string el3;
  }
  receive() external   payable
  {
    if (false)
    {
      require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
      if (((uint136((((uint136(0) * uint136(0)) & uint136(0)) / uint136(0))) ^ uint136(82959495526585304706249519443507018243255)) >= uint136(0)))
      {
        emit ev0();
      }
    }
    else
    {
      for(uint solinit0 = 0; solinit0 < (uint256(20870125694413048584520436724443950909400812999225282516317784774283552621516) % 11); solinit0++)
      {
        if (false)
        {
          break;
        }
        else
        {
          (bool l0) = payable(this).send(0);
          emit ev0();
        }
        if (true)
        {
          emit ev0();
        }
        else if (true)
        {
          payable(this).transfer(11634627861212393949);
          if (false)
          {
            bool l1 = ((uint56(0) % uint56(0)) >= ((uint56(0) % uint56(0)) + uint56(0)));
          }
          else
          {
            while (true)
            {
            }
            if (true)
            {
              continue;
            }
            do
            {
              s0 >>= uint88(((((uint88((uint88(0) / uint88(0))) ^ uint88(309485009821345068724781055)) | uint88(309485009821345068724781055)) % uint88(277225401367243894907866795)) / uint88(120633607189128426055946327)));
              if (true)
              {
                assert(true);
                break;
              }
              while (false)
              {
                s0 >>= (((uint88((uint88(0) / uint88((uint88(309485009821345068724781055) / uint88(0))))) ^ uint88(309485009821345068724781055)) | uint88(0)) - uint88(54786321298329556736864417));
              }
            }
            while (true);
          }
        }
      }
    }
  }
}
contract C1 {
  event ev1(function (int56) external   returns (bool, bytes20)  ep0, bytes  ep1, function () external   returns (address)[5] indexed ep2);
  C0  public s1 = C0(payable(address(this)));
  mapping(bytes18 => bytes19)   s2;
  bytes17  public s3 = bytes17(0xbbd08fe6977b6b2155ece510d25e01ac83);
  constructor()   {
    s2[((~(bytes18(0xd4ea9799d6308ab8841ca25d7190d68fcce7))) ^ (bytes18(0xdf344f74ab2bd46907e692955a86fdcb0c53) ^ (bytes18(0x000000000000000000000000000000000000) | bytes18(0xffffffffffffffffffffffffffffffffffff))))] &= bytes19(0x5ff352d5d0d696ece18180aecaf2ef89b82756);
    unchecked {
    }
  }
  function f3() public   payable   {
  }
}
// ====
// ----
