
==== Source: su0.sol ====
contract C0 {
  int48   s0;
  constructor(int48 i0)   {
    s0 -= (((int48(-60861360004729) % int48(4946668006912)) * (int48(52192147632089) & int48(140737488355327))) & int48(0));
    {
    }
  }
  fallback() external virtual  
  {
  }
  struct St0 {
    address el0;
    address payable el1;
    function (address payable, uint152) external   returns (int72, int48) el2;
    uint72 el3;
  }
}
contract C1 {
  function f1() public      {
    assert(false);
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    (bool l2, bytes memory l3) = payable(this).call{value: 16950072249562292330}("");
  }
  receive() external   payable
  {
    bytes13 l0 = bytes13(0xffffffffffffffffffffffffff);
    (uint40(631202843678) ^ ((uint40(0) + (uint40(906633903364) + uint40(13085621805))) + uint40(0)));
  }
  fallback() external   
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 17773297602833884399}("");
  }
  error er0(bool ep0);
  mapping(uint160 => address)  public s1;
  bytes14[9]   s2;

	function compareMemoryAndStorage(bytes14[9] memory v1, bytes14[9] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int24  public s3;
  int24   s4 = int24(953882);
  constructor(bytes14[9] memory i0,int24 i1)   {
    s2 = i0;
    s3 &= 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f4 /*suffix expr*/;
    s1[(uint160(((((uint160(0) | uint160(1461501637330902918203684832716283019655932542975)) * uint160(1356367200654610975948201043494591344056812601927)) << uint136(uint136(87112285931760246646623899502532662132735))) / uint160(1461501637330902918203684832716283019655932542975))) * uint160(0))] = s1[(((payable(address(this)) == payable(address(bytes20(address(0x6eeD2BfC4d0277074De09BB9Ed5a064e7D7562c3))))) ? uint160(1461501637330902918203684832716283019655932542975) : uint160(0)) | uint160(89047358290141757017601412922727717903492357583))];
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
contract C2 is C0 {
  int80   s5;
  bytes8   s6;
  uint72   s7 = uint72(3209960785441752051623);
  constructor(int48 i0,int80 i1,bytes8 i2)  C0(((int40(326539922927) + (~((int40(-219893276995) ** uint240(uint240(158579826646958778288672186752195538714207052931341918723643950781760062)))))) & int48(-3503501012665)))
  {
    s0 *= (int16(32767) - (int48(-49911397935784) * int48(31340770866762)));
    s5 -= int80(-557265886935365941842302);
    s6 |= bytes8(bytes6(bytes23(0x0000000000000000000000000000000000000000000000)));
    {
    }
  }
  function f5(int80 i0) external     returns(function (int232) external   returns (bool, string[5] memory, C1) o0,int64 o1)  {
    int48  l0 = s0;
    int48  l1 = l0;
    assert(l1 == s0);
  }
  fallback() external virtual override  
  {
  }
}
function f4(address i0) pure suffix  returns(int24 o0)
{
  function (C0.St0 memory, C0.St0 memory, bool) external   returns (bool) l0;
  return (((int24(8388607) * (int24((int24(0) / int24(0))) * int24(0))) | int24(6185587)));
}

==== Source: su1.sol ====
struct St1 {
  mapping(int32 => address) el0;
  address el1;
}
struct St2 {
  bool el0;
  bytes22 el1;
  bool el2;
  uint160 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
