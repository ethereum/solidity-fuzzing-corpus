
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(uint24 indexed ep0, address indexed ep1);
  bytes23   s0;
  mapping(bool => int184)   s1;
  constructor(bytes23 i0)   {
    s0 |= bytes5(0x0000000000);
    s1[(payable(address((ripemd160(bytes("ffffffffffffffffffffffffffffffffffffffffffff512f679c33cb9baef8e91ba0441fbac23b2ef9b4571ff64862cb8b62")) ^ (~(bytes20(address(0xBb635b8f4270C300C5BA350D5CB1354B5EBF3f72))))))) > payable(address(this)))] |= int184(12259964326927110866866776217202473468949912977468817407);
    unchecked {
    }
  }
  fallback() external   
  {
    return;
  }
}
contract C1 is C0 {
  function f1(bytes23 i0,bytes10 i1) public   payable  returns(function (address payable, uint248) external   returns (bytes32, address) o0,function (C0, uint184, bytes28) external   returns (bytes31[] memory, bool) o1)  {
  }
  uint120   s2;
  int8   s3 = int8(0);
  address   s4 = address(this);
  constructor(bytes23 i0,uint120 i1)  C0((i0 ^= (bytes23(0x0000000000000000000000000000000000000000000000) & bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff))))
  {
    s0 &= bytes23(bytes1(0x11));
    s2 >>= (uint120(207496651787956510892532913379928847) * (((~((uint120(1230884931205196693141164728259677677) ^ uint120(0)))) >> uint128(uint128(150227897665533777595849665960533568830))) ^ uint120(0)));
    s1[false] = int184(12259964326927110866866776217202473468949912977468817407);
    unchecked {
    }
  }
}

==== Source: su1.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24
}
pragma solidity >= 0.0.0;
import "su0.sol";
struct St0 {
  EN0 el0;
  address el1;
  bool el2;
  uint192 el3;
}
// ====
// ----
