
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
  }
  receive() external virtual  payable
  {
    if (false)
    {
      return;
    }
    else if (false)
    {
      bytes13 l0 = (bytes13(0x00000000000000000000000000) | bytes13(0x00000000000000000000000000));
    }
    if (false)
    {
      for(      string memory l1 = string("This is a really long string that must ideally be random but is currently hard coded");
true;
((uint168((uint168((uint168((uint168(374144419156711147060143317175368453031918731001855) / uint168(374144419156711147060143317175368453031918731001855))) / uint168(0))) / uint168(374144419156711147060143317175368453031918731001855))) != uint168(0)) ? new mapping(uint248 => bool)[](3) : new mapping(uint248 => bool)[](3)))
      {
        continue;
      }
    }
  }
  bytes   s0;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  int256   s1;
  uint16   s2;
  mapping(address => bytes19)   s3;
  constructor(bytes memory i0,int256 i1,uint16 i2)   {
    s0 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000");
    s1 -= (int256(-42281985045684545301508527261050545566119081606764229462086730875291500008045) - int256(57896044618658097711785492504343953926634992332820282019728792003956564819967));
    s2 /= ((((((uint16(0) & uint16(25556)) ** uint232(uint232(0))) ^ uint16(51349)) & uint16(11436)) + uint16(0)) + uint16(14527));
    s3[address(this)] |= bytes19(0xffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  error er0();

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(bytes calldata i0,bytes calldata i1,address i2) external     returns(bytes17 o0,bytes31 o1,address o2)  {
    (bool l0) = payable(this).send(8608930663460826359);
  }
}
struct St0 {
  string el0;
  address payable el1;
  function (bool, bool) external   returns (uint16, address, uint88) el2;
  uint144 el3;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
