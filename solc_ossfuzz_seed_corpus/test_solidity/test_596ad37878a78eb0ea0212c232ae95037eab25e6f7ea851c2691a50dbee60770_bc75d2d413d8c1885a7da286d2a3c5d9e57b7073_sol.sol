
==== Source: su0.sol ====
struct St0 {
  bytes27 el0;
  int80 el1;
  address el2;
  int128 el3;
}
contract C0 {
  uint240  public s0 = uint240(0);
  bool   s1;
  mapping(bool => uint64)  public s2;
  constructor(bool i0) payable  {
    s1 = false;
    s2[((bytes9(0xb179e340c10c30b5f5) ^ (bytes9(0xffffffffffffffffff) | bytes8(0xffffffffffffffff))) >= bytes9(0x000000000000000000))] %= (uint64(0) + uint64(0));
    {
    }
  }
  error er0();
  error er1(int120 ep0);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
error er2(function (function (bytes7) external  , int40, address payable) external   returns (int224, uint176) ep0);
contract C1 {
  function f0() private     returns(address payable o0)  {
    o0 = payable(address(bytes20(address(0x59D45982a403Be18BdA538656f8Abaa218478A78))));
    assert(o0 == payable(address(bytes20(address(0x59D45982a403Be18BdA538656f8Abaa218478A78)))));
  }
  function f1() private     returns(bool o0)  {
    bool l0 = true;
  }
  bool   s3 = true;
  int8  public s4 = int8(-82);
  uint80   s5;
  constructor(uint80 i0)   {
    s5 -= uint80(((uint80(1208925819614629174706175) % (((uint80(1208925819614629174706175) + uint80(0)) >> uint184(uint184(8543792696707623401814349607774212531910657715733378451))) & uint80(0))) / uint80(0)));
    unchecked {
      bool  l0 = s3;
      bool  l1 = l0;
      assert(l1 == s3);
    }
  }
}
pragma solidity >= 0.0.0;
contract C2 is C1 {
  function f2() public      {
  }
  event ev0();
  uint160   s6 = uint160(1461501637330902918203684832716283019655932542975);
  constructor(uint80 i0)  C1((uint80(((~(((true ? uint80(0) : uint80(508651551052551355265848)) >> uint160(uint160(1167907502613508414156918643438304484648516228682))))) / uint80(803107770884471185223961))) ^ uint80(1208925819614629174706175)))
  {
    s5 %= uint80(0);
    {
    }
  }
  struct St1 {
    bytes28 el0;
    uint176 el1;
    bool el2;
    mapping(bytes15 => bytes7) el3;
  }
}
struct St2 {
  bool el0;
  uint136 el1;
  bytes el2;
}
// ====
// ----
