
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
bool constant cons0 = false;
function f0(function (bool, uint104, int208) external   returns (int80, int80) i0,address i1,uint152 i2)    
{
  assembly
  {
    let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
  }
}
library L0 {
  function f1(bytes memory i0,bool i1) external   
  {
  }
  event ev0();
}
contract C0 {
  event ev1();
  event ev2(int80  ep0) anonymous;
  struct St0 {
    function () external   returns (bool, address) el0;
    bool el1;
  }
  error er0(C0.St0 ep0);
  receive() external virtual  payable
  {
    unchecked {
      if ((false || (!(false))))
      {
      }
      emit ev2((int80(604462909807314587353087) ** uint48((uint48(281474976710655) * ((uint48(16925667550377) ** uint96(uint96(79228162514264337593543950335))) << uint176(uint176(95780971304118053647396689196894323976171195136475135)))))));
      return;
      bytes26 l0 = bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff);
      payable(this).transfer(12054451079957007102);
    }
  }
  bytes3  public s0;
  constructor(bytes3 i0) payable  {
    s0 &= bytes3(0x000000);
    { }
  }
  function f3(address i0,function (uint136, address, int152) external   i1,C0.St0 memory i2) public    returns(function (bytes3) external   returns (uint64, bool, uint184) o0)
  {
  }
  using L0 for *;
  type T0 is address payable;
}
contract C1 {
  function f4(bool i0) internal   
  {
  }
  using L0 for *;
  fallback() external   
  {
    function (uint56[] memory) internal   l0;
    if (false)
    {
      C0.St0 memory l1;
      emit L0.ev0();
    }
    else if ((bytes11(0xe30581349b4f2556275623) != bytes11(bytes11(0xffffffffffffffffffffff))))
    {
    }
    else
    {
      payable(address(this));
    }
    (bool l2, bytes memory l3) = address(this).call("a1716ecd2e114322266a8695e0a9a5a9305845be1000450d");
    do
    {
    }
    while (true);
  }
  modifier m0(function (bytes19, int8) external   returns (C0.T0, C0.T0) i0) virtual
  {
    emit L0.ev0();
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000"));
    _;
  }
  struct St1 {
    mapping(bytes28 => C0.T0[]) el0;
    int24 el1;
    bool el2;
  }
  bool[]   s1 = [false, true];
  function f6(function (C0.T0, uint248) external   returns (bool, bytes20) i0) external    returns(address[2] memory o0,C0.T0 o1,address payable o2)
  {
    return ([address(0x0000000000000000000000000000000000000005), address(0x0000000000000000000000000000000000000002)], C0.T0.wrap(payable(address(0x0000000000000000000000000000000000000002))), payable(address(this)));
    if (false)
    {
    }
  }
}
error er1(address payable ep0);
// ====
// ----
