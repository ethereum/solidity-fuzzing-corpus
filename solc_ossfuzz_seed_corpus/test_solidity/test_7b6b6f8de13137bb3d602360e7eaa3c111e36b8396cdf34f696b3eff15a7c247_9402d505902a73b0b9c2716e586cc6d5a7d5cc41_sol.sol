
==== Source: su0.sol ====
contract C0 {
  bytes8 immutable  s0 = bytes8(0xffffffffffffffff);
  int56   s1 = int56(0);
  address  public s2 = address(this);
  function f0(bytes8 i0,int56 i1) public virtual  payable   {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  bool public constant cons0 = true;
  event ev0();
}
struct St0 {
  int192[1] el0;
  mapping(bool => int48) el1;
  bytes el2;
}
function f1()      returns(uint32 o0){
  if (false)
  {
    if (false)
    {
      (o0) = (uint32(4218844872));
      assert(o0 == uint32(4218844872));
    }
    else if ((address(0x0000000000000000000000000000000000000004) >= address(0x0000000000000000000000000000000000000008)))
    {
      for(uint solinit0 = 0; solinit0 < ((((uint256(((uint256(0) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) * uint256(50067826443668558215856995599854021369231381329399853499554416936555585252425))) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(47817703296260875699831209002435048839750373893621366348372536752496066336179)) % 11); solinit0++)
      {
        continue;
      }
    }
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  bytes11 el0;
  string el1;
}
contract C1 is C0 {
  bool public constant cons1 = true;
  function f2(int56 i0,int56 i1) public virtual    returns(uint24 o0,function (bytes12, uint144, bytes19) external   o1)  {
  }
  bytes17   s3;
  bool   s4 = false;
  int224  public s5 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
  constructor(bytes17 i0)   {
    s3 &= bytes17(0xffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  function f0(bytes8 i0,int56 i1) public virtual override  payable
  {
    if (i0 > (~(bytes8(0x2f49c673a02ff4d1))))
    {
      for(uint solinit1 = 0; solinit1 < ((~(msg.sender.balance)) % 11); solinit1++)
      {
        if (i1 <= (int56(int128(170141183460469231731687303715884105727)) % (~((true ? int56(36028797018963967) : int56(-30196992101407299))))))
        {
          while (((((0x0575Aa651FF7eE6281F0802E22F92767d47CCE0D f5 /*suffix expr*/ & (uint96(76284376587363151912629089048) + uint96(79228162514264337593543950335))) << uint208(uint208(0))) % uint96(0)) >= uint96(79228162514264337593543950335)))
          {
            bytes memory l0 = bytes("0000000000000000000000000000000000000000000000ffffffffffffffffffffffff");
            if (i0 >= bytes8(0xffffffffffffffff))
            {
              for(              St1 memory l1 = St1({el0: bytes11(0x0000000000000000000000), el1: string("This is a really long string that must ideally be random but is currently hard coded")});
false;
(false ? St1(bytes11(0xffffffffffffffffffffff), string("This is a really long string that must ideally be random but is currently hard coded")) : (0 f6 /*suffix expr*/ ? St1(bytes11(0xffffffffffffffffffffff), string("This is a really long string that must ideally be random but is currently hard coded")) : St1({el0: bytes11(0x76b31530e101a0200eac90), el1: string("This is a really long string that must ideally be random but is currently hard coded")}))))
              {
                break;
              }
            }
          }
        }
      }
    }
  }
}
function f3(uint112 i0) pure suffix  returns(uint144 o0)
{
}
function f5(address i0) pure suffix  returns(uint96 o0)
{
}
function f6(uint24 i0) pure suffix  returns(bool o0)
{
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
struct St2 {
  bytes el0;
  uint104 el1;
}
// ====
// ----
