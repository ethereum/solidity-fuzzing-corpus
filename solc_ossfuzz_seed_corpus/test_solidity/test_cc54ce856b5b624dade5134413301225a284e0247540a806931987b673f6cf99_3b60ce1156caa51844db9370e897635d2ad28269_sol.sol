
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    uint248 el0;
  }
  modifier m0(string memory i0,bool i1) virtual
  {
    _;
  }
  event ev0(uint256  ep0, bytes27  ep1);
  modifier m1() virtual
  {
    (bool l0) = payable(this).send(18008473261283838381);
    assert((true || (bytes11(0x0000000000000000000000) <= bytes11(0xffffffffffffffffffffff))));
    if (((true || (false ? true : false)) ? true : true))
    {
      if (true)
      {
        _;
      }
      _;
    }
  }
  type T0 is address;
  C0.T0 public constant cons0 = C0.T0.wrap(address(0x0000000000000000000000000000000000000001));
  receive() external  m0("0a3fd6a60f720c1522500fac7ddbcb723e95e3bd0244a261354ce0193d0e4bff",true) m1() payable
  {
    emit ev0(((((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) ^ uint256(97866646915628440428446701750880396937942147743437256516530139386139503250240)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(0)) - uint256(0)) & uint256(0)) ^ uint256(0)), bytes27(0x49f96283bd94e066333a1e22c65875a9607c39dd840875fde1ea14));
  }
  address  public s0 = address(this);
  C0.St0   s1 = C0.St0(uint248(0));
}
C0.T0 constant cons1 = C0.T0.wrap(address(0x0000000000000000000000000000000000000002));
function f1(function () external   i0)     returns(address payable o0)
{
}
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35
}
// ====
// ----
