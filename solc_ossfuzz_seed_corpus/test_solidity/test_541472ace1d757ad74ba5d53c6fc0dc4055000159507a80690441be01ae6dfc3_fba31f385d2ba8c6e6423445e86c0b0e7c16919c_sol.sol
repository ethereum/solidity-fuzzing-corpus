
==== Source: su0.sol ====
library L0 {
  type T0 is bool;
  modifier m0() 
  {
    {
      assert((true ? ((bytes21(0x000000000000000000000000000000000000000000) >= bytes21(0x000000000000000000000000000000000000000000)) ? false : false) : false));
      unchecked {
        if ((true ? (!(true)) : ((true != true) || false)))
        {
        }
        else
        {
          if (false)
          {
            function () external   returns (address payable[1] memory, bytes memory) l0;
          }
          else if (false)
          {
          }
        }
        while ((((~((~(((uint80(1208925819614629174706175) | uint80(0)) | uint80(1208925819614629174706175)))))) | uint80(1208925819614629174706175)) < uint80(1208925819614629174706175)))
        {
          {
            continue;
            {
              break;
              int136 l1 = int136(3968565964927945283418691978033568558153);
              break;
              break;
            }
          }
          if ((!(true)))
          {
          }
          else if (true)
          {
            break;
          }
        }
      }
      if (true)
      {
        function (bytes4, bytes9) external   l2;
        try l2(bytes4(0x00000000),bytes9(0x9142887a36abec09e3))
        {
          if ((!((bytes1(0xff) > bytes1(0xed)))))
          {
            _;
          }
        }
        catch
        {
        }
        catch Panic(uint256 l3)
        {
          if (true)
          {
          }
          else
          {
          }
          if ((!(true)))
          {
          }
          else
          {
          }
          function () external   l4;
        }
      }
      while (true)
      {
        _;
        continue;
        _;
      }
      address payable l5 = payable(address(0x0000000000000000000000000000000000000003));
    }
    true;
  }
  bytes29 public constant cons0 = (bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) ^ bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
  using L0 for *;
  error er0();
  bytes25 public constant cons1 = bytes25(0xc63031a776efb5515ab5f9a4832f5aa00074d87e2a6547e0ec);
  function f0() public  m0() 
  {
    assembly
    {
    }
  }
  error er1();
}
struct St0 {
  uint256 el0;
}
int168 constant cons2 = ((((((int168(-60894731113296274006547996013534027145882846977361) ** uint120(uint120(659880663002273306096427526922342423))) ** uint48(uint48(224414755911238))) & int168(110131628749731676941644145863800487998983465664736)) | int168(187072209578355573530071658587684226515959365500927)) | int168(0)) ^ int168(-152623266946605758223418569174860835271486807210518));
pragma solidity >= 0.0.0;
using L0 for uint;
function f1()     returns(uint104 o0)
{
}
type T1 is int168;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60
}
// ====
// ----
