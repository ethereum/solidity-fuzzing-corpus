
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is address;
  error er0(address payable ep0, address payable ep1);
  type T1 is bytes18;
  event ev0();
  bool immutable  s0 = false;
  mapping(uint24 => C0.T1)  public s1;
  int32   s2 = int32(2147483647);
  constructor() payable  {
    s1[uint24(int24(0))] = s1[uint24(0)];
    {
    }
  }
  event ev1(uint64[2]  ep0);
}
function f0(address payable i0)      returns(string[] memory o0){
  if (i0 != payable(address(0x0000000000000000000000000000000000000006)))
  {
    if (i0 >= payable(address(0x0000000000000000000000000000000000000008)))
    {
    }
    else if (i0 < ((true ? true : (uint112(0) >= uint112(0))) ? payable(address(0x0000000000000000000000000000000000000002)) : payable(address(0x0000000000000000000000000000000000000005))))
    {
      o0 = new string[](2);
      o0 = new string[](2);
      if (i0 == payable(address(0x0000000000000000000000000000000000000004)))
      {
      }
      else
      {
        do
        {
          continue;
        }
        while (false);
      }
    }
  }
  else
  {
  }
}

==== Source: su1.sol ====
contract C1 {
  bool   s3 = true;
  int160   s4 = int160(360929075452913055391453019878637904390456036288);
  function f1() internal virtual    returns(int144 o0)  {
    return (((int144(-1532685920589083394902215991483662807194419) - int144(0)) & int144(((int144(0) % int144(651632239919710784125711249689779867910876)) / int144(11150372599265311570767859136324180752990207)))));
  }
  receive() external virtual  payable
  {
    if (true)
    {
    }
    if (true)
    {
      do
      {
        break;
      }
      while (true);
      do
      {
        continue;
      }
      while (s3);
    }
    return;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
