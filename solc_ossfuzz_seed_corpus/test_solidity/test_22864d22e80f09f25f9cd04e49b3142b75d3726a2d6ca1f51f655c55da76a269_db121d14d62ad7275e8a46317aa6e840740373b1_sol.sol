
==== Source: su0.sol ====
struct St0 {
  string[1][] el0;
}
library L0 {
  function f0(bool i0,uint136 i1) public    returns(bytes24 o0)
  {
    assembly
    {
      for 
      {
        i0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
        for 
        {
          o0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
        }
        o0
        {
          for 
          {
            {
            }
            for 
            {
              selfdestruct(0)
            }
            i0
            {
            }
            {
              for 
              {
              }
              115792089237316195423570985008687907853269984665640564039457584007913129639935
              {
              }
              {
              }
              pop(and(i1, 115792089237316195423570985008687907853269984665640564039457584007913129639935))
              {
                pop(i0)
              }
            }
          }
          42199049225722911594746412948909214472646323218512048675037101738403844820609
          {
          }
          {
          }
          i0 := o0
        }
        {
        }
      }
      i0
      {
        stop()
        for 
        {
        }
        14841669984728535574757981865023959539903740717519348878651254774116945665332
        {
          switch 0
          case 115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
            return(i0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
            let al0 := i0
          }
          return(i1, i1)
        }
        {
        }
      }
      {
        break
        return(115792089237316195423570985008687907853269984665640564039457584007913129639935, i0)
        {
          switch not(calldataload(mod(85457077065961318576448849600543564758762862553296527009064293780410542110650, calldatasize())))
          default
          {
            continue
            if 47000534278553684184845734827145784269866090939618758810329895938985404665293
            {
              return(calldataload(mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, calldatasize())), i0)
            }
          }
          break
          {
            stop()
            if i1
            {
            }
          }
        }
      }
    }
    (o0) = (bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff));
  }
  uint48 public constant cons0 = ((((((uint48(281474976710655) % uint48(0)) << uint72(uint72(0))) - uint48(0)) ^ uint48(197411886742043)) << uint64(uint64(13110709288288430714))) % uint48(281474976710655));
  modifier m0() 
  {
    payable(address(0x0000000000000000000000000000000000000001));
    _;
  }
  using L0 for *;
  type T0 is bytes1;
}
type T1 is address payable;
pragma solidity >= 0.0.0;
function f1()     returns(bool o0,int104 o1)
{
  if ((!((bytes2(0xffff) >= (bytes2(0x0000) & bytes2(0xffff))))))
  {
    delete o0;
  }
  else
  {
  }
}
error er0();

==== Source: su1.sol ====
function f2()    
{
}
pragma solidity >= 0.0.0;
error er1(bytes4 ep0);
type T2 is bool;
struct St1 {
  address payable el0;
}
// ====
// ----
