
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  modifier m0(address i0) virtual
  {
    _;
  }
  modifier m1() virtual
  {
    if (false)
    {
      if (false)
      {
        _;
      }
      else if (false)
      {
      }
      _;
    }
    else
    {
    }
    assembly
    {
      for 
      {
      }
      0
      {
      }
      {
      }
    }
  }
  modifier m2() 
  {
    _;
  }
  error er0();
  fallback() external   payable
  {
    (bool l0) = payable(this).send(5918324674694353287);
  }
  struct St0 {
    bool[] el0;
    mapping(bool => bytes8) el1;
    int120 el2;
    int152 el3;
  }
  receive() external virtual  payable
  {
  }
  event ev0(int24 indexed ep0, bytes9  ep1) anonymous;
  event ev1(int168  ep0);
  bytes2   s0 = bytes2(0x0d0b);
}
error er1(address ep0);
function f2()     returns(address payable[] memory o0)
{
  do
  {
    (o0, o0[0], o0[0], o0) = (new address payable[](2), (o0[1] = o0[((((((uint256(0) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(0)) % uint256(20803950427250199298495445522688211184732779553183372327652021272717697494305)) ^ uint256(21832505416086818599389606994405066108998426418751975111170115722503047577620)) & uint256(100036354395415219918644052127462601410403042338714124285376659173580203482276)) | uint256(0))]), o0[1], new address payable[](2));
    if (true)
    {
    }
    else if ((false || true))
    {
    }
    else if ((!((false || (false && (int72(2025817475090162432806) < int72(0)))))))
    {
      delete o0[1];
    }
    revert er1(address(0x0000000000000000000000000000000000000003));
  }
  while ((!(true)));
  if (((false && false) ? true : (uint224(26959946667150639794667015087019630673637144422540572481103610249215) < uint224(8424942389052624237987852028127012821107471739510290243221402161160))))
  {
  }
  else if (false)
  {
  }
  else if (false)
  {
  }
}
address payable constant cons0 = payable(0x0000000000000000000000000000000000000000);
// ====
// ----
