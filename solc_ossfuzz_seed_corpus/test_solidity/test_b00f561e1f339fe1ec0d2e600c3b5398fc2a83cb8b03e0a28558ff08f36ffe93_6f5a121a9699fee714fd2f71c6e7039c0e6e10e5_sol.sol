
==== Source: su0.sol ====
function f0(bytes30 i0)     {
  return;
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
    while (false)
    {
      return;
    }
    (bool l0) = payable(this).send(0);
  }
  int48 immutable  s0;
  address payable[6]   s1;

	function compareMemoryAndStorage(address payable[6] memory v1, address payable[6] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  mapping(uint208 => mapping(bytes5 => bool[5]))   s2;
  int240[6]  public s3 = [int240(0), int240(883423532389192164791648750371459257913741948437809479060803100646309887), int240(883423532389192164791648750371459257913741948437809479060803100646309887), int240(0), int240(883423532389192164791648750371459257913741948437809479060803100646309887), int240(-723032680872710261305161943746577804812498899249842786686920395795423617)];

	function compareMemoryAndStorage(int240[6] memory v1, int240[6] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(int48 i0,address payable[6] memory i1)   {
    s0 = (int48(0) + (int48(0) - ((false ? false : true) ? int48(0) : int48(0))));
    s1 = i1;
    unchecked {
      for(;
false;
)
      {
        for(uint solinit0 = 0; solinit0 < ((uint256(0) ^ uint256(0)) % 11); solinit0++)
        {
          break;
        }
        continue;
      }
    }
  }
  function f2() public virtual  payable  returns(bool o0,function () external   returns (uint88, function (uint232, uint104, int56) external   returns (uint16, address[8] memory)) o1)  {
    (s1) = ([payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000003)), payable(address(0x0000000000000000000000000000000000000003)), payable(address(0x0000000000000000000000000000000000000005)), payable(address(0x0000000000000000000000000000000000000004))]);
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



error er0();
// ====
// ----
