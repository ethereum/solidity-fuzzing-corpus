
==== Source: su0.sol ====
contract C0 {
  function f0() private   
  {
    (bool l0, bytes memory l1) = address(this).call("40a259be38692bf1ad45524d21e16d7ced1447738eeffac6bdbae30f");
    for(    false;
;
bytes26(0x06f0f2188d82c715ebeb6771c675d64530b1ed648ffe7704dd46))
    {
      do
      {
        break;
        assembly
        {
        }
      }
      while (false);
      for(      bytes9 l2 = bytes9(0xd2af66ebed20f24e4e);
;
(uint128(138106881474205741390987324904885113049) <= ((((uint128(340282366920938463463374607431768211455) % uint128(340282366920938463463374607431768211455)) | uint128(0)) * uint128(0)) % uint128(256853793312532403328661369786917083655))))
      {
        assembly
        {
        }
      }
      while (true)
      {
        continue;
        if ((uint96(49255484507178512128114476082) == (uint96(0) * uint96(68411695402219244981323619270))))
        {
          if (true)
          {
            for(            int48 l3 = int48(140737488355327);
;
bytes8(0xffffffffffffffff))
            {
            }
          }
          unchecked {
            f0();
            break;
          }
        }
        else if (false)
        {
          uint72 l4 = (uint72(4722366482869645213695) + uint72(0));
        }
      }
    }
  }
  fallback() external   
  {
  }
  modifier m0(address payable i0) 
  {
    _;
  }
  struct St0 {
    bytes24 el0;
    bool el1;
  }
  error er0();
  address[1]   s0;
  C0.St0   s1 = C0.St0(bytes24(0x000000000000000000000000000000000000000000000000), false);
  address payable  public s2;
  constructor(address[1] memory i0,address payable i1) payable  {
    s0 = i0;
    s2 = payable(address(this));
    {
      if (false)
      {
        delete s0[0];
      }
      else if (true)
      {
        (bool l0, bytes memory l1) = address(this).call("000000000000000000000000000000000000000000000000008d3f11ba87090cb28824b6b17f802420e7dbed5e");
      }
      else if (true)
      {
        if (s1.el1)
        {
        }
        else if (false)
        {
          delete s2;
          s0[0] = address(this);
        }
      }
    }
  }
  function f2(bool i0,C0.St0 memory i1) public virtual m0(payable(address(ripemd160("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")))) payable returns(string memory o0,C0.St0 memory o1)
  {
  }
  type T0 is bool;
  event ev0(string  ep0, function (address[] memory) external   returns (bytes3, bytes12, address payable)  ep1);
  modifier m1() 
  {
    _;
  }
}
error er1(address payable ep0, bytes2 ep1);
pragma solidity >= 0.0.0;
function f3(bytes24 i0,int144 i1)    
{
}
type T1 is bytes28;
// ====
// ----
