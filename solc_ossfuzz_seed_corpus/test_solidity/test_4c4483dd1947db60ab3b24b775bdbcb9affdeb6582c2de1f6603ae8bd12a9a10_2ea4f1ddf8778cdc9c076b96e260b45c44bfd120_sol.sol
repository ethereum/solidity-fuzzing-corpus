
==== Source: su0.sol ====
struct St0 {
  address payable[] el0;
  uint192 el1;
  uint56 el2;
  bool el3;
}
pragma solidity >= 0.0.0;
library L0 {
  uint176 public constant cons0 = uint176((uint176((((((uint176(61885400695438970867452897839223747156236204392362868) >> uint88(uint88(292446435471716982445154322))) | uint176(95780971304118053647396689196894323976171195136475135)) & uint176(95780971304118053647396689196894323976171195136475135)) << uint64(uint64(18446744073709551615))) / uint176(95780971304118053647396689196894323976171195136475135))) / uint176(49599172490155989229413723076418343330329295814273500)));
  event ev0();
  modifier m0(bool i0) 
  {
    _;
    _;
    assembly
    {
    }
    _;
  }
  function f0(uint176 i0,uint240 i1,string[2] memory i2) public  m0((int80(((int80(0) ** uint240(uint240(0))) / (int80(0) + int80(604462909807314587353087)))) <= int80(0))) 
  {
    emit L0.ev0();
  }
  error er0(St0 ep0);
  modifier m1(uint120 i0,uint40[1] memory i1) 
  {
    _;
    _;
    _;
    unchecked {
    }
    string memory l0 = "000000000000000000000000000000000000000000";
  }
  type T0 is bool;
  error er1(int168 ep0);
  function f1() external  m1(uint120(637912551878325716279041878812088618),[uint40(797202982476)]) m0((bytes24(0x000000000000000000000000000000000000000000000000) != bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff)))  returns(L0.T0 o0,bool o1)
  {
    (o0) = (L0.T0.wrap(false));
  }
}
type T1 is uint56;
error er2(uint64 ep0);

==== Source: su1.sol ====
import "su0.sol";
function f2(bool i0,int144 i1)     returns(function (bool, int88) external   o0)
{
  while (((false == (!(false))) && (bytes29(0xd889131deeb9b53f2fa8794996b7ead6355e144d7a1c31ef2ceb1f8333) <= bytes29(0x0000000000000000000000000000000000000000000000000000000000))))
  {
    while (false)
    {
    }
  }
  return (o0);
  delete o0;
  bytes memory l0 = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff5f";
}
using L0 for uint;
pragma solidity >= 0.0.0;
// ====
// ----
