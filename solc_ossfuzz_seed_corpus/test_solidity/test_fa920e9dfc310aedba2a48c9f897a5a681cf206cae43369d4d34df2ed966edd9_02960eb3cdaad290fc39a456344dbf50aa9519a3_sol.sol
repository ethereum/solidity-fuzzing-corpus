
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() internal virtual     {
    if (true)
    {
    }
  }
  fallback() external virtual  
  {
    for(    [payable(address(0x0000000000000000000000000000000000000004)), payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000005)), payable(address(0x0000000000000000000000000000000000000007)), payable(address(0x0000000000000000000000000000000000000008)), payable(address(0x0000000000000000000000000000000000000002)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000001))];
;
true)
    {
      if (true)
      {
      }
      if (false f2 /*suffix expr*/)
      {
        break;
      }
      else
      {
        if (false)
        {
          if ((int88(0) > int88(154742504910672534362390527)))
          {
            (bool l0, bytes memory l1) = address(this).call(bytes(16279850633723944728541645088368 f3 /*suffix expr*/));
          }
        }
        while (true)
        {
          if ((address(this) > address(this)))
          {
            continue;
          }
          else if ((address(this) <= address(this)))
          {
            continue;
          }
        }
      }
    }
  }
  struct St0 {
    mapping(int40 => uint208) el0;
    int240 el1;
    bytes11 el2;
  }
  struct St1 {
    C0.St0 el0;
    int32 el1;
  }
  uint8  public s0;
  bytes17 immutable  s1 = bytes17(0x0000000000000000000000000000000000);
  C0.St1   s2;
  constructor(uint8 i0)   {
    s0 >>= (((uint8(0) % (uint8(0) % uint8(255))) & uint8(0)) | uint8(0));
    unchecked {
    }
  }
  function f4(uint8 i0,uint8 i1) public virtual  payable   {
  }
}
function f2(bool i0) pure suffix  returns(bool o0)
{
  require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
}
function f3(uint104 i0) pure suffix  returns(string memory o0)
{
  int128 l0 = int128(((uint128(0) - uint128(((uint128(102151558596393498419609902956543019071) | uint128(34676031689401418397216182128884520601)) / uint128(340282366920938463463374607431768211455)))) & uint128(42356956193893230954183913719178332184)));
  for(uint solinit0 = 0; solinit0 < (uint256((address(0x0000000000000000000000000000000000000004).balance / addmod((uint56(72057594037927935) & uint56(46611021696256524)), uint256(56814921577915929846101750381594137973053767186460096022620559398332024158114), uint256(0)))) % 11); solinit0++)
  {
    break;
  }
}

==== Source: su1.sol ====
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function f5(int128 i0)    pure suffix returns(bool o0){
  if (i0 >= int128(((int128((int128((uint128(270425346532307896114728657538044540060) >> uint88(uint88(309485009821345068724781055)))) - int128(144617741613647553495439722082492423646))) * int128(170141183460469231731687303715884105727)) / int128(170141183460469231731687303715884105727))))
  {
    while (false)
    {
      while (hex"320d018468a2937cce6e016d9a2f975f4ebc2b511165078c7f41d51b285828" f6 /*suffix expr*/)
      {
        for(        function (address payable) internal   returns (T0, address payable) l0;
true;
[int88(15849382014813813760074788), int88(145616558382223775957975233), int88(154742504910672534362390527), int88(154742504910672534362390527), int88(-4094857856269706301331209), int88(154742504910672534362390527), int88(-130441631741561223974438170), int88(0)])
        {
          continue;
        }
      }
      return (true);
    }
  }
}
pragma solidity >= 0.0.0;
import "su0.sol";
function f6(bytes31 i0) pure suffix  returns(bool o0)
{
  o0 = true;
  assert(o0 == true);
}
// ====
// ----
