==== Source:  ====

==== Source: su0.sol ====
int168 constant cons0 = 0;
pragma solidity >= 0.0.0;
contract C0 {
  function f0(bytes20 i0) public virtual     {
    (i0) = (bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    assert(i0 == bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    if (i0 <= bytes15(0xdcdda94b45902c6e24a4a5524623d9))
    {
      return;
    }
    else
    {
      if (i0 == bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))
      {
        (i0, i0) = (bytes20(address(0xe398B3d58a99B10e571089372d02418606015F17)), bytes20(address(0x7fff8f5FD468c6cebE9757F17cA6dfB94879a39A)));
        assert(i0 == bytes20(address(0xe398B3d58a99B10e571089372d02418606015F17)));
        assert(i0 == bytes20(address(0x7fff8f5FD468c6cebE9757F17cA6dfB94879a39A)));
      }
    }
    while ((address(this) == (true ? (false ? address(this) : address(this)) : address(this))))
    {
      continue;
    }
  }
  uint8  public s0;
  bytes  public s1 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  mapping(bool => address)  public s2;
  constructor(uint8 i0) payable  {
    s0 += uint8(int8(0));
    s2[true] = address(this);
    unchecked {
    }
  }
  error er0(bytes28 ep0);
  function f1() external virtual    returns(bytes memory o0,int184 o1)  {
    if ((true ? true : (false ? true : false)))
    {
      return (bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6a25ae7a0036312683fb08b47d56d00e47b467d3"), (int184(0) % (((int184(-1587691660634168074763203248633014084804543082966520309) ** uint32(uint32(716399876))) % int184(-3870961064533086301564035457110338184283237992609159907)) * int184(12259964326927110866866776217202473468949912977468817407))));
    }
    else if ((payable(address(this)) != payable(address(this))))
    {
      (s0) = ((((false ? ((uint8(255) - uint8(0)) + uint8(255)) : uint8(255)) - uint8(0)) * uint8(255)));
      assert(s0 == (((false ? ((uint8(255) - uint8(0)) + uint8(255)) : uint8(255)) - uint8(0)) * uint8(255)));
      this.f0(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    }
    revert er0(bytes28(0x00000000000000000000000000000000000000000000000000000000));
  }
  function f2(bool i0) external virtual  payable   {
  }
}

==== Source: su1.sol ====
bytes32 constant cons1 = bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
pragma solidity >= 0.0.0;
struct St0 {
  function (uint208, int184, bool) external   returns (uint216) el0;
  int72 el1;
}
// ----
// Warning 5667: (su0.sol:1252-1260): Unused function parameter. Remove or comment out the variable name to silence this warning.
