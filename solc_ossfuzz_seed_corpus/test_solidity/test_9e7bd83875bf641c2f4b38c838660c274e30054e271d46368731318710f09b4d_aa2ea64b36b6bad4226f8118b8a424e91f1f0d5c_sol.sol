
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(bool ep0);
type T0 is address;
contract C0 {
  function f0(bool i0) private    returns(int192 o0)
  {
  }
  modifier m0() 
  {
    assembly
    {
    }
    for(    address payable l0 = payable(address(this));
(((bytes15(0x000000000000000000000000000000) == bytes15(0xffffffffffffffffffffffffffffff)) && (bytes10(0xffffffffffffffffffff) != bytes10(0x6e4f10a534297f5f2220))) && false);
)
    {
      while (true)
      {
        _;
      }
    }
    for(    new uint256[](1);
true;
bytes31(0x00000000000000000000000000000000000000000000000000000000000000))
    {
    }
  }
  receive() external  m0() payable
  {
    for(    bool[] storage l0;
true;
)
    {
      address payable l1 = payable(address(this));
      if (true)
      {
      }
      else
      {
        if (false)
        {
        }
        else if ((((((int184(0) * int184(-8191630111408758144979305486195458770926753421943907515)) ** uint56(uint56(0))) & int184(5981926125040166544423957731014485250975464846084116719)) >= int184(0)) && true))
        {
          if (true)
          {
            bytes22 l2 = bytes22(0x00000000000000000000000000000000000000000000);
          }
          else if (true)
          {
            break;
          }
          else if (false)
          {
          }
        }
        else if (false)
        {
          assembly
          {
            for 
            {
            }
            115792089237316195423570985008687907853269984665640564039457584007913129639935
            {
              for 
              {
                switch l1
                case 0
                {
                  let al0 := l1
                }
                case 115792089237316195423570985008687907853269984665640564039457584007913129639935
                {
                }
                default
                {
                  mstore(mod(l1, 2048), mload(mod(0, 2048)))
                }
              }
              l1
              {
              }
              {
                return(115792089237316195423570985008687907853269984665640564039457584007913129639935, l1)
              }
              l0 := l1
            }
            {
            }
          }
          bytes17(0xffffffffffffffffffffffffffffffffff);
        }
      }
      revert er0(false);
      unchecked {
        if (true)
        {
          break;
          (bool l3) = payable(this).send(14513774677343416886);
        }
        else
        {
          (bool l4) = payable(this).send(3748972006071143707);
        }
        break;
        (l1) = (payable(address(this)));
      }
    }
  }
  bool  public s0;
  uint96  public s1 = uint96(79228162514264337593543950335);
  constructor(bool i0)   {
    s0 = false;
    { }
  }
}
struct St0 {
  bool el0;
  function (address payable) external   el1;
}
// ====
// ----
