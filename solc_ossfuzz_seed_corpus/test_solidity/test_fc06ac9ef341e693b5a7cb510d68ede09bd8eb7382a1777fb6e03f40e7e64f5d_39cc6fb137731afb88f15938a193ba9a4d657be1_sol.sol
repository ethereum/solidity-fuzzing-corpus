
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    function (int232, bytes memory, bytes5) external   returns (bool)[2] el0;
    uint200 el1;
    uint88 el2;
  }
  int184 public constant cons0 = int184(0);
  event ev0(uint64  ep0, function () external   returns (int256[][1] memory)  ep1, address  ep2);
  fallback() external   
  {
  }
  int24   s0;
  constructor(int24 i0) payable  {
    s0 += (((int24(1650698) + int24((int24(0) / int24(8388607)))) + int24(0)) % int24(8388607));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
  }
  error er0(int96 ep0);
  function f1(bool i0) external   payable returns(bytes memory o0,C0.St0 memory o1,function () external   returns (bool) o2)
  {
    {
      return (abi.encodeCall(this.f1, ((true || ((int168(0) < int168(0)) ? true : true)))), o1, o2);
    }
    for(;
(true != false);
)
    {
      continue;
      return ("00000000000000000000000000000000000000000000000000000000009120d7cff9f29a860c7bf52f6c5245a0", o1, o2);
    }
    (o1.el2, o1.el0) = (((uint88(((((uint88(309485009821345068724781055) ** uint104(uint104(12156085242079439462212205739037))) << uint240(uint240(742536501298143572759102455454464707525272437400043397007456989312958771))) & uint88(0)) / uint88(0))) + uint88(150304819934601753116187216)) | uint88(309485009821345068724781055)), o1.el0);
  }
}
pragma solidity >= 0.0.0;
library L0 {
  function f2() public    returns(function (bool) external   returns (uint96, bytes19, address) o0)
  {
  }
  modifier m0(uint232 i0,uint184 i1) 
  {
    _;
  }
  event ev1(function (address, bytes22) external   returns (int192, bool, bytes15)  ep0, bytes5 indexed ep1);
  event ev2(bool  ep0, bool  ep1);
  type T0 is bytes28;
  function f3(uint40 i0) internal  m0(uint232(((((((uint232(3896566066230060702593102283030213943617525564583008284536245123254790) << uint16(uint16(51906))) * uint232(6901746346790563787434755862277025452451108972170386555162524223799295)) - uint232(0)) & uint232(0)) * uint232(0)) / uint232(6617837433356854740510522555321824666372978183855261197325424980665281))),(uint184(17715636166050020658229132060584438219122852650361157732) | ((uint184(0) % (uint184(0) & uint184(15030947193444304684490361939121616401437976943159770985))) % uint184(8822491294324418766131414175625072240582260389247340546)))) 
  {
  }
  function f4() public    returns(bytes19 o0,uint96 o1)
  {
    emit L0.ev2(false, true);
  }
  error er1(address payable ep0);
  using L0 for *;
  error er2();
  modifier m1(bytes8 i0,C0.St0 memory i1) 
  {
    _;
  }
}
error er3(function (function (int152) external   returns (uint104, bytes19)) external   returns (bytes7) ep0);
contract C1 {
  struct St1 {
    int120 el0;
    function () external   el1;
  }
  event ev3(function () external   returns (function (bytes27, address payable) external   returns (bool, function () external   returns (string memory, function (C0) external   returns (bytes memory), bytes23), bytes8), C0, int136)  ep0) anonymous;
  function f5() private   
  {
    address payable[1][2] memory l0 = [[payable(address(0x0000000000000000000000000000000000000004))], [payable(address(0x0000000000000000000000000000000000000002))]];
    (bool l1, bytes memory l2) = address(this).call("0000000000000000000000000000000000000000000000000000");
  }
  C0   s1 = C0(address(this));
  uint152   s2 = uint152(0);
  L0.T0 public constant cons1 = L0.T0.wrap(bytes28(0x60b9db1687e3341addddbb20febb8d12e2fab76c708d7c12d29cb182));
  error er4();
  function f6() internal virtual  
  {
    assembly
    {
      stop()
      stop()
    }
  }
}
// ====
// ----
