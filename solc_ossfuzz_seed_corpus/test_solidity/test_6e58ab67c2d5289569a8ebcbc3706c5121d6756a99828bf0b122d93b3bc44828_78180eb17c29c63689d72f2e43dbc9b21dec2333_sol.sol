
==== Source: su0.sol ====
error er0();
contract C0 {
  fallback() external   
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 11607492575350501674}("");
    if ((payable(address(this)) == payable(address(bytes20(address(0x0000000000000000000000000000000000000000))))))
    {
      do
      {
        payable(this).transfer(9270136108946419676);
      }
      while (((true ? false : false) ? (true ? true : true) : false));
      (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
    }
    else
    {
      return;
    }
    for(;
(bytes12(0xffffffffffffffffffffffff) > bytes12(0x5ed9444be4a270ad9985bee1));
)
    {
      if (false)
      {
        break;
      }
      else if (false)
      {
        if (true)
        {
          break;
        }
      }
      break;
    }
  }
  bytes9   s0 = bytes9(0xffffffffffffffffff);
  uint144   s1 = uint144(22300745198530623141535718272648361505980415);
  int184[2]   s2 = [int184(12259964326927110866866776217202473468949912977468817407), int184(12259964326927110866866776217202473468949912977468817407)];

	function compareMemoryAndStorage(int184[2] memory v1, int184[2] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  struct St0 {
    address el0;
    uint72 el1;
    int136 el2;
  }
  event ev0(int8  ep0);
  receive() external   payable
  {
  }
  event ev1();
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St1 {
  address payable el0;
  bool el1;
  bool el2;
}
struct St2 {
  mapping(bool => uint88) el0;
  address el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
