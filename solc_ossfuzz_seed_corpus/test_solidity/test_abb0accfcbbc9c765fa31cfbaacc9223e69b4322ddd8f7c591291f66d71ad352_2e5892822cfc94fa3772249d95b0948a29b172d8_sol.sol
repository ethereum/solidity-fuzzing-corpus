
==== Source: su0.sol ====
address constant cons0 = 0x0000000000000000000000000000000000000000;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
function f0()      returns(int120 o0){
}
pragma solidity >= 0.0.0;
function f1(address payable[9] memory i0,int168 i1)     {
  return;
}
contract C0 {
  receive() external virtual  payable
  {
  }
  function f3(address i0) public     returns(bool[] memory o0)  {
    o0 = new bool[](2);
    if (i0 <= this.f3.address)
    {
      o0 = new bool[](2);
    }
    else if (i0 <= address(this))
    {
    }
  }
  uint248   s0 = uint248(452312848583266388373324160190187140051835877600158453279131187530910662655);
  bytes  public s1;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  mapping(bool => int72)   s2;
  int192   s3 = int192(0);
  constructor(bytes memory i0) payable  {
    s1 = bytes("ffffffffffffffffffffffffffffffffff06e785dbd8bfcd8ff52f1b7f95cf91a30e");
    s2[true] += int72(0);
    unchecked {
    }
  }
  function f4(uint248 i0) external virtual     {
    (int120 l0) = f0();
    return;
  }
  function f5(address payable i0) external      {
    do
    {
    }
    while (false);
    s1.push("\xc3");
  }
  struct St0 {
    function (uint112, bool) external   returns (bool, int176) el0;
    mapping(bytes29 => uint24) el1;
    bool[] el2;
  }
}
// ====
// ----
