
==== Source: su0.sol ====
address constant cons0 = 0x0000000000000000000000000000000000000000;
struct St0 {
  address el0;
  address el1;
  bool el2;
  bytes21 el3;
}
function f0(St0 memory i0)     {
  if (((-(int56(((int56(13447154607759096) & int56(36028797018963967)) / int56(0))))) < int56(0)))
  {
  }
  else if (true f1 /*suffix expr*/)
  {
    for(uint solinit0 = 0; solinit0 < (hex"732525df2ea20145ef0edd617926b33cd4283d5e2c99aefa4e12974242dd" f2 /*suffix expr*/ % 11); solinit0++)
    {
      break;
    }
  }
  i0.el1 = address(0x0000000000000000000000000000000000000007);
  assert(i0.el1 == address(0x0000000000000000000000000000000000000007));
}
pragma solidity >= 0.0.0;
function f1(bool i0) pure suffix  returns(bool o0)
{
  return (true);
}
function f2(bytes30 i0) pure suffix  returns(uint256 o0)
{
  address payable l0 = payable(address(0x0000000000000000000000000000000000000002));
  assert((false ? true : true));
  if (i0 > bytes30(bytes30(0x000000000000000000000000000000000000000000000000000000000000)))
  {
    o0 >>= uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935);
  }
  else if (i0 != bytes30(0x000000000000000000000000000000000000000000000000000000000000))
  {
    for(    bytes28 l1 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
;
int16(0))
    {
      o0 >>= false f3 /*suffix expr*/;
    }
    f0({i0: -7292449 f4 /*suffix expr*/});
  }
}
function f3(bool i0) pure suffix  returns(uint256 o0)
{
  (o0) = ((~(payable(address(0x0000000000000000000000000000000000000005)).balance)));
  assert(o0 == (~(payable(address(0x0000000000000000000000000000000000000005)).balance)));
}
function f4(int24 i0) pure suffix  returns(St0 memory o0)
{
  (o0.el2, o0.el0) = (false, msg.sender);
  assert(o0.el2 == false);
  assert(o0.el0 == msg.sender);
}

==== Source: su1.sol ====
error er0();
struct St1 {
  function (uint200, int136, function () external   returns (bool)) external   el0;
}
pragma solidity >= 0.0.0;
// ====
// ----
