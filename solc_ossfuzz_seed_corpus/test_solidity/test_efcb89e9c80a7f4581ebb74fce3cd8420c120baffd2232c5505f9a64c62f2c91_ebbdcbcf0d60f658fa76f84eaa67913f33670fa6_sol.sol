
==== Source: su0.sol ====
contract C0 {
  function f0(uint80 i0) public   payable  returns(bool o0)  {
    uint8 l0 = uint8((((uint8((uint40(1099511627775) ^ uint40(0))) - uint8(0)) - uint8(131)) / uint8(219)));
  }
  uint48   s0 = uint48(229551121917272);
  address payable   s1;
  address payable[]  public s2 = [payable(address(0x0000000000000000000000000000000000000005)), payable(address(0x0000000000000000000000000000000000000004)), payable(address(0x0000000000000000000000000000000000000001))];

	function compareMemoryAndStorage(address payable[] memory v1, address payable[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(address payable i0)   {
    s1 = payable(address(this));
    unchecked {
    }
  }
  function f1(address payable i0) private     returns(bytes memory o0,string memory o1,function () external   returns (int120, int128, uint88) o2)  {
    while ((true ? true : false))
    {
      continue;
    }
    s2.push();
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  bytes6   s3;
  address   s4;
  int104   s5 = int104(0);
  mapping(bool => address)[9]   s6;
  constructor(bytes6 i0,address i1) payable  {
    s3 ^= bytes6(bytes12(0x000000000000000000000000));
    s4 = address(this);
    unchecked {
    }
  }
  event ev0(string  ep0, uint72  ep1);
  error er0();
}
pragma solidity >= 0.0.0;
contract C2 {
  function f2() private      {
    (bool l0, bytes memory l1) = address(this).call(bytes.concat(bytes5(0x39659384a9)));
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  function f3(bytes30 i0) private     returns(C1 o0,uint24 o1,function () external   returns (uint136, function (string memory, bool) external  [] memory)[10] memory o2)  {
    return (C1(address(o0)), uint24((((uint24((uint24(1385832) / uint24(16777215))) ^ uint24(16607022)) ^ uint24(0)) / uint24(0))), o2);
  }
  fallback() external   
  {
    if (false)
    {
      (uint224(26959946667150639794667015087019630673637144422540572481103610249215) ^ ((((uint224(25607691804450689581836342549023742771856119875812244568607936397877) - uint224(26959946667150639794667015087019630673637144422540572481103610249215)) * uint224(23867515559971898799507615760085687531642666692308079354008994735657)) % uint224(26959946667150639794667015087019630673637144422540572481103610249215)) | uint224(20390526376739641322390583762946798686180636485737843839034187778504)));
    }
  }
  bytes31   s7;
  constructor(bytes31 i0)   {
    s7 &= (~((true ? (true ? bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) : bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) : bytes31(0x00000000000000000000000000000000000000000000000000000000000000))));
    unchecked {
      s7 &= bytes31(0x00000000000000000000000000000000000000000000000000000000000000);
    }
  }
  struct St0 {
    bytes25 el0;
    address payable el1;
    address payable el2;
  }
  modifier m0() 
  {
    revert C1.er0();
    _;
  }
  function f5(bytes31 i0) internal  m0() m0()   returns(int88 o0,bytes5 o1,C2.St0 memory o2)  {
    (o2.el0) = ((~(bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff))));
    assert(o2.el0 == (~(bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff))));
  }
}
// ====
// ----
