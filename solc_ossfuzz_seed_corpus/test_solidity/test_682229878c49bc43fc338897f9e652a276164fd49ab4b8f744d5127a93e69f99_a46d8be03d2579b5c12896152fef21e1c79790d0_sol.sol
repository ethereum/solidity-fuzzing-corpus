
==== Source: su0.sol ====
error er0(bool ep0, bytes ep1);
struct St0 {
  bytes14 el0;
}
pragma solidity >= 0.0.0;
error er1();
struct St1 {
  int56 el0;
  address el1;
  St0 el2;
  bytes24 el3;
}

==== Source: su1.sol ====
contract C0 {
  type T0 is address payable;
  uint176 immutable public s0 = uint176(0);
  C0.T0   s1 = C0.T0.wrap(payable(address(0x0000000000000000000000000000000000000008)));
  bytes16   s2;
  mapping(uint208 => bool)   s3;
  constructor(bytes16 i0)   {
    s2 = bytes16(0x2e34edc8dced8e5e1e1c9b4d6f028e96);
    s3[uint208(0)] = true;
    {
      for(      function (bytes memory, address payable[5][1] memory, int200) external   returns (C0.T0) l0;
;
)
      {
        if (i0 < bytes16(0xffffffffffffffffffffffffffffffff))
        {
          continue;
        }
        string storage l1;
      }
    }
  }
  function f0(bytes16 i0,C0.T0 i1) public      {
  }
}
pragma solidity >= 0.0.0;
struct St2 {
  address el0;
}
error er2(uint112 ep0, function (St2 memory, int96, uint24) external   returns (int184, bytes7, address) ep1);
// ====
// ----
