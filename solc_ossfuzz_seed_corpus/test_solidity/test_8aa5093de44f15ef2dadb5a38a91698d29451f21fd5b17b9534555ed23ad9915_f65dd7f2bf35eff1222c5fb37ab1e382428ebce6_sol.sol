
==== Source: su0.sol ====
function f0(bytes13 i0)      returns(bytes8 o0){
  while ((bytes6(0xffffffffffff) < bytes6(0x000000000000)))
  {
  }
  o0 ^= (bytes7(0xc845dd722095b2) ^ bytes7(0x00000000000000));
  o0 = (bytes8(0xffffffffffffffff) | (~((bytes8(0x7c4303b6e1ddff32) | bytes8(0x0000000000000000)))));
  assert(o0 == (bytes8(0xffffffffffffffff) | (~((bytes8(0x7c4303b6e1ddff32) | bytes8(0x0000000000000000))))));
}
contract C0 {
  type T0 is int72;
  function f1(uint88 i0,bool i1,function (bytes32, bytes memory) external   returns (bool, function () external  ) i2) public virtual     {
    (bool l0, bytes memory l1) = address(this).call(bytes("0000000000eb47a412cf29391c30"));
  }
  address payable   s0;
  bool   s1 = true;
  address payable  public s2 = payable(address(this));
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T1 is uint88;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,
add1 as +, sub1 as -, mul1 as *, div1 as /, mod1 as %,
eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }




function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) | T1.unwrap(y)); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) & T1.unwrap(y)); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) ^ T1.unwrap(y)); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(~T1.unwrap(x)); }




function add1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) + T1.unwrap(y)); }

function sub1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) - T1.unwrap(y)); }

function mul1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) * T1.unwrap(y)); }

function div1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) / T1.unwrap(y)); }

function mod1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) % T1.unwrap(y)); }



function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



contract C1 {
  fallback() external   
  {
  }
  error er0(T1 ep0, function (uint112, bytes21) external   returns (T1, bool) ep1);
  event ev0() anonymous;
  address payable   s3 = payable(address(this));
  T1   s4;
  mapping(bool => bool)   s5;
  constructor(T1 i0)   {
    s4 = (T1.wrap(uint88(309485009821345068724781055)) ^ T1((((i0 * T1.wrap(uint88(309485009821345068724781055))) * T1.wrap(uint88(0))) / T1.wrap(uint88(309485009821345068724781055)))));
    s5[((uint144(0) <= uint144(22300745198530623141535718272648361505980415)) ? false : true)] = s5[true];
    unchecked {
    }
  }
}
contract C2 {
  C1   s6 = C1(address(this));
  int24  public s7;
  uint88  public s8;
  constructor(int24 i0,uint88 i1)   {
    s7 *= ((int24(0) ** uint32((((uint32(0) ^ uint32(0)) ^ uint32(3130495223)) - uint32(0)))) % int24(3873545));
    s8 ^= uint88(309485009821345068724781055);
    unchecked {
    }
  }
  function f3() public virtual     {
    if (false)
    {
    }
    else if (true)
    {
    }
  }
  struct St0 {
    uint64 el0;
  }
}
// ====
// ----
