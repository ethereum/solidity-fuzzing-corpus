
==== Source: su0.sol ====
type T0 is bytes31;
struct St0 {
  int120 el0;
  function (uint120, uint32) external   returns (int16, int240, address payable) el1;
}
contract C0 {
  uint96[1]  public s0 = [uint96(20718988717591781977354946473)];
  St0   s1;
  bytes16   s2 = bytes16(0x79089589e144e8d13609f3efc4ac2ea3);
  int72 immutable public s3 = int72(-1495654809995677762764);
  receive() external   payable
  {
    revert(string("599897c6e78969840b30f0ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  function f1(uint112 i0) private   
  {
  }
  function f2(function () external   returns (T0, bytes26, bytes18) i0,address payable i1) public virtual   returns(bool o0)
  {
    if (true)
    {
      (bool l0) = payable(this).send(13388867611456223625);
      s1.el1 = s1.el1;
    }
    else if (false)
    {
      if (true)
      {
        revert("63e0a473d638ffffffffffffffffffffffffffffffffffffffffffffffffffff");
      }
      else if (true)
      {
      }
      return ((false || (false || (!(true)))));
    }
    else
    {
      (s0) = ([uint96(32549136879842954757003946370)]);
    }
    return (true);
    while (false)
    {
    }
    for(;
;
)
    {
      break;
    }
  }
  address payable public constant cons0 = payable(0xc2b6f52a09319D2Aa03F0A2AB181EfFfceba510a);
  function f3() external   payable returns(bytes memory o0)
  {
    do
    {
      while (true)
      {
      }
      continue;
      if (((int152(0) + (int152(2854495385411919762116571938898990272765493247) ** uint120((uint120(1329227995784915872903807060280344575) | uint120(0))))) == int152(0)))
      {
        break;
        continue;
      }
      else
      {
        T0 l0 = T0.wrap(bytes31(0x15451ceba05951692b15f2eee1acb29df884a47999cefd4193f9f960ca7845));
      }
      break;
    }
    while ((int64(0) < ((int64((int64(6950362387733604189) / int64(0))) + int64(0)) % int64(9223372036854775807))));
    (bool l1) = payable(this).send(1143151432220632092);
    return (bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb303419f7a0e79d06e771ba63cbaa1bf91bc76906c410f264c3933c579"));
  }
  event ev0();
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57
}
function f4(int200 i0,T0 i1)    
{
  if ((uint184(24519928653854221733733552434404946937899825954937634815) >= ((uint184(24519928653854221733733552434404946937899825954937634815) << uint32(uint32(4294967295))) * uint184(21969277676753812207501882248080394089402243099535240934))))
  {
    unchecked {
    }
  }
  while ((bytes12(0xffffffffffffffffffffffff) < bytes12(0xffffffffffffffffffffffff)))
  {
  }
  for(  int120[1] memory l0 = [int120(0)];
true;
)
  {
    continue;
    { }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
