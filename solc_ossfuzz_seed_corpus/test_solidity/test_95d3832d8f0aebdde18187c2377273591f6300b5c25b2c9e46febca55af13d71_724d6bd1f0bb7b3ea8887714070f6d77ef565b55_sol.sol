
==== Source: su0.sol ====
bool constant cons0 = false;
contract C0 {
  event ev0(bool  ep0, uint120 indexed ep1) anonymous;
  modifier m0(address payable[2] memory i0) virtual
  {
    _;
    for(    function () internal   returns (uint64) l0;
(!(true));
)
    {
      _;
      assembly
      {
        switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
        case 64840107834007887687087220108142279005068416936246164898985270175285740923558
        {
          let al0 := 95201737883500970256101442418370465578645593673083016694017342447273908535476
        }
        case 3282557051219617888392456090671557449923599032820994102840716861582275083159
        {
          return(cons0, cons0)
        }
        case 0
        {
        }
      }
    }
    emit ev0(false, uint120(0));
    if (((((((uint232(0) << uint144(uint144(458154079831383583570388749282391931297139))) & uint232(6555646504064939315106868275836779740716549946658243807680724480806436)) * uint232(0)) % uint232(6901746346790563787434755862277025452451108972170386555162524223799295)) - uint232(582984494290426148806802711184435799068032933668883877045585802809008)) == uint232(5758525276018472659007045608616905008254138214145954553557145144338048)))
    {
    }
    else if (false)
    {
      (i0) = ([payable(address(0x0000000000000000000000000000000000000007)), payable(address(0x0000000000000000000000000000000000000004))]);
    }
    else if (false)
    {
      (bool l1, bytes memory l2) = address(this).call(bytes("0000000000000000000000000000000000000000000000000000191ef4b64ac8e35c91932e1dbd5b"));
    }
    _;
  }
  event ev1(bool  ep0);
  struct St0 {
    int32 el0;
    int24 el1;
    bytes25 el2;
  }
  int192   s0;
  constructor(int192 i0)   {
    s0 |= int192(((int192(3138550867693340381917894711603833208051177722232017256447) ** uint64(uint64(4949002940147477691))) / ((int192(3138550867693340381917894711603833208051177722232017256447) ** uint56(uint56(0))) ** uint192(uint192(896252270930808915584670014132591116867536002796678268035)))));
    unchecked {
      bool l0 = true;
    }
  }
}
type T0 is address payable;
pragma solidity >= 0.0.0;
error er0();
// ====
// ----
