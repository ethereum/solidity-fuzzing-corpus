
==== Source: su0.sol ====
contract C0 {
  function f0(int120 i0,int152 i1,function (bytes25, int184) external   returns (bytes18, function (address, int136, function (address payable[] memory, bytes22) external   returns (bytes25, bytes memory)) external  , int184) i2) internal   
  {
    try i2(bytes25(0x00000000000000000000000000000000000000000000000000),((int184(-12208644561735705103017118148532166217483481006914822875) % ((int184(12259964326927110866866776217202473468949912977468817407) | int184(0)) * int184(8175452040909002740861963984623604046984778500495449247))) & int184(12259964326927110866866776217202473468949912977468817407))) returns (bytes18 l0, function (address, int136, function (address payable[] memory, bytes22) external   returns (bytes25, bytes memory)) external   l1, int184 l2)
    {
      while (((bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) <= ripemd160(bytes("ffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000000000000000000000"))) != true))
      {
      }
      if (true)
      {
      }
      else if ((true ? false : true))
      {
      }
      else if (false)
      {
      }
    }
    catch
    {
      for(      int128 l3 = (int128(0) ** uint16(((((uint16(0) - uint16(65535)) >> uint208(uint208(0))) ^ uint16(0)) + uint16(48200))));
(bytes7(0xffffffffffffff) == bytes7(0x00000000000000));
bytes9(0xffffffffffffffffff))
      {
      }
    }
  }
  function f1(address i0,int248 i1) private   
  {
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31

  }
  address   s0;
  mapping(int184 => mapping(int152 => address))  public s1;
  mapping(C0.EN0 => C0.EN0)   s2;
  uint200  public s3 = uint200(1606938044258990275541962092341162602522202993782792835301375);
  constructor(address i0) payable  {
    s0 = address(this);
    s2[C0.EN0.M8] = C0.EN0(uint8(11));
    unchecked {
    }
  }
  struct St0 {
    bytes el0;
    uint248 el1;
    bytes1 el2;
    uint56[2] el3;
  }
  fallback() external   
  {
    if (((false && (true || false)) && false))
    {
    }
    else
    {
    }
    if ((int32(1720178053) == int32(((~(((int32(-1683621099) & int32(2147483647)) ^ int32(2147483647)))) / int32(0)))))
    {
    }
    else
    {
      bytes22 l0 = bytes22(0x00000000000000000000000000000000000000000000);
    }
  }
  receive() external   payable
  {
    return;
    payable(this).transfer(2131702685328797505);
    if ((!((false && (((uint200(1606938044258990275541962092341162602522202993782792835301375) >> uint56(uint56(72057594037927935))) + uint200(113489739738454387489696458044040574300503290817257395984853)) > uint200(0))))))
    {
      if ((!(true)))
      {
      }
      else if (false)
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 1449550653091055719}("");
      }
      else
      {
        if ((true ? (false || false) : (false && false)))
        {
        }
      }
      return;
    }
    else if (true)
    {
    }
  }
  modifier m0(function (bytes32, uint200, C0.EN0) internal   returns (address payable, address payable)[] memory i0,C0.St0[] memory i1) 
  {
    if (true)
    {
      _;
      (bool l0) = payable(this).send(4260311274967391899);
      _;
    }
    else if (false)
    {
      if (true)
      {
      }
      else if (false)
      {
      }
      else
      {
        delete s0;
      }
    }
    else if (true)
    {
      _;
    }
  }
  modifier m1(C0.St0 memory i0) virtual
  {
    _;
  }
  type T0 is address payable;
  function f4(C0.EN0 i0,bool i1,bool i2) external virtual   returns(bool o0)
  {
    return (false);
  }
}
pragma solidity >= 0.0.0;
function f5(uint208 i0,C0.EN0 i1)     returns(function () external   returns (address, int192, address payable) o0,bytes8 o1)
{
  assembly
  {
  }
}
error er0();
// ====
// ----
