
==== Source: su0.sol ====
struct St0 {
  bytes18 el0;
}
pragma solidity >= 0.0.0;
function f0(bytes22 i0)     {
  return;
}
contract C0 {
  event ev0(bool indexed ep0, bytes[6] indexed ep1);
  struct St1 {
    string el0;
    function (uint56, St0 memory) external   returns (function (address payable) external   returns (address, bool, int96), bytes3, uint24) el1;
  }
  int32   s0 = int32(-1652679592);
  St0   s1 = St0(bytes18(0x9382b7e0f5946b284d1de6f6f4086ef301f9));

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  int24   s2 = int24(0);
  function f1(int32 i0) external virtual     {
    for(    C0.St1 memory l0;
(bytes13(0x00000000000000000000000000) <= bytes13(bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
int112(2596148429267413814265248164610047))
    {
      revert(string.concat(string(bytes("2a01b17fa56400000000000000000000000000000000000000000000000000000000")), string(bytes("ffffffffffffffffffffffffffffffffffffffffffffffff")), string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")), string("This is a really long string that must ideally be random but is currently hard coded")));
    }
  }
}
struct St2 {
  bytes20 el0;
  bool[5][4] el1;
  int168[] el2;
  uint24 el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St3 {
  address el0;
  int16 el1;
}
struct St4 {
  mapping(uint80 => int8) el0;
  uint168 el1;
  bool el2;
  bool el3;
}
struct St5 {
  bytes el0;
  bool el1;
  St3 el2;
}
// ====
// ----
