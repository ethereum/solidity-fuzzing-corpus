
==== Source: su0.sol ====
contract C0 {
  function f0() public      {
  }
  bool[]  public s0;

	function compareMemoryAndStorage(bool[] memory v1, bool[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool  public s1;
  constructor(bool[] memory i0,bool i1)   {
    s0 = i0;
    s1 = false;
    unchecked {
    }
  }
  function f1() public     returns(bytes32 o0)  {
    if (true)
    {
    }
    else if (((int80(-383062882980949905740944) * (int120(0) * int120(0))) < int120(0)))
    {
      (bool l0, bytes memory l1) = address(this).call(191286372573658869898141675490209667604723878151071552563897201447949906018 f2 /*suffix expr*/);
      if (false)
      {
        this.f0();
        return ((bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & keccak256(bytes("00000000000000000000000000000000000000000000000000000000"))));
      }
    }
    do
    {
      (uint256(0) | uint256(((int256(38931787956007265230607490228141561911967981167333293289222432992205529706350) * int256(0)) ** uint104(uint104(12609401741273151940210514814763)))));
      while ((true ? true : false))
      {
        continue;
      }
    }
    while (true);
  }
}
pragma solidity >= 0.0.0;
function f2(int248 i0) pure suffix  returns(bytes memory o0)
{
}

==== Source: su1.sol ====
struct St0 {
  mapping(bool => bool) el0;
  int56 el1;
}
pragma solidity >= 0.0.0;
contract C1 {
  bool  public s2 = true;
  function f3(bool i0,bool i1) public virtual  payable   {
    do
    {
      (bool l0, bytes memory l1) = address(this).call(0x0000000000000000000000000000000000000002 f4 /*suffix expr*/);
      if (i1)
      {
        (s2) = (false);
        assert(s2 == false);
        continue;
      }
      else if (i1)
      {
        break;
      }
      if (i0)
      {
        for(        bytes memory l2 = bytes("0000ffffffff");
false;
)
        {
          for(uint solinit0 = 0; solinit0 < (((uint256(((~(uint256(86482165576301802661977945002067205046281122594882713998575355012601457199513))) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
          {
            continue;
          }
        }
      }
      else if (i1)
      {
        continue;
      }
    }
    while (false);
  }
  type T0 is bool;
}
contract C2 {
  function f5() public     returns(bool o0,int144 o1)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000"));
    do
    {
    }
    while (((((false ? true : true) ? false : false) == true) ? true : true));
  }
  event ev0();
  event ev1(bytes indexed ep0, string  ep1);
  C1   s3 = C1(address(this));
  address payable   s4;
  bool   s5 = false;
  constructor(address payable i0) payable  {
    s4 = payable(address(this));
    unchecked {
    }
  }
  error er0();
}
struct St1 {
  C1[5] el0;
  bool el1;
}
function f4(address i0) pure suffix  returns(bytes memory o0)
{
  if (i0 < address(0x0000000000000000000000000000000000000004))
  {
    for(;
((~(uint8(int8(0)))) <= (uint8(0) ** uint136(uint136(87112285931760246646623899502532662132735))));
int176(((int176((int176(47890485652059026823698344598447161988085597568237567) / (int176(47890485652059026823698344598447161988085597568237567) | int176(47890485652059026823698344598447161988085597568237567)))) % int176(0)) / int176(0))))
    {
      if (i0 > address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))))
      {
      }
      break;
    }
  }
}
// ====
// ----
