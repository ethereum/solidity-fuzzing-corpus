
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
type T0 is uint168;
T0 constant cons0 = T0.wrap(uint168(0));
library L0 {
  modifier m0() 
  {
    {
      if (true)
      {
        _;
      }
      else if ((bytes4(0xffffffff) < msg.sig))
      {
      }
      else
      {
        if (true)
        {
        }
        if (true)
        {
          if ((true && true))
          {
          }
          else if ((bytes4(0x00000000) != bytes4(0x3d987769)))
          {
            _;
            _;
            assembly
            {
              switch 0
              case 115792089237316195423570985008687907853269984665640564039457584007913129639935
              {
                invalid()
              }
              case 40523260221236070036594962233902327757415908178805947293010032759991195275861
              {
                let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
              }
              case 43687782018414186351436977945424556251472424439358770632168787884492268411376
              {
                if 115792089237316195423570985008687907853269984665640564039457584007913129639935
                {
                }
                {
                  revert(cons0, cons0)
                  let al1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
                }
              }
              switch cons0
              case 10116378733323600467093256987978932255202616729054652355276543020455765588862
              {
                let al2 := cons0
                switch 51722587076766582995273913986852183109850344983950259027944706381216841384518
                case 0
                {
                  function af0(ai0, ai1, ai2, ai3) -> ao0
                  {
                    let al3 := ai3
                  }
                }
                function af1(ai4, ai5, ai6)
                {
                }
              }
            }
          }
          if (true)
          {
          }
          else if (((!(false)) || true))
          {
            _;
          }
        }
      }
    }
  }
  using L0 for *;
  event ev0(bytes1  ep0, T0[2]  ep1);
  error er0();
  modifier m1() 
  {
    if ((bytes31(0x412d87475f7251bb2e89740fddd6ed7b1758a0a53926282b20491e4eb2e8ab) > bytes31(0xc965c5cc7bd3889d6a14471c24fc3d9de7dc2ac57adac0d3547966e6662980)))
    {
      revert er0();
      _;
    }
    _;
    revert er0();
    for(    (((int24(0) | int24(-1900346)) % (int24(-424821) | int24(-3156898))) + int24(5407078));
true;
)
    {
    }
  }
  type T1 is bool;
  bytes6 public constant cons1 = bytes6(0x000000000000);
  error er1(T0 ep0);
  function f0() private  m1() 
  {
    if ((false && true))
    {
      f0();
    }
    else if (false)
    {
    }
    else if (false)
    {
      if (((~((uint56(33283121972567518) >> uint32(uint32(4294967295))))) >= (uint56(0) % uint56(0))))
      {
      }
      else if ((false && (true || true)))
      {
        { }
      }
      else if (((((((uint8(255) ^ uint8(71)) % uint8(0)) << uint80(uint80(1208925819614629174706175))) < uint8(255)) && true) && false))
      {
        { }
      }
    }
    assembly
    {
      return(cons0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      return(cons0, calldataload(mod(cons1, calldatasize())))
    }
  }
}
// ====
// ----
