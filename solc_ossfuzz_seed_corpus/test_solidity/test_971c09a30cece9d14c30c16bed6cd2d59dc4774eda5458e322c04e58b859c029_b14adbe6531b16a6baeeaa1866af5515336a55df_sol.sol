
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()     {
  for(uint solinit0 = 0; solinit0 < ((((((uint152(0) << uint256(uint256(0))) >> uint40(uint40(0))) * uint152(3175230021521956246934811842287583112113330930)) % uint152(0)) * uint152(4955446100015006287563722906622254178343265706)) % 11); solinit0++)
  {
    break;
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address payable el0;
}
struct St1 {
  int120 el0;
  function (bytes11, address, int176) external   returns (bytes5) el1;
}
contract C0 {
  struct St2 {
    bool el0;
    address el1;
    function () external   returns (function (address, uint200, address payable[] memory) external   returns (bytes memory, string memory)) el2;
  }
  receive() external virtual  payable
  {
    function (uint96) external   l0;
    int136 l1 = int136((uint136(72226075485913343510762177127144532452793) + (((uint136(0) - uint136(77792486721139605923506342643124560815182)) * uint136(87112285931760246646623899502532662132735)) >> uint160(uint160(21219227788434583702708983171342872444217135644)))));
  }
  address payable  public s0;
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
    }
  }
  function f2() public     returns(int176 o0,bytes[] memory o1,function () external   returns (address payable, address payable) o2)  {
  }
  int216 public constant cons0 = 52656145834278593348959013841835216159447547700274555627155488767;
}
// ====
// ----
