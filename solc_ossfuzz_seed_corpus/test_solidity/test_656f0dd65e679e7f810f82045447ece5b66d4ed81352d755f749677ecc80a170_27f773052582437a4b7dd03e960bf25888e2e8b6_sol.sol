
==== Source: su0.sol ====
contract C0 {
  function f0(int200 i0) external     returns(uint192 o0)  {
    if (i0 != int200(241740612853917591335465269177889236966533393972750115650818))
    {
      return (uint192(0));
    }
  }
  error er0();
  bool   s0 = false;
  mapping(int176 => uint160)  public s1;
  bool  public s2 = true;
  uint216   s3;
  constructor(uint216 i0) payable  {
    s3 |= (uint216(71797282674015375670604139412252683960318077924371450632907304752) | (uint40(0) ^ (uint216(0) & uint216(0))));
    s1[int176((int176((int176(47890485652059026823698344598447161988085597568237567) / ((int160(0) & int160(730750818665451459101842416358141509827966271487)) - int160(-462577474213914227725373970430038326244717468723)))) / int176(47890485652059026823698344598447161988085597568237567)))] |= ((uint160(1461501637330902918203684832716283019655932542975) & (uint160(1461501637330902918203684832716283019655932542975) ^ (uint160(1461501637330902918203684832716283019655932542975) * uint160(387229198926947556625101511475823241386452612396)))) | uint160(0));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
error er1(bytes3[] ep0);

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
}
struct St1 {
  uint184 el0;
  address el1;
  St0 el2;
  bytes25[] el3;
}
// ====
// ----
