
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() public      {
  }
  bool  public s0 = false;
  receive() external virtual  payable
  {
    (s0) = (true);
    assert(s0 == true);
    (bool l0, bytes memory l1) = payable(this).call{value: 15045364834385921723}("");
    if (false)
    {
      for(      function (uint208) internal   returns (int40[] memory, bytes31, uint144) l2;
false;
(uint160(1461501637330902918203684832716283019655932542975) | ((((uint160(1461501637330902918203684832716283019655932542975) * uint160(272160725386796835197690903172683184278184824367)) | uint160(1180937429624479218951624991738698777918403945660)) * uint160(1461501637330902918203684832716283019655932542975)) ^ uint160(0))))
      {
        break;
      }
    }
    else if (true)
    {
      (bool l3) = payable(this).send(0);
      s0 = false;
      assert(s0 == false);
    }
  }
  fallback() external   
  {
    if (true)
    {
      (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSignature("f0()"));
    }
    else if (true)
    {
      (bool l2, bytes memory l3) = payable(this).call{value: 2938695791996711799}("");
    }
    return;
  }
  function f3(bool i0,bool i1) private     returns(function (bytes31, uint144) external   returns (uint160) o0,address[7] memory o1)  {
    o1 = [address(0x0000000000000000000000000000000000000002), address(0x0000000000000000000000000000000000000001), address(0x0000000000000000000000000000000000000005), address(0x0000000000000000000000000000000000000005), address(0x0000000000000000000000000000000000000007), address(0x0000000000000000000000000000000000000003), address(0x0000000000000000000000000000000000000006)];
  }
  function f4() internal virtual     {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    if (true)
    {
      if (false)
      {
        if (true)
        {
        }
      }
      return;
    }
  }
}
type T0 is bytes11;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }




==== Source: su1.sol ====
error er0(address ep0);
struct St0 {
  address payable el0;
}
pragma solidity >= 0.0.0;
// ====
// ----
