
==== Source: su0.sol ====
struct St0 {
  address payable el0;
}
pragma solidity >= 0.0.0;
type T0 is bytes4;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C0 {
  struct St1 {
    function (int40, bytes8, int112) external   el0;
    T0 el1;
    bytes10 el2;
    St0 el3;
  }
  function f0() private      {
    for(;
;
)
    {
      return;
    }
    return;
  }
  string   s0;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bytes26   s1 = bytes26(0x0ae539a7c419d9c62a1a4d372c1b58a74491ea43a197fe3b8f35);
  uint240   s2 = uint240(1766847064778384329583297500742918515827483896875618958121606201292619775);
  constructor(string memory i0)   {
    s0 = string("This is a really long string that must ideally be random but is currently hard coded");
    unchecked {
      (s1) = (bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
      assert(s1 == bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
    }
  }
}
contract C1 {
  function f1(T0 i0) public virtual  payable   {
    if (((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) ** uint104(uint104((((uint160(1179801881186384313969258375861188766384620296432) > uint160(1461501637330902918203684832716283019655932542975)) ? uint104(10616452966034646033301480238680) : uint104(1948635092751492893098384751378)) / uint104(20282409603651670423947251286015))))) <= int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)))
    {
    }
  }
  error er0(bytes29 ep0);
  mapping(address => uint104)  public s3;
  address payable   s4;
  address payable   s5 = payable(address(this));
  C0   s6;
  constructor(address payable i0,C0 i1)   {
    s4 = payable(address(this));
    s6 = C0(address(this));
    s3[address(this)] /= (((~(((uint104(0) * uint104(17281742480359773326090607770705)) % uint104(0)))) * uint104(12411078457458123753446403586211)) | uint104(0));
    unchecked {
    }
  }
  fallback() external virtual  payable
  {
    payable(this).transfer(13843884777781014350);
    this.f1((~(T0.wrap(bytes4(0x9f8605cd)))));
  }
}

==== Source: su1.sol ====
struct St2 {
  bool el0;
  int168 el1;
  uint64 el2;
}
pragma solidity >= 0.0.0;
// ====
// ----
