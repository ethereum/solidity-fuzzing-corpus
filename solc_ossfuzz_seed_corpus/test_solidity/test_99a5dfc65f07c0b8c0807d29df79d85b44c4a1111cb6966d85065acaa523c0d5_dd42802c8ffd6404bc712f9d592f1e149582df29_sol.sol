
==== Source: su0.sol ====
contract C0 {
  type T0 is uint168;
  struct St0 {
    address el0;
    uint32 el1;
    int88 el2;
  }
  int80  public s0;
  int232  public s1 = int232(1225138355698681650368464578454890084109204299828146874157489931774444);
  bool immutable  s2 = false;
  address payable[]   s3;

	function compareMemoryAndStorage(address payable[] memory v1, address payable[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(int80 i0,address payable[] memory i1) payable  {
    s0 -= (int24(8210983) - int16(-11398));
    s3 = i1;
    {
      if (i1.length <= (((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(0)) * uint256(18700228026810664381245875432045317808825772298836706741518980359877510607666)) - uint256(0)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))
      {
        (s0) = ((int80(604462909807314587353087) % ((int80(0) ^ (int80(0) - int80(0))) ^ int80(0))));
        assert(s0 == (int80(604462909807314587353087) % ((int80(0) ^ (int80(0) - int80(0))) ^ int80(0))));
        s3[uint256(0)] = payable(address(this));
        assert(s3[uint256(0)] == payable(address(this)));
      }
      else
      {
        (bool l0, bytes memory l1) = address(this).call(bytes("7205f952fd55496d9f322f7cfae7"));
        s3.pop();
      }
    }
  }
  function f0() public      {
    if (false)
    {
      s3.pop();
      if ((true == false))
      {
      }
      else if (false)
      {
        if (false)
        {
          return;
        }
        else
        {
          return;
        }
        (s3[uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / ((uint256(89564305567228321757257874014402006506825057557924885401566172627934110476190) ^ (uint256(0) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))))], s3[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]) = ((false ? payable(address(this)) : (true ? payable(address(bytes20(address(0x0000000000000000000000000000000000000000)))) : payable(address(this)))), payable(address(this)));
        assert(s3[uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / ((uint256(89564305567228321757257874014402006506825057557924885401566172627934110476190) ^ (uint256(0) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))))] == (false ? payable(address(this)) : (true ? payable(address(bytes20(address(0x0000000000000000000000000000000000000000)))) : payable(address(this)))));
        assert(s3[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] == payable(address(this)));
      }
    }
  }
}
struct St1 {
  bytes14 el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  function f1() public     returns(string memory o0)  {
  }
  uint56  public s4 = uint56(72057594037927935);
  struct St2 {
    uint88 el0;
    address el1;
    string el2;
  }
  type T1 is int72;
}
contract C2 {
  fallback() external   
  {
  }
  struct St3 {
    bool el0;
    bool el1;
  }
  event ev0(address payable  ep0);
  event ev1();
  address payable  public s5;
  constructor(address payable i0) payable  {
    s5 = payable(address(this));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
struct St4 {
  function () external   returns (bytes7, C1.St2 memory, uint176) el0;
  mapping(address => int176) el1;
}
// ====
// ----
