
==== Source: su0.sol ====
error er0();
pragma solidity >= 0.0.0;
struct St0 {
  bytes17 el0;
}

==== Source: su1.sol ====
contract C0 {

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f0(string calldata i0) external virtual     {
    for(uint solinit0 = 0; solinit0 < (((~(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ^ uint256(31213827824639707282154608015839353956648252318936530772031388075477349600748)) % 11); solinit0++)
    {
      break;
    }
    for(uint solinit1 = 0; solinit1 < (uint256((uint256(((((uint256(71973418050918225569640063447521562334268557392939766432998059687030126618247) * uint256(0)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(0)) / uint256(76109795766872370677107717232632590400104692487464898208399990824244518778936))) / uint256(0))) % 11); solinit1++)
    {
      do
      {
        if (bytes(i0).length != uint256(18351034506379308771044959544044192668090590602916147308636510019857047237050))
        {
          if (bytes(i0).length >= (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) & (uint256(79899613878021069721699499956722176721906333013001321051338611284805433296767) << uint176(((uint176(0) ^ uint176(12712606604303509608445401178659227774162334171131725)) + uint176(0))))))
          {
            continue;
          }
        }
        break;
      }
      while (false);
    }
  }
  struct St1 {
    uint216 el0;
    uint136 el1;
    uint136 el2;
  }
  receive() external virtual  payable
  {
  }
  bytes32  public s0 = bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  function f2(bytes32 i0,bytes32 i1) public virtual    returns(function (address, bool) external   returns (bytes15, bool[] memory, uint160) o0)  {
    return (o0);
  }
  struct St2 {
    function (int168) external   returns (bytes16, int32, int176) el0;
    bytes11 el1;
    int120 el2;
  }
}
import "su0.sol";
struct St3 {
  address el0;
  bytes10 el1;
  C0.St1 el2;
  string el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
