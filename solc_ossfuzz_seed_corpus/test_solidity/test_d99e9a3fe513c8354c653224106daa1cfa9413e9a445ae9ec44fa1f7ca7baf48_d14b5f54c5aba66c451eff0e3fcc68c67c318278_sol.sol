
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1
}
contract C0 {
  function f0() external     returns(bool o0)  {
    try this.f0() returns (bool l0)
    {
      address payable l1 = 681070927282837951160293 f1 /*suffix expr*/;
      while ((false ? (true != true) : (false != false)))
      {
        do
        {
          break;
        }
        while ((false ? false : false));
        (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffff"));
      }
      uint80 l4 = uint80((((uint80(1208925819614629174706175) - (uint80(407065810104216461294351) + uint80(1208925819614629174706175))) | uint80(1208925819614629174706175)) / uint80(0)));
    }
    catch
    {
      for(uint solinit0 = 0; solinit0 < ((~(uint256(0))) % 11); solinit0++)
      {
        continue;
      }
    }
  }
  bool public constant cons0 = false;
  mapping(int192 => uint184)   s0;
  address immutable public s1;
  EN0  public s2 = EN0.M0;
  bool  public s3;
  constructor(address i0,bool i1)   {
    s1 = address(this);
    s3 = cons0;
    s0[int192(3138550867693340381917894711603833208051177722232017256447)] = (s0[(int192(0) | int192(3138550867693340381917894711603833208051177722232017256447))] | (uint184(0) >> uint224(uint224(0))));
    unchecked {
    }
  }
  fallback() external virtual  
  {
    (s3) = (true f3 /*suffix expr*/);
    assert(s3 == true f3 /*suffix expr*/);
    (s2) = (EN0.M0);
    assert(s2 == EN0.M0);
  }
}
function f1(uint80 i0) pure suffix  returns(address payable o0)
{
  return (payable(address(0x0000000000000000000000000000000000000005)));
}
function f3(bool i0) pure suffix  returns(bool o0)
{
  do
  {
    if (i0)
    {
      o0 = true;
      assert(o0 == true);
      require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    break;
  }
  while (((((((int256(0) * int256(0)) | int256(15720204628430331421815964346787691844733125139010637308786278611170484498139)) + int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) + int256(-10778160532848688325392142460728461935566386818310184785491858767929740658552)) ^ int256(0)) < int256(-52115046146999045389884579919191259814316314213852012746400548614430868875741)));
  o0 = true;
  assert(o0 == true);
}

==== Source: su1.sol ====
struct St0 {
  int104 el0;
  bytes10 el1;
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
