
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(bool indexed ep0, function (bool) external   returns (address) indexed ep1);
  function f0(address payable i0,bool i1,function (bytes13, address payable[4] memory, uint32) external   i2) external      {
  }
  bytes11   s0 = bytes11(0xffffffffffffffffffffff);
  address payable   s1;
  mapping(uint232 => uint112)   s2;
  constructor(address payable i0) payable  {
    s1 = payable(address(this));
    s2[uint232(6901746346790563787434755862277025452451108972170386555162524223799295)] |= ((((uint112(5192296858534827628530496329220095) | uint112(3202274764640936506158787600983315)) ^ uint112(5192296858534827628530496329220095)) ^ uint112(5192296858534827628530496329220095)) << uint80(uint80(681817141383688681286705)));
    unchecked {
    }
  }
  fallback() external   
  {
    if ((uint216(0) == (uint216(0) | uint216((uint216(uint24(0)) / uint216(35951683415475903927892808471032645977072580898801425384840052342))))))
    {
      return;
    }
    else if (false)
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    this.f0({i0: payable(ecrecover(sha256(true f3 /*suffix expr*/), uint8(4), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000), (bytes32(0xae1245b1068b15fe59309c565b1bfc6b1ce1c2b5fb1ff745311e745fd440d79e) & bytes32(0xe668a54db1d21a25ede9823c9e37a5923703f09b57529e7aa7b9ccf2751f591f)))), i1: true, i2: 0x0000000000000000000000000000000000000000 f4 /*suffix expr*/});
  }
  receive() external   payable
  {
    return;
  }
}
type T0 is uint72;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function f2(bytes24 i0) pure suffix  returns(bool o0)
{
}
function f3(bool i0) pure suffix  returns(bytes memory o0)
{
  if (i0)
  {
    for(uint solinit0 = 0; solinit0 < (uint256(69431125946503627998127618917189902984990655541154688844327026618640532274810) % 11); solinit0++)
    {
      break;
    }
  }
}
function f4(address i0) pure suffix  returns(function (bytes13, address payable[4] memory, uint32) external   o0)
{
  do
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  while (true);
}

==== Source: su1.sol ====
struct St0 {
  address payable el0;
  bool el1;
  int160 el2;
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
