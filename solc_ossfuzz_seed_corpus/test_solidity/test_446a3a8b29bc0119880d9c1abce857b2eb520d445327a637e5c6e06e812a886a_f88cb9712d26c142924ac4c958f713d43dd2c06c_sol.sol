
==== Source: su0.sol ====
contract C0 {
  bytes23   s0 = bytes23(0x0000000000000000000000000000000000000000000000);
  bytes  public s1 = bytes("ffffffffffffffffffffffffd727bc0d5c43f8");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f0(bytes23 i0) public virtual    returns(bool o0,function (function (bytes memory, int192) external   returns (int72, address payable, bool[9] memory)) external   returns (address payable) o1)  {
    s1.push("\x8b");
    s1.push("\xe8");
  }
  type T0 is bytes25;
  function f1() public virtual    returns(int152 o0)  {
    if (true)
    {
      s1.push("\xa2");
    }
    else if (true)
    {
      s1.push();
      if ((true f2 /*suffix expr*/ ? ((0x0000000000000000000000000000000000000007 f3 /*suffix expr*/ & (uint64(3141618928104442530) * uint64(18446744073709551615))) < uint64(0)) : false))
      {
      }
    }
    for(    uint168(82939384146402471318675896433983685171128469441834);
false;
)
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000ffffffffffffff"));
      for(      bool l2 = false;
;
new mapping(int248 => int16)[](6))
      {
        (bool l3, bytes memory l4) = address(this).call(bytes("0000000000000000000000000000000039750873b45de8410e0bad773763412dfdcb4655e496d9aabd97ff68df4576"));
        return (int152((int152(0) / (((int152(2581589827687431584137250144777766106695646939) | int152(-838399231790280162942647541621212887547863600)) + int152(0)) & int152(2787068851517960532864268699511670754598274361)))));
      }
      continue;
    }
  }
  struct St0 {
    string el0;
    bool el1;
    int104 el2;
  }
}
pragma solidity >= 0.0.0;
function f2(bool i0) pure suffix  returns(bool o0)
{
  if (i0)
  {
    address payable[] memory l0 = new address payable[](9);
  }
  for(uint solinit0 = 0; solinit0 < (address(0x0000000000000000000000000000000000000006).balance % 11); solinit0++)
  {
    address l1 = address(0x0000000000000000000000000000000000000004);
    assert(0x0000000000000000000000000000000000000003 f4 /*suffix expr*/);
  }
}
function f3(address i0) pure suffix  returns(uint64 o0)
{
}
function f4(address i0) pure suffix  returns(bool o0)
{
  return (false);
}

==== Source: su1.sol ====
contract C1 {
  fallback() external   
  {
    while (true)
    {
      return;
    }
    (int240(0) * (int72(1007128914119425296134) & (false ? int240(0) : int240(430227429331395111265595842399056937027956071347719663027954441745894972))));
    (bool l0, bytes memory l1) = address(this).call((false ? bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") : bytes(0 f6 /*suffix expr*/)));
    if (false)
    {
    }
  }
  int96  public s2;
  constructor(int96 i0) payable  {
    s2 |= ((((int24(8388607) + int24(-4068094)) - int96(39614081257132168796771975167)) | int96(-33550982978243260421038799519)) & int96(39614081257132168796771975167));
    unchecked {
    }
  }
  address public constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
  type T1 is bytes30;
}
pragma solidity >= 0.0.0;
struct St1 {
  bytes4 el0;
  address payable el1;
  bool el2;
}
function f6(int104 i0) pure suffix  returns(string memory o0)
{
  revert(string("This is a really long string that must ideally be random but is currently hard coded"));
}
// ====
// ----
