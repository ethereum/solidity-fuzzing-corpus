
==== Source: su0.sol ====
bool constant cons0 = false;
contract C0 {
  function f0() external virtual     {
    try this.f0()
    {
      return;
    }
    catch
    {
      if (((uint88(0) & (uint88((uint32(0) / uint88(114678624004277308388079882))) << uint32(uint32(0)))) != uint88(74762762144422164474543450)))
      {
        uint160 l0 = uint160(0);
      }
      if (true)
      {
        address payable l1 = payable(address(this));
        if (true)
        {
        }
      }
      else
      {
      }
    }
  }
  struct St0 {
    int144 el0;
    uint144 el1;
    address el2;
  }
  bytes24 immutable  s0 = bytes24(0x000000000000000000000000000000000000000000000000);
  struct St1 {
    function (address payable, bool, bool) external   returns (string memory, function (bytes28[] memory) external  ) el0;
    function (int208, C0.St0 memory) external   el1;
  }
  fallback() external virtual  
  {
    try this.f0()
    {
    }
    catch
    {
      this.f0();
      if (((uint16(0) & uint16(65535)) < (uint16((uint16(6614) / uint16(63824))) ^ uint16(25042))))
      {
        bytes24  l0 = s0;
        bytes24  l1 = l0;
        assert(l1 == s0);
        (~(int64(9223372036854775807)));
      }
      else if (cons0)
      {
        if (true)
        {
        }
        else if (false)
        {
          while (true f2 /*suffix expr*/)
          {
            this.f0();
            return;
          }
        }
        for(        bool l2 = true;
true;
)
        {
          uint216 l3 = (uint216(43841689122614032075969097954995438464853909366850895205734686024) + (uint200((int200(803469022129495137770981046170581301261101496891396417650687) - int200(524165877032504943251189155434739067449554958416825623033186))) ^ uint216(66473319853270113535482442930088894344410418280776828624228630462)));
        }
      }
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 {
  fallback() external   
  {
  }
  event ev0(function (uint152) external   returns (int224, address payable, bytes9)  ep0, address  ep1, address[5][1]  ep2, uint56 indexed ep3);
  bool   s1 = false;
}
struct St2 {
  address el0;
  bool el1;
  bytes24 el2;
  int24 el3;
}
function f2(bool i0) pure suffix  returns(bool o0)
{
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St3 {
  bool el0;
  bytes16[2] el1;
  bytes el2;
  bool el3;
}
contract C2 {
  error er0(function () external   returns (address payable) ep0, bool ep1);
  bool  public s2 = false;
  address payable immutable  s3;
  bool immutable  s4 = false;
  bytes12  public s5 = bytes12(0x000000000000000000000000);
  constructor(address payable i0) payable  {
    s3 = payable(ecrecover((bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & ((true ? bytes7(0xffffffffffffff) : bytes7(0x39c03e7faee528)) | bytes32(0x343f65287bcb0d7e64b32350ce6be196a5a2d2d20595289a524cf7726eba6762))), uint8(0), bytes32(0xda33dd3995d3c958d01864b36f97e692e8c58cb0a1faca7ab07cf3b53ca463b0), bytes32(0x0c8a45385feceb784758749bd124889d4a0b4ffe2f62e44232e1f98c093170f5)));
    unchecked {
    }
  }
  receive() external virtual  payable
  {
  }
}
int192 constant cons1 = 0;
// ====
// ----
