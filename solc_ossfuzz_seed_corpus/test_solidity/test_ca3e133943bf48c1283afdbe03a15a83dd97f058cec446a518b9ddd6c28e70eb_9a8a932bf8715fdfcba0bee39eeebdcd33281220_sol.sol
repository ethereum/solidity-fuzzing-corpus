
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  modifier m0(bool i0,bool i1) 
  {
    _;
  }
  bytes26 public constant cons0 = bytes26(0xf221e5f81fb7339b335aa986a1a67b180c7e3320b4855522d813);
  modifier m1() 
  {
    _;
  }
  uint16 public constant cons1 = (((uint16(0) + ((uint16(368) ** uint56(uint56(72057594037927935))) - uint16(63737))) + uint16(21121)) << uint24(uint24(16777215)));
  event ev0(bool  ep0) anonymous;
  function f0(string memory i0,function () external   i1) external    returns(string[] memory o0)
  {
  }
  error er0();
  error er1();
}
using L0 for uint;
function f1()    
{
  emit L0.ev0(true);
}
contract C0 {
  fallback() external   
  {
    return;
    assembly
    {
    }
  }
  modifier m2(function () external   returns (function () external  , uint160, uint208)[2] memory i0) virtual
  {
    if (false)
    {
      _;
      if ((true != true))
      {
        do
        {
          i0[1] = i0[0];
        }
        while ((true ? (!(true)) : true));
      }
    }
    else if ((true || (!((((int136(43556142965880123323311949751266331066367) & int136(43556142965880123323311949751266331066367)) >= int136(43556142965880123323311949751266331066367)) || false)))))
    {
    }
    else if ((false || true))
    {
    }
    assembly
    {
      if i0
      {
        if 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          {
            i0 := 0
          }
        }
      }
      switch i0
      default
      {
      }
    }
    if (false)
    {
    }
    else if (false)
    {
    }
  }
  type T0 is bytes20;
  using L0 for *;
  event ev1(C0.T0  ep0, bytes15  ep1);
  C0.T0  public s0;
  bool   s1 = false;
  constructor(C0.T0 i0)   {
    s0 = C0.T0.wrap(bytes20(address(0x0000000000000000000000000000000000000000)));
    unchecked {
      emit L0.ev0(false);
      for(      uint136 l0 = uint136(87112285931760246646623899502532662132735);
;
)
      {
        emit ev1(C0.T0.wrap(bytes20(address(0x0000000000000000000000000000000000000000))), bytes15(0x2afe0e13f1266a9cfdd407b2cfb67c));
        assert(((uint32(4294967295) != uint32(3600933256)) || true));
        continue;
      }
    }
  }
  struct St0 {
    uint64 el0;
    string el1;
  }
  modifier m3() virtual
  {
    _;
  }
  function f3(bytes calldata i0,address payable i1) public  m3() payable
  {
    (bool l0, bytes memory l1) = address(this).call("7de4b9216c69529a7b693b90");
  }
}
// ====
// ----
