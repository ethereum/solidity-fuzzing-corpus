
==== Source: su0.sol ====
contract C0 {
  event ev0(uint160  ep0, int16  ep1, bool  ep2) anonymous;
  bytes4 immutable  s0 = bytes4(0xffffffff);
  mapping(bool => address)   s1;
  uint256  public s2 = uint256(57998035516043997269072292431956450058055883343913716866299784811610117139448);
  constructor()   {
    s1[false] = address(this);
    {
    }
  }
  struct St0 {
    bytes el0;
  }
}
function f0()      returns(int248 o0,string memory o1){
  delete o1;
  do
  {
    break;
  }
  while (false);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f1()     {
  return;
}
function f2(uint56[] memory i0,bytes32 i1)      returns(bytes memory o0){
}
contract C1 {
  struct St1 {
    bool el0;
    bytes el1;
  }
  address   s3;
  bool   s4;
  constructor(address i0,bool i1) payable  {
    s3 = address(this);
    s4 = ((bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff) ^ bytes26(0x0000000000000000000000000000000000000000000000000000)) <= bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
    unchecked {
    }
  }
  type T0 is address;
  error er0();
  function f3(address i0,bool i1) private      {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  function f4(address i0) public virtual     {
    do
    {
      break;
    }
    while (false);
    (bool l0, bytes memory l1) = address(this).call(bytes("00000000000000000003c8"));
  }
}
function f5(uint232 i0)      returns(int32 o0){
  for(uint solinit0 = 0; solinit0 < (uint256(0) % 11); solinit0++)
  {
    break;
  }
}
// ====
// ----
