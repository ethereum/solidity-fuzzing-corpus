
==== Source: su0.sol ====
struct St0 {
  bytes26 el0;
  int80 el1;
}
uint200 constant cons0 = 509493595439962244546664013574088437862087865416396914493192;
contract C0 {
  function f0() external virtual    returns(bool o0,int216 o1)  {
    return (false, int216(0));
  }
  event ev0(bytes17  ep0);
  function f1() external   payable  returns(bytes22 o0)  {
    while ((uint192(0) < (uint192((uint192(0) / uint192(291646669497202754044512287585384615805746006613847381791))) * uint192(6277101735386680763835789423207666416102355444464034512895))))
    {
      continue;
    }
  }
  address payable   s0 = payable(address(this));
  bytes3  public s1;
  bool   s2;
  bool   s3;
  constructor(bytes3 i0,bool i1,bool i2) payable  {
    s1 ^= bytes2(0x0000);
    s2 = (true ? (payable(address(this)) != payable(address(this))) : false);
    s3 = false;
    unchecked {
    }
  }
  function f2(bool i0) external virtual  payable   {
    while ((hex"0000000000000000" f3 /*suffix expr*/ > bytes20(address(0x0000000000000000000000000000000000000000))))
    {
      (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSignature("f1()"));
      try this.f2({i0: true})
      {
        break;
      }
      catch
      {
        while (false)
        {
          (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
          (((uint184(0) << uint80(uint80(547247129278461635014630))) >= (uint184(18023421220310123446181856379589809707623237698434844034) & uint184(24519928653854221733733552434404946937899825954937634815))) ? bytes11(0xffffffffffffffffffffff) : bytes11(0x0dd514382b2bb87a5a10ad));
        }
        continue;
      }
      catch Error(string memory l4)
      {
        St0 storage l5;
        continue;
      }
    }
  }
}
struct St1 {
  St0 el0;
  address el1;
  string el2;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52
}
pragma solidity >= 0.0.0;
function f3(bytes8 i0) pure suffix  returns(bytes11 o0)
{
}

==== Source: su1.sol ====
struct St2 {
  mapping(address => address) el0;
  bytes el1;
}
function f4(function (bytes31) external   returns (address payable) i0)     {
  while ((false ? false f5 /*suffix expr*/ : true))
  {
    break;
  }
}
error er0();
pragma solidity >= 0.0.0;
function f5(bool i0) pure suffix  returns(bool o0)
{
  (o0, o0) = (false, true);
  assert(o0 == false);
  assert(o0 == true);
}
// ====
// ----
