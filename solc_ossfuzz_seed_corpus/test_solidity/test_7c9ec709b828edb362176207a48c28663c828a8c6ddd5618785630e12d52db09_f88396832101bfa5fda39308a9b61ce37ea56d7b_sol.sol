
==== Source: su0.sol ====
struct St0 {
  function () external   returns (address payable) el0;
  int72 el1;
}
contract C0 {
  int176 public constant cons0 = (int176((int176((((int176((int176(47890485652059026823698344598447161988085597568237567) / int176(0))) * int176(0)) ** uint24(uint24(16777215))) / int176(0))) / int176(47890485652059026823698344598447161988085597568237567))) + int176(-20319450501173383451935757455735252722875490021054413));
  receive() external   payable
  {
    return;
  }
  modifier m0(bool i0,address payable i1) 
  {
    _;
  }
  struct St1 {
    address el0;
    address payable el1;
    mapping(address => address) el2;
  }
  modifier m1(string memory i0) virtual
  {
    _;
    do
    {
      address l0 = address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    }
    while ((!(false)));
  }
  bytes32   s0 = bytes32(0x65340a56ffe53935594d605d27977337aabe2ac8329c4c1aabcddf93b84610f8);
  address payable  public s1;
  constructor(address payable i0) payable  {
    s1 = payable(address(this));
    unchecked {
    }
  }
  error er0(bool ep0);
  modifier m2(bytes10 i0) 
  {
    _;
  }
  function f1(string calldata i0,St0 memory i1) public  m0(true,s1) payable returns(function (bytes memory) external   returns (bool, address, function (bytes8) external  ) o0)
  {
    assembly
    {
      return(calldataload(mod(s0.slot, calldatasize())), s0.offset)
      stop()
      switch 76351468639717159034969322594375084217034604397836749064550675529700831137109
      case 0
      {
      }
      case 6766670011836472532283787110120940077081353146498247708155078944316424023829
      {
        let al0 := s0.offset
        for 
        {
          mstore(mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 2048), 0)
        }
        0
        {
          i1 := 15855864999154564726585501433423572743635582121451781243618596694408330664062
          switch al0
          case 107587317369072516787437968424416277797277294345922473097201921412114346726696
          {
          }
          case 0
          {
            switch gaslimit()
            case 115792089237316195423570985008687907853269984665640564039457584007913129639935
            {
              al0 := s0
            }
          }
        }
        {
          for 
          {
            i1 := s1.slot
          }
          cons0
          {
            return(0, s0)
          }
          {
            continue
            continue
            continue
            continue
            al0 := al0
          }
        }
      }
      case 29958824213271986283908444627390674511820422813816748051241405073640864817475
      {
      }
      default
      {
        let al1 := 0
        i1 := s0.offset
      }
    }
    (bool l0, bytes memory l1) = payable(this).call{value: 17363541085172132424}("");
    return (o0);
  }
  error er1(bool ep0);
  event ev0(function (bool) external   returns (address, int184) indexed ep0);
}
bool constant cons1 = ((((((uint192(1042201626160530425789442030187596049545248001427419133472) ** uint184(uint184(17275210027101603283326160578558226339360754413586277782))) - uint192(6277101735386680763835789423207666416102355444464034512895)) * uint192(6277101735386680763835789423207666416102355444464034512895)) ^ uint192(4151309897029215270033007782306079234172072404577064297118)) | uint192(6277101735386680763835789423207666416102355444464034512895)) < uint192(2808587561156952311947389130383212346089974819956346799053));
error er2();
function f2(address payable i0,function (function () external   returns (int160, int184, address), bool) external   returns (bytes23[1] memory, uint112, bool) i1)     returns(St0[] memory o0,address o1,int80 o2)
{
  bool l0 = cons1;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36
}
pragma solidity >= 0.0.0;
// ====
// ----
