
==== Source: su0.sol ====
contract C0 {
  event ev0(int152  ep0, address payable  ep1);
  fallback() external virtual  
  {
  }
  int176 immutable  s0;
  address  public s1;
  uint112   s2 = uint112(5192296858534827628530496329220095);
  constructor(int176 i0,address i1) payable  {
    s0 = int176(0);
    s1 = address(this);
    unchecked {
      revert("00000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
  }
  function f1() external    returns(uint248 o0,address o1)
  {
    (o1) = (address(this));
    payable(this).transfer(9865569455290835309);
  }
  struct St0 {
    uint32[2] el0;
    address el1;
    uint176 el2;
  }
  modifier m0(bytes memory i0) virtual
  {
    _;
  }
  function f2() public  m0(bytes("00000000000000000000000000ffffff")) payable returns(function (int16, address) external   returns (C0.St0 memory, address, C0.St0 memory) o0,int88[] memory o1)
  {
    emit ev0(int152(2854495385411919762116571938898990272765493247), payable(address(this)));
    return (o0, new int88[](1));
    if (false)
    {
      (function (int16, address) external   returns (C0.St0 memory, address, C0.St0 memory) l0, int88[] memory l1) = this.f2();
    }
    else if ((int80(0) < (int80(604462909807314587353087) % int80(0))))
    {
    }
    else
    {
      emit ev0(int152(-1976947474391920859271200760260009869237565927), payable(address(this)));
    }
  }
  receive() external  m0("00000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffff") payable
  {
    try this.f1() returns (uint248 l0, address l1)
    {
    }
    catch
    {
    }
    emit ev0((int152((int152(0) / int152(37356852883694410593475549150328646714646032))) * (int152(-1094859268407369202578036514064085206609285083) * int152(431851505895111333007921980061078077902229753))), payable(address(this)));
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10
}
pragma solidity >= 0.0.0;
type T0 is bytes24;
// ====
// ----
