
==== Source: su0.sol ====
error er0();
contract C0 {
  bytes29   s0;
  constructor(bytes29 i0)   {
    s0 &= (false ? bytes29(0x86583b0b373a093590567611b56e088e7722ff3f6f7c4b88e1324f3bce) : ((bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes29(0x0000000000000000000000000000000000000000000000000000000000)) & bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    {
      bytes29  l0 = s0;
      bytes29  l1 = l0;
      assert(l1 == s0);
    }
  }
  function f0(bytes29 i0,bytes29 i1) external     returns(function (function () external  , bytes7) external   returns (address[6] memory) o0,int184 o1,address payable o2)  {
    o2 = payable(address(this));
    assert(o2 == payable(address(this)));
    while (true)
    {
      if (i1 <= (((int32(0) < int32(0)) ? bytes1(0x00) : bytes29(0x7bc60d145ea86fa3a32800570130fef915f3edaa4b076e13f2ae527b79)) | bytes29(0x0000000000000000000000000000000000000000000000000000000000)))
      {
        uint120(0);
        bytes16 l0 = bytes16(bytes21(0xffffffffffffffffffffffffffffffffffffffffff));
      }
      return (o0, int184(0), (true ? payable(address(this)) : payable(address(this))));
    }
  }
}
function f1(string memory i0)      returns(string[2] memory o0,bytes31 o1){
  o0 = [string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")];
  (bytes3(0x784c62) | bytes3(0x000000));
}
pragma solidity >= 0.0.0;
struct St0 {
  address el0;
  bool el1;
}

==== Source: su1.sol ====
function f2()      returns(bool o0){
  while (false)
  {
    if ((bytes31(bytes11(bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff))) <= bytes31(0x00000000000000000000000000000000000000000000000000000000000000)))
    {
      o0 = false;
      assert(o0 == false);
      if (((bytes22(0x00000000000000000000000000000000000000000000) == bytes22(bytes30(0x000000000000000000000000000000000000000000000000000000000000))) ? false : true))
      {
        (o0) = (((((uint248(0) * (uint248(277691526295105244351684631152095982010457723309096275559720209436761913326) << uint32(uint32(0)))) - uint248(211459558448115834358855878416097826934071418630314219682952192612938354662)) & uint248(269673459104651170860057029340434193019599677204990103850604649539148163725)) >= uint248(0)));
        assert(o0 == ((((uint248(0) * (uint248(277691526295105244351684631152095982010457723309096275559720209436761913326) << uint32(uint32(0)))) - uint248(211459558448115834358855878416097826934071418630314219682952192612938354662)) & uint248(269673459104651170860057029340434193019599677204990103850604649539148163725)) >= uint248(0)));
      }
      else
      {
        if (false)
        {
          return (true);
        }
      }
      o0 = false;
      assert(o0 == false);
      while (false)
      {
      }
    }
    else
    {
    }
  }
}
contract C1 {
  fallback() external virtual  
  {
  }
  event ev0();
  bytes26  public s1 = bytes26(0x92fe0763380fff9611a741fccb86a1101643e05dcc740d666516);
  uint40   s2;
  bool immutable public s3 = false;
  bool   s4;
  constructor(uint40 i0,bool i1)   {
    s2 -= uint40(43729296080);
    s4 = (f2() != f2());
    unchecked {
    }
  }
  struct St1 {
    bytes2[5] el0;
    bytes17 el1;
    int200 el2;
    address el3;
  }
  error er1(uint40 ep0);
  function f4(bytes26 i0,uint40 i1) internal virtual    returns(address payable o0)  {
    emit ev0();
    if (i1 >= uint40(313524278398))
    {
      revert er1(uint40(392411421842));
    }
    else
    {
      bool  l0 = s3;
      bool  l1 = l0;
      assert(l1 == s3);
      if (i0 == bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff))
      {
        emit ev0();
      }
      if (i1 <= uint40(593346805475))
      {
      }
    }
  }
}
pragma solidity >= 0.0.0;
error er2(int200 ep0, bytes6 ep1);
// ====
// ----
