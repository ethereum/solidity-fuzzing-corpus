
==== Source: su0.sol ====
error er0(int224 ep0);
contract C0 {
  mapping(uint176 => uint208)   s0;
  constructor()   {
    s0[uint176(68760566383768374161097427901353994628708754565711894)] <<= ((hex"0000000000000000000000000000" f0 /*suffix expr*/ - uint208((((uint208(411376139330301510538742295639337626245683966408394965837152255) | uint208(0)) | uint208(411376139330301510538742295639337626245683966408394965837152255)) / uint208(411376139330301510538742295639337626245683966408394965837152255)))) & uint208(276478438157004770580346978934941531117491560183432920203126288));
    unchecked {
      if (true)
      {
        if (true)
        {
        }
      }
    }
  }
  function f1(uint232 i0) public virtual  payable  returns(bytes memory o0,uint240 o1)  {
    o1 <<= (((uint240(166200129977368830387190281192833789494134467499584524881304497262163541) ^ uint240(0)) * uint240(0)) * uint240(0));
  }
}
pragma solidity >= 0.0.0;
function f0(bytes14 i0) pure suffix  returns(uint208 o0)
{
  if (i0 >= bytes14(0x76634cb715dfbbfe26485b8b28b5))
  {
    if (i0 >= (bytes14(0xffffffffffffffffffffffffffff) ^ ((true ? bytes14(0x0000000000000000000000000000) : bytes14(0x0000000000000000000000000000)) | bytes14(0xffffffffffffffffffffffffffff))))
    {
      bytes29 l0 = bytes29(0x0aa5adb1a7b6d409526cd40d966aec6d36c08307ecd434ae9390efb3c5);
    }
  }
  if (i0 != bytes14(0x77c719df84544d1fea811d5aaa4f))
  {
    if (i0 >= bytes14(0x0000000000000000000000000000))
    {
      if (i0 == (bytes14(0x0000000000000000000000000000) ^ (false ? (bytes14(0xffffffffffffffffffffffffffff) & bytes14(0xffffffffffffffffffffffffffff)) : bytes14(0x0000000000000000000000000000))))
      {
        if (i0 != bytes14(0x0000000000000000000000000000))
        {
        }
        else if (i0 != bytes14(0xffffffffffffffffffffffffffff))
        {
        }
      }
      else
      {
        (o0, o0) = (uint208(0), uint208(106642248259366336183144582099436447875313221335402511817738095));
        assert(o0 == uint208(0));
        assert(o0 == uint208(106642248259366336183144582099436447875313221335402511817738095));
        while (false)
        {
          ((int16(0) * (-((int16(0) + int16(0))))) & int16(32767));
        }
      }
      (o0) = ((uint208(411376139330301510538742295639337626245683966408394965837152255) ^ uint208(0)));
      assert(o0 == (uint208(411376139330301510538742295639337626245683966408394965837152255) ^ uint208(0)));
    }
  }
}

==== Source: su1.sol ====
contract C1 {
  receive() external   payable
  {
  }
  bytes31  public s1;
  address payable   s2 = payable(address(this));
  constructor(bytes31 i0) payable  {
    s1 = bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  fallback() external virtual  
  {
  }
  struct St0 {
    address payable[] el0;
  }
}
pragma solidity >= 0.0.0;
type T0 is bytes15;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
