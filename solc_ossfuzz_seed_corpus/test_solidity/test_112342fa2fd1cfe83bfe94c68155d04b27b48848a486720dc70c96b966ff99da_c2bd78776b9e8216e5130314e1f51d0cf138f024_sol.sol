
==== Source: su0.sol ====
contract C0 {
  uint176 public constant cons0 = 0;
  function f0(address i0,uint40 i1,bytes15 i2) external virtual  payable   {
    try this.f0({i0: address(bytes20(address(0x0000000000000000000000000000000000000000))), i1: (uint40(((uint40(int40(549755813887)) * uint40(1099511627775)) / uint40(4498043043))) ** uint208(uint208(199110986103030390153663293799091168291858432469105191661156494))), i2: bytes15(((payable(address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))) >= payable(address(this))) ? bytes13(0xffffffffffffffffffffffffff) : bytes13(0x550a12b18a891566b23bd33906)))})
    {
      if (i2 <= bytes15(0x000000000000000000000000000000))
      {
        (bool l0, bytes memory l1) = address(this).call(bytes("46bb2738801594b38c15ee478c224f45e43f6723ffffffffffffffffffffffffffffffffffffffffffffffff"));
      }
      else
      {
        (bool l2, bytes memory l3) = address(this).call(bytes("0000000000000000000000000000a409110949081369a9c478c3927904e1e4c33fdaa3d078b494ba4c1e6608"));
        try this.f0({i0: address(this), i1: uint40(1099511627775), i2: bytes15(0x000000000000000000000000000000)})
        {
        }
        catch
        {
          if (i0 == msg.sender)
          {
          }
          else
          {
            return;
          }
          uint256 l4 = (((uint256(0) - uint256(0)) | (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) ** uint200(uint200(0)))) + uint256(57200126721330225796013122279735028245620384797036544185222185515573621385616));
        }
      }
    }
    catch
    {
    }
    catch Panic(uint256 l5)
    {
    }
  }
  bytes8  public s0 = bytes8(0xffffffffffffffff);
  int224  public s1 = int224(0);
  error er0();
}
struct St0 {
  mapping(int72 => address) el0;
}
error er1();
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  int168 el0;
  uint64[] el1;
  int120 el2;
  bool el3;
}
struct St2 {
  int120 el0;
  uint128 el1;
}
// ====
// ----
