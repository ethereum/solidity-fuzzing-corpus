
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  string el0;
  int104 el1;
}
function f0(function (uint152) external   i0)     {
  return;
}
contract C0 {
  function f1(function (int192, address payable, uint176) external   i0) public virtual  payable  returns(bytes22 o0,bytes memory o1)  {
    if (false)
    {
      o0 = bytes22(0xd965d9d9c0da6c40151107a2eeaf87d5f3591ddebe45);
      assert(o0 == bytes22(0xd965d9d9c0da6c40151107a2eeaf87d5f3591ddebe45));
      (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffff"));
      o0 = (true ? (~((bytes7(0xd6a82517bd0741) & bytes9(0xeec0447a7547bd42ca)))) : bytes9(0x5acf7515c34cb97c20));
      assert(o0 == (true ? (~((bytes7(0xd6a82517bd0741) & bytes9(0xeec0447a7547bd42ca)))) : bytes9(0x5acf7515c34cb97c20)));
    }
    else if (false)
    {
      (bool l2, bytes memory l3) = address(this).call(bytes(string("This is a really long string that must ideally be random but is currently hard coded")));
    }
  }
  function f2() public      {
    St0 storage l0;
  }
  uint256   s0 = uint256(0);
  struct St1 {
    address payable el0;
    St0 el1;
  }
  function f3() public virtual  payable  returns(function (function (uint160, bytes6, int72) external   returns (address payable, St0[5][] memory)) external   returns (bytes memory, bool) o0,function (uint144, address[6] memory) external   returns (uint56) o1)  {
  }
}
contract C1 {
  function f4(bytes3 i0) public virtual  payable  returns(bool o0,int88 o1,C0 o2)  {
    string storage l0;
    if (i0 != bytes3(0x000000))
    {
      return ((int200(-410469790922342269237890705750085243623078671945851866518601) > ((~(int200((int200(803469022129495137770981046170581301261101496891396417650687) / int200(-252456549999557768999310233209354611304986206147583408267177))))) | int200(0))), int88(-103247570456388737544388767), C0(address(this)));
    }
    else if (i0 == bytes3(0x108868))
    {
    }
    for(    function (address payable, bytes7) external   l1;
true;
)
    {
      continue;
    }
    for(uint solinit0 = 0; solinit0 < (uint40(629421452056) % 11); solinit0++)
    {
      assert((int64(9223372036854775807) == int64(9223372036854775807)));
      break;
    }
  }
  function f5(address i0,bool i1) public virtual     {
    return;
  }
  receive() external   payable
  {
  }
  bool   s1 = false;
  address   s2;
  address immutable public s3 = address(this);
  address   s4;
  constructor(address i0,address i1) payable  {
    s2 = address(this);
    s4 = address(bytes20(address(0x255a18d5EBF2D21C2f6cFC0ABC15fb800D59B0ED)));
    unchecked {
    }
  }
}

==== Source: su1.sol ====
struct St2 {
  address el0;
  int48 el1;
  address el2;
  uint168 el3;
}
pragma solidity >= 0.0.0;
bytes26 constant cons0 = bytes26(0x6b446d0da877487ca3f02184d883aa4de14a28e6824f6857fea5);
// ====
// ----
