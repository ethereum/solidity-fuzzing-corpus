
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    bool el0;
  }

	function compareMemoryAndCalldata(C0.St0 memory v1, C0.St0 calldata v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  function f0(function () external   returns (bytes memory) i0,C0.St0 memory i1,uint72 i2) public virtual  payable  returns(bytes29[] memory o0)  {
    for(uint solinit0 = 0; solinit0 < (uint256(0) % 11); solinit0++)
    {
      return ((((true ? ((uint64(0) * uint64(18446744073709551615)) | uint64(18446744073709551615)) : uint64(18446744073709551615)) == uint64(12569285079415731091)) ? new bytes29[](8) : new bytes29[](8)));
    }
  }
  mapping(int128 => C0.St0[])   s0;
  int104   s1 = int104(10141204801825835211973625643007);
  int24 immutable  s2;
  constructor(int24 i0) payable  {
    s2 = (int24(8388607) * (~(((int24(-7672792) ** uint224(uint224(0))) ^ int24(-7182112)))));
    unchecked {
    }
  }
  type T0 is uint128;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bytes23[3] el0;
  uint184 el1;
}
// ====
// ----
