
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint256[] el0;
  int104 el1;
  mapping(bool => bytes28) el2;
}
library L0 {
  event ev0(function (bytes30, function (uint88, bool) external   returns (bytes24), address payable) external   returns (function (address, bytes27) external   returns (string memory, address payable[2] memory, uint256), bytes5, address)  ep0, bytes23 indexed ep1, function (bytes[1] memory) external    ep2) anonymous;
  error er0();
}
contract C0 {
  event ev1(function (int168) external   returns (bytes4)  ep0, uint152  ep1, int192  ep2) anonymous;
  fallback() external   
  {
  }
  bytes2   s0 = bytes2(0x1f7d);
  address payable   s1 = payable(address(this));
  bytes5   s2;
  address payable   s3 = payable(address(this));
  constructor(bytes5 i0) payable  {
    s2 &= bytes5(0xffffffffff);
    {
      s2 = bytes5(0x6633f88b33);
      revert L0.er0();
      if (false)
      {
      }
      do
      {
      }
      while ((int40(533208836762) >= (int40(549755813887) % int40((int40(0) / int40(549755813887))))));
    }
  }
  function f1(bytes22[1] calldata i0,bytes23 i1) public virtual  payable
  {
  }
  type T0 is uint160;
  int152 public constant cons0 = ((((int152(0) - (~(int152(2854495385411919762116571938898990272765493247)))) | int152(-962227859077978314147940773923772964001602230)) ^ int152(0)) * int152(2854495385411919762116571938898990272765493247));
  event ev2() anonymous;
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47

  }
  error er1();
  using L0 for *;
}
// ====
// ----
