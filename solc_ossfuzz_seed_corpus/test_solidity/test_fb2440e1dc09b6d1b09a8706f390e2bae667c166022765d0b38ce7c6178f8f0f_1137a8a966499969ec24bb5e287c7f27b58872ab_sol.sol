==== Source:  ====

==== Source: su0.sol ====
function f0()      returns(int240[] memory o0){
}
int104 constant cons0 = 0;
pragma solidity >= 0.0.0;
struct St0 {
  address payable el0;
  int80 el1;
}

==== Source: su1.sol ====
contract C0 {
  address payable   s0 = payable(address(this));
  int104  public s1 = int104(8348717284846125698499556540454);
  event ev0() anonymous;
  function f1() public virtual     {
    payable(this).transfer(0);
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
  }
  receive() external virtual  payable
  {
    if (true)
    {
      if ((((bytes1(0xff) | (true ? bytes3(0xffffff) : bytes3(0x8e8dec))) | bytes3(0xffffff)) <= bytes3(0xffffff)))
      {
      }
      else if ((address(this) >= address(this)))
      {
      }
    }
    else if (true)
    {
      emit ev0();
      do
      {
        break;
      }
      while (true);
      while (true)
      {
        (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSelector(this.f1.selector));
        if (false)
        {
          (bool l2, bytes memory l3) = payable(this).call{value: 2627165625528806130}("");
        }
        else
        {
          return;
        }
      }
    }
  }
  function f3(int104 i0) external   payable  returns(uint160[] memory o0)  {
  }
  function f4() public      {
    try this.f3(int104(0)) returns (uint160[] memory l0)
    {
      emit ev0();
    }
    catch
    {
      emit ev0();
    }
    catch Error(string memory l1)
    {
      if (true)
      {
        revert(string(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000")));
      }
      return;
    }
    return;
  }
  struct St1 {
    bytes29 el0;
  }
  fallback() external   
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 7018316652860250843}("");
    emit ev0();
    emit ev0();
    emit ev0();
  }
}
import "su0.sol";
struct St2 {
  int80[] el0;
  bytes9 el1;
}
pragma solidity >= 0.0.0;
function f6()      returns(bytes22 o0){
  do
  {
    do
    {
      break;
    }
    while (true);
    continue;
  }
  while (true);
  return (bytes22(0x00000000000000000000000000000000000000000000));
}
// ----
// Warning 5740: (su1.sol:1844-1848): Unreachable code.
// Warning 5740: (su1.sol:651-655): Unreachable code.
// Warning 2072: (su1.sol:224-231): Unused local variable.
// Warning 2072: (su1.sol:233-248): Unused local variable.
// Warning 2072: (su1.sol:694-701): Unused local variable.
// Warning 2072: (su1.sol:703-718): Unused local variable.
// Warning 2072: (su1.sol:824-831): Unused local variable.
// Warning 2072: (su1.sol:833-848): Unused local variable.
// Warning 5667: (su1.sol:1130-1149): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1237-1253): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1530-1537): Unused local variable.
// Warning 2072: (su1.sol:1539-1554): Unused local variable.
// Warning 2018: (su1.sol:1752-1954): Function state mutability can be restricted to pure
