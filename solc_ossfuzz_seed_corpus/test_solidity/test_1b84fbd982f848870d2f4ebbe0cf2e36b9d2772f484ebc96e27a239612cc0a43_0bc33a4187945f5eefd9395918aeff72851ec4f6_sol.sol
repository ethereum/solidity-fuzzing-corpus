
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  struct St0 {
    uint32 el0;
  }
  fallback() external virtual  payable
  {
    for(    bytes28 l0 = (~(bytes28(0x00000000000000000000000000000000000000000000000000000000)));
;
(uint152(0) != (((uint152(0) - uint152(523129472396970577346234676223743545244535756)) ^ uint152(5708990770823839524233143877797980545530986495)) >> uint184(uint184(7439488635794937730673104015688287093011303135606249362)))))
    {
      if (true)
      {
        if (false)
        {
          if (false)
          {
            return;
          }
        }
        else
        {
          do
          {
            continue;
          }
          while (true);
        }
        break;
      }
    }
  }
  error er0(bytes16[] ep0);
  int64   s0;
  address payable   s1;
  int232   s2;
  bytes20  public s3 = bytes20(address(0x0000000000000000000000000000000000000000));
  constructor(int64 i0,address payable i1,int232 i2)   {
    s0 += (((int64(0) ^ int64(9223372036854775807)) + (int64(-6117313844813076202) + int64(2123834815510193738))) ^ int64(9223372036854775807));
    s1 = payable(address(this));
    s2 *= int232(3450873173395281893717377931138512726225554486085193277581262111899647);
    unchecked {
    }
  }
  function f1(address payable i0) external virtual     {
  }
}

==== Source: su1.sol ====
type T0 is address payable;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }





function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) | bytes20(address(T0.unwrap(y)))))); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) & bytes20(address(T0.unwrap(y)))))); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) ^ bytes20(address(T0.unwrap(y)))))); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(payable(address(~bytes20(address(T0.unwrap(x)))))); }






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



import "su0.sol";
pragma solidity >= 0.0.0;
function f2(bool i0,T0 i1)     {
  bytes11 l0 = (~((bytes11(0x0000000000000000000000) ^ bytes11(0xef989d2d1058d76bcde9f5))));
}
// ====
// ----
