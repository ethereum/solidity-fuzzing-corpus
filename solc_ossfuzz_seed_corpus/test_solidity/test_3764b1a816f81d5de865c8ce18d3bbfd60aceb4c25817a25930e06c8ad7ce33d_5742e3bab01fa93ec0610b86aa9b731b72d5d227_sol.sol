
==== Source: su0.sol ====
struct St0 {
  address payable[10] el0;
  bool el1;
  mapping(address => address[5]) el2;
}
contract C0 {
  struct St1 {
    string el0;
  }
  receive() external   payable
  {
    if (false)
    {
    }
    else if (((((~(int192(-1155138973800928395360688660810912093273248707824949804507))) & int192(2071863502862863916213848269966592388603372511769950819287)) + int192(-1200677712814785433311907726552477893721905700472471110370)) != int192(0)))
    {
      return;
    }
    if (true)
    {
    }
    else
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
      return;
    }
  }
  fallback() external   
  {
    if (true)
    {
      bytes memory l0 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
    else if (((bytes10(0x40a163a4fdbafa18b49d) < (0x2F50a8CECEE77f95D89894ca11AF39Fc515d8C81 f2 /*suffix expr*/ | (true ? bytes10(0xd7bfb372f23f5a7cdd1a) : bytes10(0xffffffffffffffffffff)))) == true))
    {
      assert(false);
    }
    return;
  }
  bool   s0 = false;
  bytes25   s1;
  constructor(bytes25 i0) payable  {
    s1 &= (((((bytes25(0x00000000000000000000000000000000000000000000000000) | bytes25(0x00000000000000000000000000000000000000000000000000)) | bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff)) | bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff)) & bytes25(0x00000000000000000000000000000000000000000000000000)) ^ bytes25(0x00000000000000000000000000000000000000000000000000));
    unchecked {
    }
  }
  type T0 is int248;
  function f3() external virtual    returns(int48 o0,bool o1)  {
  }
}
error er0();
pragma solidity >= 0.0.0;
function f2(address i0) pure suffix  returns(bytes10 o0)
{
  return (((true ? bytes10(0x00000000000000000000) : bytes10(0xffffffffffffffffffff)) | bytes10(0xa5e022a88c1359d50a41)));
}

==== Source: su1.sol ====
type T1 is address;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,

eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }





function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(address(bytes20(T1.unwrap(x)) | bytes20(T1.unwrap(y)))); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(address(bytes20(T1.unwrap(x)) & bytes20(T1.unwrap(y)))); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(address(bytes20(T1.unwrap(x)) ^ bytes20(T1.unwrap(y)))); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(address(~bytes20(T1.unwrap(x)))); }






function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32
}
pragma solidity >= 0.0.0;
// ====
// ----
