
==== Source: su0.sol ====
struct St0 {
  int120 el0;
  uint248 el1;
  address el2;
}
type T0 is address payable;
pragma solidity >= 0.0.0;
T0 constant cons0 = T0.wrap(payable(address(0x0000000000000000000000000000000000000002)));
contract C0 {
  uint40   s0 = uint40(0);
  mapping(address => T0)   s1;
  constructor() payable  {
    s1[address(this)] = T0.wrap(payable(address(0x0000000000000000000000000000000000000003)));
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 4594994283294505440}("");
    }
  }
  address payable public constant cons1 = payable(0x0000000000000000000000000000000000000000);
  modifier m0(bool i0) virtual
  {
    _;
  }
  fallback() external  m0((false || (((int96(28658059139606526272012559930) % int96(3434578770679257911104215155)) > int96(10356897407995868346763741290)) && true))) payable
  {
    do
    {
      if (true)
      {
        assembly
        {
          stop()
        }
        continue;
      }
      else
      {
        continue;
      }
    }
    while (false);
    revert(string.concat(string("000000000000000000000000000000000000000000000000000089fdad6a5099207130f17750a6e5084d46289f30b494215bb4e9780d9902"), "000000000000000000000000000000ffffffffffff", "8d0a0c73f65b7e73b13135366ff48224ed0e3acd296dd0867d2d9b3ee231e611c30eb9"));
    if (false)
    {
      (s0) = (((uint40(0) ^ uint40(393325359683)) - ((uint40(0) & uint40(0)) + uint40(0))));
    }
    else if ((((int24((((int24(0) ** uint160(uint160(0))) | int24(8388607)) / int24(1053686))) ** uint88(uint88(309485009821345068724781055))) ^ int24(8388607)) == int24(0)))
    {
    }
    else if (false)
    {
      require((false || (!((bytes17(0x0000000000000000000000000000000000) != bytes17(0x0000000000000000000000000000000000))))));
    }
  }
}
library L0 {
  event ev0();
  type T1 is bytes1;
  bytes7 public constant cons2 = bytes7(0x118a13e8027232);
  modifier m1(function () external   returns (uint32, T0, uint80) i0,uint208 i1) 
  {
    _;
  }
  function f1(uint136 i0) public    returns(St0 memory o0,int248 o1)
  {
  }
  modifier m2() 
  {
    _;
  }
  uint16 public constant cons3 = ((((((uint16(28633) << uint32(uint32(4294967295))) + uint16(0)) & uint16(65535)) ** uint240(uint240(438447758010381296535748787509057760421866773399714963226596746111705469))) + uint16(0)) + uint16(65535));
  modifier m3() 
  {
    unchecked {
      if (false)
      {
        for(;
true;
L0.T1.wrap(bytes1(0xff)))
        {
        }
      }
      else if (true)
      {
      }
      else
      {
        if (false)
        {
        }
        revert("ffffffffffffffffffffffffffffffffffffffffffffffffff");
      }
    }
    _;
    if (true)
    {
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40
  }
  function f2(uint40 i0,L0.EN0 i1) public  m3() 
  {
    (i0) = (((uint40((uint40(1099511627775) / (~((uint40(1099511627775) | uint40(1099511627775)))))) >> uint136(uint136(87112285931760246646623899502532662132735))) | uint40(0)));
  }
}

==== Source: su1.sol ====
error er0(uint200 ep0);
struct St1 {
  uint240 el0;
  bool el1;
  address payable el2;
  uint80 el3;
}
function f3(int192 i0)    
{
}
int96 constant cons4 = ((int96(0) | ((~((int96(0) + int96(0)))) | int96(0))) * int96(39614081257132168796771975167));
pragma solidity >= 0.0.0;
// ====
// ----
