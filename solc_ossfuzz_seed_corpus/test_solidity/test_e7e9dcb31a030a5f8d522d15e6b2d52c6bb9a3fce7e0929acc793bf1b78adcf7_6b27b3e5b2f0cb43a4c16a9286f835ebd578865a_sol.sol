
==== Source: su0.sol ====
struct St0 {
  bytes23 el0;
  function (bool[] memory) external   returns (uint88, bool, bool) el1;
  address el2;
  uint176 el3;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  function f0() public      {
  }
  event ev0(uint24  ep0, function () external    ep1, bytes16  ep2);
  uint96 public constant cons0 = 79228162514264337593543950335;
  function f1(address i0) external virtual  payable   {
    revert(string(bytes("000000000000000000000000000000000000000000")));
  }
  struct St1 {
    function (address) external   returns (bool, bool, int24) el0;
    function (function (bytes4, bytes17) external   returns (address payable), bytes18[10] memory) external   returns (int192, int144[] memory, bytes11[2] memory) el1;
    bool el2;
    bytes6 el3;
  }
  int192[3]   s0;

	function compareMemoryAndStorage(int192[3] memory v1, int192[3] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool   s1;
  constructor(int192[3] memory i0,bool i1)   {
    s0 = i0;
    s1 = true;
    unchecked {
    }
  }
}
struct St2 {
  bool el0;
  bool el1;
  function (address payable, address) external   el2;
  bytes19 el3;
}
struct St3 {
  bytes21 el0;
}
pragma solidity >= 0.0.0;
contract C1 {
  fallback() external   
  {
    while (false)
    {
    }
    return;
  }
  receive() external   payable
  {
    (false ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded"));
    if (true)
    {
      (bool l0) = payable(this).send(12273018426285201106);
    }
    else if (false)
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    for(    address l1 = address(this);
true;
(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655) & (((uint248(0) + uint248(0)) << uint104(uint104(0))) - uint248(217912258774477947832526259114800072578434760293618794752693171749028854638))))
    {
      break;
    }
  }
  function f4(function (string memory) external   i0) external virtual  payable  returns(bool o0,function (uint216) external   returns (uint200) o1,bool o2)  {
    if (false)
    {
      return ((true ? false : true), o1, false);
    }
    if (true)
    {
      (uint200 l0) = o1((~(uint216(105312291668557186697918027683670432318895095400549111254310977535))));
      (bool l1, bytes memory l2) = payable(this).call{value: 939276966143151847}("");
    }
  }
  bytes8   s2 = bytes8(0xfde4e97ce3a1fc97);
  int200   s3;
  uint232  public s4;
  int16   s5;
  constructor(int200 i0,uint232 i1,int16 i2)   {
    s3 &= (true ? (int200(0) + ((int200(-51152018760436878990783621317532268247835852794331828827453) ^ int200(417344568174039035987343966077316214375451876652712661020082)) * int200(-656247530525030225782452823595386000189329930821384519506713))) : int200(0));
    s4 = uint232(0);
    s5 |= (int16(32767) | (int16(5042) % ((int16(32767) * int16(0)) - int16(0))));
    unchecked {
    }
  }
  struct St4 {
    address payable el0;
    bool el1;
    int240 el2;
  }
}
// ====
// ----
