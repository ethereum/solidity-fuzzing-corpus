
==== Source: su0.sol ====
struct St0 {
  int72 el0;
}
contract C0 {
  address   s0 = address(this);
  uint32  public s1;
  address   s2;
  constructor(uint32 i0,address i1) payable  {
    s1 /= ((uint32(0) ** uint32(uint32(((~(uint32(4294967295))) / uint32(0))))) | uint32(301257809));
    s2 = address(this);
    unchecked {
    }
  }
  struct St1 {
    bytes29 el0;
  }
  function f0() public virtual    returns(int232 o0,address payable o1,address o2)  {
    if (false)
    {
      o1 = payable(address(this));
      assert(o1 == payable(address(this)));
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffff737e5cbadd81a0ea8d8d00a76ea1e3b4"));
    }
    (s0) = (address(this));
    assert(s0 == address(this));
    return (int232(3450873173395281893717377931138512726225554486085193277581262111899647), payable(address(this)), (true ? address(this) : (true ? address(this) : address(this))));
  }
  type T0 is address payable;
  error er0();
  struct St2 {
    C0.St1 el0;
    address el1;
  }
}
contract C1 {
  bytes14   s3 = bytes14(0x19a1278629d631868442673c34bb);
  int40   s4 = int40(0);
  C0.T0  public s5 = C0.T0.wrap(payable(address(0x0000000000000000000000000000000000000007)));
  error er1();
  fallback() external   
  {
    do
    {
      continue;
    }
    while (true);
  }
  error er2(C0.T0 ep0, function (bytes10) external   returns (int48[6] memory) ep1);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St3 {
  int40 el0;
  bool[4][] el1;
}
struct St4 {
  int16 el0;
  mapping(uint120 => bool) el1;
  function () external   returns (bool, bytes10) el2;
}
pragma solidity >= 0.0.0;
// ====
// ----
