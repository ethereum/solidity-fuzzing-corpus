==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  struct St0 {
    bool el0;
  }
  receive() external virtual  payable
  {
    return;
  }
  modifier m0() virtual
  {
    _;
    payable(this).transfer(0);
  }
  int176  public s0;
  bytes25  public s1 = bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff);
  uint208   s2;
  constructor(int176 i0,uint208 i1)   {
    s0 *= int176(0);
    s2 <<= uint208(411376139330301510538742295639337626245683966408394965837152255);
    unchecked {
    }
  }
  fallback() external  m0() 
  {
    uint208  l0 = s2;
    uint208  l1 = l0;
    assert(l1 == s2);
    if (true)
    {
      for(      address payable l2 = payable(address(((bytes20(address(0x9c2a9e0B07789c23AB258bD506cc3A25724780DA)) ^ bytes20(address(0x0000000000000000000000000000000000000000))) & (bytes20(address(0x824be99d436B4954BAff5801cB983287D90e677A)) ^ bytes20(address(0x6D0eC7cF6b206cfAd4973d0A132B09a6D2c83042))))));
;
bytes15(0x000000000000000000000000000000))
      {
        continue;
      }
    }
    else
    {
      return;
    }
  }
  function f2(bytes25 i0,int176 i1) public     returns(uint128[] memory o0)  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
  }
  struct St1 {
    bytes10 el0;
    bool el1;
    string el2;
  }
}
struct St2 {
  uint48 el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
error er0(string ep0);
type T0 is bytes28;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



import "su0.sol";
error er1(St2 ep0);
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su0.sol:312-321): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:322-332): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:903-944): Statement has no effect.
// Warning 2072: (su0.sol:605-623): Unused local variable.
// Warning 5667: (su0.sol:1039-1049): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1050-1059): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1080-1099): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1109-1116): Unused local variable.
// Warning 2072: (su0.sol:1118-1133): Unused local variable.
