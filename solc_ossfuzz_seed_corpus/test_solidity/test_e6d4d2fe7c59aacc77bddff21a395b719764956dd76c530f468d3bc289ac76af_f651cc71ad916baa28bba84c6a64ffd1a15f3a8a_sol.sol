
==== Source: su0.sol ====
function f0()    
{
}
contract C0 {
  struct St0 {
    bytes23 el0;
    uint48 el1;
  }
  bool public constant cons0 = (((uint240((uint240((uint240((uint240(1766847064778384329583297500742918515827483896875618958121606201292619775) / uint240(0))) / uint240(0))) / uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) & uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) & uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) != uint240(1766847064778384329583297500742918515827483896875618958121606201292619775));
  modifier m0(bytes18 i0) 
  {
    assembly
    {
      i0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      if address()
      {
      }
    }
    assembly
    {
    }
    i0 ^= bytes18(0xb9d1cc6ba43afca3d65bae310dae829136b3);
    _;
  }
  C0.St0   s0 = C0.St0(bytes23(0xc312e54225cad533407560c09c72177d2bf5c30f25a1f5), uint48(0));
  uint256 immutable  s1;
  constructor(uint256 i0) payable  {
    s1 = uint256(68400635906722166758654000175853376908506952893970843416075100454600648451808);
    unchecked {
      delete s0.el1;
    }
  }
  modifier m1() virtual
  {
    string storage l0;
    _;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12
  }
  modifier m2(C0.EN0 i0) virtual
  {
    do
    {
      s0.el1 ^= ((((((uint48(281474976710655) | uint48(34597632493098)) % uint48(279671654551697)) & uint48(281474976710655)) * uint48(281474976710655)) ** uint256(uint256(74652148042227258348552396901291484854031900166131138460575095828146321770904))) & uint48(33640396620021));
      _;
    }
    while (false);
  }
  fallback() external   
  {
  }
  function f2() external   payable returns(bool o0)
  {
    assembly
    {
      o0 := o0
      stop()
    }
    try this.f2() returns (bool l0)
    {
    }
    catch
    {
    }
    catch Error(string memory l1)
    {
      (o0, s0.el0) = (true, s0.el0);
      try this.f2() returns (bool l2)
      {
        assert((!(cons0)));
      }
      catch
      {
      }
    }
    catch Panic(uint256 l3)
    {
      f0();
    }
    assembly
    {
      o0 := o0
    }
    for(    int120 l4 = int120(75474681037682276537158082640258815);
false;
int112(2596148429267413814265248164610047))
    {
      continue;
    }
    assembly
    {
    }
  }
  function f3(string calldata i0,address payable i1,int8 i2) private   
  {
  }
}
pragma solidity >= 0.0.0;
type T0 is int112;
int248 constant cons1 = ((int248(-125244482378160991821352490859294274273323179487228226038070203481810362255) * int248((((int248(0) ^ int248(176598219864841518363839783919770808884662709952628914753047493421450325718)) % int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) / int248(0)))) | int248(226156424291633194186662080095093570025917938800079226639565593765455331327));
// ====
// ----
