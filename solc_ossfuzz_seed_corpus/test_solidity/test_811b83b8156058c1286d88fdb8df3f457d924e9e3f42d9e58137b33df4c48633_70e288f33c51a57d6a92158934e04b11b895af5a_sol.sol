==== Source:  ====

==== Source: su0.sol ====
type T0 is bool;
struct St0 {
  T0 el0;
  mapping(bytes30 => uint72) el1;
  T0 el2;
  function (bytes15, bytes17, address) external   returns (function () external   returns (T0, string memory, int72), bytes memory) el3;
}
pragma solidity >= 0.0.0;
contract C0 {
  struct St1 {
    uint224 el0;
  }
  int240   s0 = int240(883423532389192164791648750371459257913741948437809479060803100646309887);
  function f0() private    returns(int256 o0,bytes22 o1)
  {
    if (false)
    {
      uint104 l0 = (uint104(20282409603651670423947251286015) + ((uint104((uint104(20282409603651670423947251286015) / uint104(20282409603651670423947251286015))) | uint104(7554883972157345098992569410042)) << uint184(uint184(24519928653854221733733552434404946937899825954937634815))));
    }
  }
  function f1(uint200 i0) external   payable returns(int144 o0,int80 o1)
  {
    for(    function (bytes17, uint128, T0) external   returns (uint184, bool, T0) l0;
;
C0.St1(uint224(0)))
    {
      continue;
    }
    assembly
    {
    }
    for(    address payable l1 = payable(address(this));
true;
((((((uint120(643162142855556737314688893397409218) - uint120(0)) >> uint152(uint152(5708990770823839524233143877797980545530986495))) << uint152(uint152(0))) | uint120(1329227995784915872903807060280344575)) | uint120(1329227995784915872903807060280344575)) * uint120(0)))
    {
      assembly
      {
        switch o0
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          switch mload(mod(s0, 2048))
          case 115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
          }
          case 71956388997466781552249164613035531198075887530211362018342230257687233501850
          {
            stop()
          }
        }
        case 16206543167065540842176005030195942049566601876916045577724508907262984880281
        {
          if gasprice()
          {
            stop()
          }
        }
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          stop()
        }
        for 
        {
        }
        0
        {
          {
            pop(l1)
          }
          for 
          {
            o1 := s0.offset
          }
          115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
            o0 := 42399668831965801243349363389936128382130982059125350466638857963282524904485
            switch s0.offset
            case 53558920492515502913548104109370993156374601229032549285606004757464144474043
            {
              if s0.slot
              {
              }
              o1 := sload(delegatecall(0, 103557366121571048943970665491209090482914781334501765253298232847845983298407, 32361895320220584883780788059878077260393081649270297294694380324316226644278, 0, 78694907770120872863490321609928084738436805124364866635328668342119538976406, 113222144769502435465259416600064893963406423877110177317116803767288542183615))
            }
          }
          {
            o1 := mload(mod(l1, 2048))
            let al0 := 51430319099542339404573736911213899195238704975567490104961637524075402964072
            stop()
            let al1 := 0
          }
        }
        {
          pop(0)
          continue
          o0 := s0
        }
        pop(s0.slot)
        function af0(ai0) -> ao0, ao1, ao2
        {
        }
      }
      unchecked {
      }
      (bool l2, bytes memory l3) = address(this).call("00000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
  }
}
// ----
// Warning 3149: (su0.sol:544-763): The result type of the shift operation is equal to the type of the first operand (uint104) ignoring the (larger) type of the second operand (uint184) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:1083-1236): The result type of the shift operation is equal to the type of the first operand (uint120) ignoring the (larger) type of the second operand (uint152) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// TypeError 1408: (su0.sol:1529-1531): Only local variables are supported. To access storage variables, use the ".slot" and ".offset" suffixes.
// DeclarationError 6792: (su0.sol:1990-2110): Duplicate case "115792089237316195423570985008687907853269984665640564039457584007913129639935" defined.
// TypeError 1408: (su0.sol:3337-3339): Only local variables are supported. To access storage variables, use the ".slot" and ".offset" suffixes.
