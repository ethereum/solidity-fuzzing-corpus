
==== Source: su0.sol ====
struct St0 {
  bytes1 el0;
}
pragma solidity >= 0.0.0;
contract C0 {
  struct St1 {
    bool el0;
  }
  error er0(int40 ep0, int112[10] ep1);
  event ev0(int88  ep0);
  fallback() external   
  {
  }
  C0.St1   s0;

	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}}
struct St2 {
  C0.St1 el0;
  uint248 el1;
}
contract C1 {
  function f1(address i0,function () external   returns (bytes13, uint80) i1) internal virtual     {
    if ((int32(2147483647) >= (((true ? int32(2147483647) : int32(0)) | int32(-1425877807)) | int32(605403558))))
    {
      return;
    }
  }
  bool   s1;
  St2   s2;

	function compareMemoryAndStorage(St2 memory v1, St2 storage v2) internal returns (bool) {

		if (!compareMemoryAndStorage(v1.el0, v2.el0))
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}
	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  C0.St1  public s3;

	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  constructor(bool i0)   {
    s1 = ((int200(uint200((((uint200(0) % uint200(1606938044258990275541962092341162602522202993782792835301375)) - uint200(1040810868060180257420106117662852025099340599517132882713202)) / uint200(1606938044258990275541962092341162602522202993782792835301375)))) >= int200(803469022129495137770981046170581301261101496891396417650687)) != false);
    unchecked {
    }
  }
  receive() external   payable
  {
    if (false)
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 523890569896656190}("");
      if (false)
      {
        bool  l2 = s1;
        bool  l3 = l2;
        assert(l3 == s1);
        (l0) = payable(this).send(14836098901989063647);
        if (s3.el0)
        {
          return;
        }
        else
        {
          if (true)
          {
          }
          if (((bytes4(0x00000000) & (bytes4(0xeebeec61) & bytes4(0x00000000))) > bytes4(0xffffffff)))
          {
            for(uint solinit0 = 0; solinit0 < ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * ((uint256(0) & (uint256(60020032478618871982619464630728181604295730798531196870257962387880510029767) - uint256(0))) + uint256(0))) % 11); solinit0++)
            {
            }
            s3.el0 = false;
            assert(s3.el0 == false);
          }
        }
      }
    }
  }
}

==== Source: su1.sol ====
function f3(int128 i0)    pure suffix returns(bool o0){
}
pragma solidity >= 0.0.0;
struct St3 {
  int256 el0;
  mapping(address => mapping(bool => int200[])) el1;
  int16 el2;
}
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
