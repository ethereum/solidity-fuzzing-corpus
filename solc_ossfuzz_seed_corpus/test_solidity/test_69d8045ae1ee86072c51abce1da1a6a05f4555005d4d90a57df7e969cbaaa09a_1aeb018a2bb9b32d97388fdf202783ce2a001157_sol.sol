==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
  }
  int152  public s0;
  bytes19 immutable  s1 = bytes19(0xfca67512216542d3782368f83d2a11ddc23049);
  constructor(int152 i0)   {
    s0 |= int152(0);
    {
      (s0) = (((int152(2854495385411919762116571938898990272765493247) + int152(0)) & int152((int152(1885296962571623173404075482918925397238613875) / int152(-2796957176003738657857938604781329545187714746)))));
    }
  }
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
  modifier m0() 
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 7753647781704886369}("");
    s0 ^= int152(1922863343798840552581290872103174091493120217);
    _;
    unchecked {
      for(;
(false || true);
)
      {
      }
      (bool l2, bytes memory l3) = payable(this).call{value: 11628873963579940738}("");
    }
  }
  error er0(bytes20 ep0, address payable ep1);
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112, M113, M114, M115, M116, M117, M118, M119,
    M120, M121, M122, M123, M124, M125, M126, M127,
    M128, M129, M130, M131, M132, M133, M134, M135,
    M136, M137, M138, M139, M140, M141, M142, M143,
    M144, M145, M146, M147, M148, M149, M150, M151,
    M152, M153, M154, M155, M156, M157, M158, M159,
    M160, M161, M162, M163, M164, M165, M166, M167,
    M168
  }
  fallback() external virtual  
  {
    return;
  }
}
bytes29 constant cons1 = (bytes29(((bytes9(0xffffffffffffffffff) | (bytes9(0xffffffffffffffffff) & bytes9(0xffffffffffffffffff))) ^ bytes9(0xffffffffffffffffff))) & bytes29(0x0000000000000000000000000000000000000000000000000000000000));
pragma solidity >= 0.0.0;
struct St0 {
  bytes13 el0;
  int48 el1;
  uint72 el2;
  bool el3;
}
library L0 {
  type T0 is uint96;
  bytes9 public constant cons2 = ((bytes9(0xffffffffffffffffff) ^ (bytes9(0xd9dfff93315c0f1d7c) & (bytes9(0x1125b07cbdb1c9d164) ^ bytes9(0x000000000000000000)))) | bytes9(0xda8786c488be382e8d));
  using L0 for *;
  enum EN1 {
    M0, M1, M2, M3
  }
  int16 public constant cons3 = int16(((((((int16(0) & int16(9454)) - int16(0)) * int16(0)) + int16(23238)) ** uint80(uint80(673011126545402031579956))) / int16(32767)));
  event ev0(L0.T0  ep0, C0.EN0  ep1, function () external   returns (C0.EN0, uint240, bool)  ep2);
}
// ----
// Warning 3149: (su0.sol:2611-2722): The result type of the exponentiation operation is equal to the type of the first operand (int16) ignoring the (larger) type of the second operand (uint80) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:165-174): Unused function parameter. Remove or comment out the variable name to silence this warning.
