
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  uint144   s0;
  constructor(uint144 i0)   {
    s0 <<= (((uint144(19407602656288254459670702715680350962293800) | ((uint144(302980977787706966555772500436043561852096) & uint144(22300745198530623141535718272648361505980415)) & uint144(15222505391758691522669658068894002906689921))) >> uint168(uint168(374144419156711147060143317175368453031918731001855))) - uint144(13441179893862919706086372013647727376548994));
    {
    }
  }
  function f0() public      {
    return;
  }
  function f1() public virtual  payable   {
  }
  function f2(uint144 i0,uint144 i1) private      {
    (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSelector(this.f1.selector));
    revert(string(bytes("85be2ad2e02795c920904f53e1befe1d4a2b37ffffffffffffffffffffff")));
  }
}
struct St0 {
  address payable el0;
  uint104 el1;
  int184[] el2;
  bytes el3;
}

==== Source: su1.sol ====
error er0();
pragma solidity >= 0.0.0;
struct St1 {
  bytes22 el0;
  int144 el1;
  bool el2;
}
// ====
// ----
