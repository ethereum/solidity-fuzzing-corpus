
==== Source: su0.sol ====
function f0()     {
}
contract C0 {
  bool public constant cons0 = true;
  uint72   s0;
  bool   s1;
  constructor(uint72 i0,bool i1) payable  {
    s0 |= ((uint8(47) ^ uint8(255)) % (true ? uint8(0) : uint8(0)));
    s1 = false;
    unchecked {
    }
  }
  function f1(uint72 i0,uint72 i1) internal      {
    return;
  }
}
pragma solidity >= 0.0.0;
error er0();

==== Source: su1.sol ====
contract C1 {
  int144  public s2 = int144(11150372599265311570767859136324180752990207);
  bytes4   s3;
  int176   s4 = int176(0);
  int120[]   s5;

	function compareMemoryAndStorage(int120[] memory v1, int120[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(bytes4 i0,int120[] memory i1)   {
    s3 &= bytes4(0xd31830ca);
    s5 = i1;
    unchecked {
    }
  }
  fallback() external   
  {
    (bool l0, bytes memory l1) = address(this).call(((int152(2854495385411919762116571938898990272765493247) == (int152(2854495385411919762116571938898990272765493247) | (int152(0) - int152(-2507430027402913982402944533863046679421371802)))) ? bytes("3895e15d38846a485aa6adf9381d48ee026ee66df61624a88aded40193d7fed0251bf18b26") : bytes("e3c236121e0f77be7c98c9ffe8bc0690e0489594edb6c4c9c81e260cb55f1e31360fc72f847d2f4a7eebb916069594161cf95f5a9ad9")));
  }
  type T0 is uint136;
  error er1(uint200 ep0);
}
pragma solidity >= 0.0.0;
type T1 is bytes17;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,

eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }




function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) | T1.unwrap(y)); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) & T1.unwrap(y)); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) ^ T1.unwrap(y)); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(~T1.unwrap(x)); }





function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



type T2 is bytes26;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,

eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }




function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) | T2.unwrap(y)); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) & T2.unwrap(y)); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) ^ T2.unwrap(y)); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(~T2.unwrap(x)); }





function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



// ====
// ----
