
==== Source: su0.sol ====
contract C0 {
  uint80   s0 = uint80(0);
  int48   s1;
  constructor(int48 i0)   {
    s1 *= ((int48(140737488355327) ** uint128((((uint128(0) % uint128(249664004572467146239119232389082024033)) + uint128(340282366920938463463374607431768211455)) + uint128(340282366920938463463374607431768211455)))) + int48(0));
    {
      uint80  l0 = s0;
      uint80  l1 = l0;
      assert(l1 == s0);
      delete s0;
      int48  l2 = s1;
      int48  l3 = l2;
      assert(l3 == s1);
      int48  l4 = s1;
      int48  l5 = l4;
      assert(l5 == s1);
      uint80  l6 = s0;
      uint80  l7 = l6;
      assert(l7 == s0);
      int48  l8 = s1;
      int48  l9 = l8;
      assert(l9 == s1);
      (bool l10, bytes memory l11) = address(this).call(bytes("834a401757391d21405348da73e57f6212dea411732bb800000000000000000000000000000000"));
      s0 >>= ((uint80(((uint80(((uint80(727468436004455321425614) % uint80(1208925819614629174706175)) / uint80(650517278764283400924363))) & uint80(393446377265025832620892)) / uint80(1208925819614629174706175))) << uint16(uint16(65535))) | uint80(1208925819614629174706175));
    }
  }
}
library L0 {
  function f0(function (address) external   returns (address, function () external   returns (bytes20[6] memory, address, bool), address payable) i0) internal   
  {
    bytes30[7][][2][6] memory l0 = [[new bytes30[7][](9), new bytes30[7][](9)], [new bytes30[7][](9), new bytes30[7][](9)], [new bytes30[7][](9), new bytes30[7][](9)], [new bytes30[7][](9), new bytes30[7][](9)], [new bytes30[7][](9), new bytes30[7][](9)], [new bytes30[7][](9), new bytes30[7][](9)]];
    int216 l1 = int216(37025132649814681710450393551784089797286033624529504191435345604);
    bytes10 l2 = bytes10(0xf26f6d75df25bf4f49e5);
  }
}
pragma solidity >= 0.0.0;
using L0 for function (address) external   returns (address, function () external   returns (bytes20[6] memory, address, bool), address payable);
library L1 {
  event ev0(address payable  ep0);
  error er0(bool ep0);
}
// ====
// ----
