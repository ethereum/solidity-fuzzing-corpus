
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    int56 l0 = (int56(31648622101287419) + int56(36028797018963967));
  }
  bytes4   s0;
  bytes3 immutable  s1 = bytes3(0xd95311);
  constructor(bytes4 i0)   {
    s0 ^= ((~((~(bytes4(0x0c7b7e0b))))) ^ (true ? bytes4(0xffffffff) : bytes4(0x00000000)));
    unchecked {
      {
        bytes4  l0 = s0;
        bytes4  l1 = l0;
        assert(l1 == s0);
      }
      {
      }
      { }
      (s0, s0) = ((bytes4(0x00000000) & bytes4(0x00000000)), bytes1((false ? (~(bytes7(0x00000000000000))) : bytes7(0xffffffffffffff))));
      assert(s0 == (bytes4(0x00000000) & bytes4(0x00000000)));
      assert(s0 == bytes1((false ? (~(bytes7(0x00000000000000))) : bytes7(0xffffffffffffff))));
    }
  }
  modifier m0() virtual
  {
    bytes3  l0 = s1;
    bytes3  l1 = l0;
    assert(l1 == s1);
    _;
    bytes4  l2 = s0;
    bytes4  l3 = l2;
    assert(l3 == s0);
    bytes3  l4 = s1;
    bytes3  l5 = l4;
    assert(l5 == s1);
    bytes3  l6 = s1;
    bytes3  l7 = l6;
    assert(l7 == s1);
  }
}
// ====
// ----
