==== Source:  ====

==== Source: su0.sol ====
library L0 {
  bytes5 public constant cons0 = bytes5(0x0000000000);
}
pragma solidity >= 0.0.0;
contract C0 {
  function f0(int24 i0) public   
  {
    (i0) = ((int24((((int24(0) ^ int24(2605997)) - int24(88597)) / int24(8388607))) ** uint32(uint32(4294967295))));
    assert(i0 == (int24((((int24(0) ^ int24(2605997)) - int24(88597)) / int24(8388607))) ** uint32(uint32(4294967295))));
    int64[][][] storage l0;
    (l0[l0.length], l0) = (l0[uint256((uint256(((int256(36980718595674233558526178685314501486875056264165157304143342017196436903307) % int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) - int256(45346065504768472073323106179484462196743821912173134614242169921028367827705))) / uint256(0)))], [new int64[][](5), new int64[][](5), new int64[][](5), new int64[][](5)]);
    unchecked {
      bytes21 l1 = bytes21(0x000000000000000000000000000000000000000000);
      bool l2 = true;
    }
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  address   s0 = address(this);
  uint16  public s1 = uint16(65535);
  uint56  public s2;
  int96   s3;
  constructor(uint56 i0,int96 i1)   {
    s2 ^= (((i0 &= ((((((uint56(72057594037927935) + uint56(29673304175746959)) & uint56(53425683613667371)) % uint56(72057594037927935)) + uint56(45712897312123804)) >> uint72(uint72(0))) | uint56(0))) ** uint216((((uint216(105312291668557186697918027683670432318895095400549111254310977535) | uint216(105312291668557186697918027683670432318895095400549111254310977535)) - uint216(43877339509146791605592368778368678401299219339184625333835383382)) * uint216(105312291668557186697918027683670432318895095400549111254310977535)))) | uint56(67950183105574366));
    s3 = ((((((int96(36101221525505384097934327114) % int96(39614081257132168796771975167)) % int96(0)) * int96(0)) + int96(-11690812283500934430597772619)) * int96(0)) ^ int96(39614081257132168796771975167));
    {
      address  l0 = s0;
      address  l1 = l0;
      assert(l1 == s0);
    }
  }
}

==== Source: su1.sol ====
struct St0 {
  uint104 el0;
  function () external   returns (bool) el1;
}
pragma solidity >= 0.0.0;
// ----
// Warning 3149: (su0.sol:161-261): The result type of the exponentiation operation is equal to the type of the first operand (int24) ignoring the (larger) type of the second operand (uint32) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:283-383): The result type of the exponentiation operation is equal to the type of the first operand (int24) ignoring the (larger) type of the second operand (uint32) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// TypeError 7407: (su0.sol:441-819): Type tuple(int64[][] storage ref,int64[][][4] memory) is not implicitly convertible to expected type tuple(int64[][] storage ref,int64[][][] storage pointer).
// Warning 3149: (su0.sol:1151-1668): The result type of the exponentiation operation is equal to the type of the first operand (uint56) ignoring the (larger) type of the second operand (uint216) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
