
==== Source: su0.sol ====
error er0(bool ep0);
function f0(int8 i0)     returns(bytes memory o0)
{
  revert er0(false);
  do
  {
    return (bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffa6"));
    return ("0000000000000000000000000000000000000000000000000003960b4417c4f4d5d32602bca3d0d1a7afa39f");
  }
  while ((true == (bytes30(0x000000000000000000000000000000000000000000000000000000000000) > bytes30(0x5036adfe54f41bba9368cb5b3554297722d48390886a1f987dcba88404eb))));
}
pragma solidity >= 0.0.0;
struct St0 {
  int240 el0;
  uint8 el1;
  int8 el2;
  address payable el3;
}
contract C0 {
  bool[]   s0;
  St0   s1;
  constructor(bool[] memory i0) payable  {
    s0 = i0;
    unchecked {
      St0 memory l0 = St0(int240(-281975946091720627799916119900559781208119325725629669370356048921358499), uint8(85), int8(0), payable(address(0x0000000000000000000000000000000000000006)));
      string[1] memory l1 = ["e40c09bec95c04000000000000000000000000000000"];
    }
  }
  struct St1 {
    mapping(bytes11 => uint176)[2] el0;
    int200 el1;
    mapping(address => bytes9) el2;
    bool el3;
  }
  event ev0();
  type T0 is uint144;
  error er1(int32 ep0);
  error er2();
  C0.T0 public constant cons0 = C0.T0.wrap(uint144(22300745198530623141535718272648361505980415));
  event ev1();
}
library L0 {
  using L0 for *;
  error er3();
  event ev2();
  error er4();
  modifier m0() 
  {
    _;
  }
}
// ====
// ----
