==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() external virtual  
  {
    function (function (bytes32, int24[][][9][][1][] memory, bytes memory) external   returns (uint88, int256), int168, uint88[] memory) external   returns (address payable) l0;
  }
  fallback() external   
  {
    bytes19[2][][][8][6][] memory l0 = ((payable(address(this)) <= payable(address(this))) ? new bytes19[2][][][8][6][](10) : new bytes19[2][][][8][6][](10));
    (l0[(uint256(0) * (((uint256(50578152189720777806494303091702016256197269556746716492085709127205315898674) ** uint56(uint56(0))) * uint256(0)) - uint256(0)))]) = (l0[(uint256(0) << uint224((((uint224(0) & uint224(0)) | uint224(0)) >> uint160(uint160(252430310968433341014824065416448241834861357570)))))]);
  }
  uint232   s0 = uint232(0);
  int72[][]  public s1 = [[int72(0), int72(-582556809830217520931)], [int72(2361183241434822606847), int72(0)], [int72(0), int72(1247243207993861762327)], [int72(0), int72(0)], [int72(2361183241434822606847), int72(2361183241434822606847)], [int72(2361183241434822606847), int72(1719422423883755382445)], [int72(2361183241434822606847), int72(2361183241434822606847)]];

	function compareMemoryAndStorage(int72[][] memory v1, int72[][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int72[] memory v1, int72[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
}
// ----
// Warning 2072: (su0.sol:83-255): Unused local variable.
// Warning 2018: (su0.sol:1441-1685): Function state mutability can be restricted to view
