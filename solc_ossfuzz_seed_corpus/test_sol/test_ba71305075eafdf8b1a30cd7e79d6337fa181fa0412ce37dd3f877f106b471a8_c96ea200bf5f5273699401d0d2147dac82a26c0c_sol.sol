==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  fallback() external virtual  
  {
    address(this);
    for(;
false;
bytes3(0x584c05))
    {
    }
    assembly
    {
      {
        codecopy(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), 0, mod(0, 1024))
      }
    }
  }
  function f2(function (int144, bool, uint72) external   returns (bytes27, bool, int152) i0) public   
  {
    unchecked {
      try i0(int144(0),(true == (address(this) > (true ? address(this) : address(this)))),((~(uint72(4722366482869645213695))) & ((uint72(0) * uint72(4722366482869645213695)) * uint72(143018962014381428409)))) returns (bytes27 l0, bool l1, int152 l2)
      {
        bytes storage l3;
      }
      catch
      {
      }
      bool[7] storage l4;
      (bool l5, bytes memory l6) = payable(this).call{value: 0}("");
      int168 l7 = (((int168((int168(187072209578355573530071658587684226515959365500927) / int168(95961674084859640253402502034252714064752673641666))) + int168(187072209578355573530071658587684226515959365500927)) & int168(0)) % int168(112164310142193798400057941788486065031402515587398));
      {
        address l8 = address(this);
        l4[(uint256(0) * uint256((uint256(0) / (uint256(0) + uint256(0)))))] = true;
        assert(l4[(uint256(0) * uint256((uint256(0) / (uint256(0) + uint256(0)))))] == true);
        for(;
(payable(address(bytes20(address(0x6EAAb32a1A6A9629016E3558C1F4BbD9A9F334AB)))) < payable(address(this)));
true)
        {
          uint248 l9 = uint184(24519928653854221733733552434404946937899825954937634815);
          (l7, l4[(uint256(61413412394490672741063807410851378289579785261909613145953962707445296185014) ^ ((uint224(26959946667150639794667015087019630673637144422540572481103610249215) ^ uint256(58906666689425144198468995477099418057310076962559219002809288374300959494316)) << uint88(uint88(0))))]) = ((int168(73968837968410293925400192686463114719033489268968) & int168(0)), l4[((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(90263588706926403079331951102608599977948987028104084134912179486760624071729)) | (uint256(0) << uint56(uint56(0))))]);
          assert(l7 == (int168(73968837968410293925400192686463114719033489268968) & int168(0)));
          assert(l4[(uint256(61413412394490672741063807410851378289579785261909613145953962707445296185014) ^ ((uint224(26959946667150639794667015087019630673637144422540572481103610249215) ^ uint256(58906666689425144198468995477099418057310076962559219002809288374300959494316)) << uint88(uint88(0))))] == l4[((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(90263588706926403079331951102608599977948987028104084134912179486760624071729)) | (uint256(0) << uint56(uint56(0))))]);
          int200 l10 = int200(0);
        }
        {
          delete l7;
          l5 = true;
          assert(l5 == true);
          function (string memory) external   returns (int184, bytes memory, bytes2) l11;
          address(this);
        }
      }
    }
    bool l12 = (address(this) != address(this));
  }
  uint72   s0 = uint72(2145084702518559660386);
  uint32   s1;
  constructor(uint32 i0) payable  {
    s1 *= (~(uint32((uint32((uint32(4294967295) / uint32(3780117080))) / (uint32(4294967295) - uint32(1419300568))))));
    unchecked {
      uint72  l0 = s0;
      uint72  l1 = l0;
      assert(l1 == s0);
    }
  }
}
// ----
// TypeError 3464: (su0.sol:1252-1254): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1344-1346): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1665-1667): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2030-2032): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2368-2370): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2658-2660): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
