==== Source:  ====

==== Source: su0.sol ====
bytes29 constant cons0 = (((((bytes2(0x3bc8) | bytes2(0xcb8e)) ^ bytes2(0x5c6f)) < bytes2(0x62fe)) == true) ? bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) : bytes29(0x0000000000000000000000000000000000000000000000000000000000));
library L0 {
  function f0() public    returns(bool o0,bytes11[] memory o1)
  {
    for(;
;
uint120(134245352103180117593470324410740050))
    {
      continue;
    }
    (o1[0], o1[0]) = (bytes11(0x0000000000000000000000), bytes11(0x0000000000000000000000));
  }
  function f1(uint56 i0) external    returns(bytes5 o0,int96 o1,address o2)
  {
    bool l0 = true;
    (o1) = ((int96(0) * int96(20397686500426818360394315374)));
  }
  modifier m0(function (string memory, function () external   returns (address payable, bool)) internal   returns (bytes memory, bytes18) i0,function () internal   returns (uint144) i1) 
  {
    _;
  }
  int248 public constant cons1 = int248(226156424291633194186662080095093570025917938800079226639565593765455331327);
  event ev0(bool  ep0);
  error er0();
  modifier m1() 
  {
    _;
    do
    {
      break;
    }
    while (false);
  }
  int240 public constant cons2 = ((((((int240(0) ** uint176(uint176(0))) % int240(0)) - int240(883423532389192164791648750371459257913741948437809479060803100646309887)) + int240(883423532389192164791648750371459257913741948437809479060803100646309887)) | int240(883423532389192164791648750371459257913741948437809479060803100646309887)) % int240(0));
  modifier m2(function () external   returns (bytes10, int160, int112) i0) 
  {
    _;
    try i0() returns (bytes10 l0, int160 l1, int112 l2)
    {
    }
    catch
    {
    }
    catch Panic(uint256 l3)
    {
      _;
      assembly
      {
        l3 := cons1
      }
    }
  }
}
pragma solidity >= 0.0.0;
using L0 for uint;
// ----
// TypeError 7615: (su0.sol:1737-1742): Only direct number constants and references to such constants are supported by inline assembly.
