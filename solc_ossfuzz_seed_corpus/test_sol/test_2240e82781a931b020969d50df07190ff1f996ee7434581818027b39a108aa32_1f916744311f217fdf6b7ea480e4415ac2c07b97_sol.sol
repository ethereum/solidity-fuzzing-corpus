==== Source:  ====

==== Source: su0.sol ====
library L0 {
  event ev0(function (int128, uint24) external    ep0, address payable  ep1, int120 indexed ep2);
  function f0(function (uint8) external   returns (string memory, uint216) i0,address i1) public   
  {
    uint128 l0 = (true ? uint128(340282366920938463463374607431768211455) : uint128(236569072189886965613688653899072419411));
  }
  modifier m0() 
  {
    _;
    function () external   returns (int40, bool) l0;
    int152 l1 = (((~(int152(1664879613919596908937264923303111467359780773))) - (-((~(int152(0)))))) * int152(-251521144619551205418068132756159790757507923));
  }
}
contract C0 {
  using L0 for *;
  using L0 for *;
  using L0 for *;
  using L0 for *;
  using L0 for *;
  bytes10  public s0 = bytes10(0xffffffffffffffffffff);
  fallback() external virtual  payable
  {
    bytes10  l0 = s0;
    bytes10  l1 = l0;
    assert(l1 == s0);
    (s0, s0) = ((~((bytes10((~(bytes28(0x00000000000000000000000000000000000000000000000000000000)))) ^ bytes10(0x228c576321f81e4b7ea5)))), (bytes10(0xffffffffffffffffffff) & ((~(bytes10(0xd93e83d508892043cb37))) | bytes10(0xffffffffffffffffffff))));
    assert(s0 == (~((bytes10((~(bytes28(0x00000000000000000000000000000000000000000000000000000000)))) ^ bytes10(0x228c576321f81e4b7ea5)))));
    assert(s0 == (bytes10(0xffffffffffffffffffff) & ((~(bytes10(0xd93e83d508892043cb37))) | bytes10(0xffffffffffffffffffff))));
  }
}
contract C1 {
  int64   s1;
  uint240  public s2;
  constructor(int64 i0,uint240 i1) payable  {
    s1 -= int64((((int64(0) ^ int64(int240(0))) | int64(0)) / int64(0)));
    s2 %= uint240(0);
    unchecked {
      uint240  l0 = s2;
      uint240  l1 = l0;
      assert(l1 == s2);
      uint240  l2 = s2;
      uint240  l3 = l2;
      assert(l3 == s2);
      uint240  l4 = s2;
      uint240  l5 = l4;
      assert(l5 == s2);
      int64  l6 = s1;
      int64  l7 = l6;
      assert(l7 == s1);
      uint240  l8 = s2;
      uint240  l9 = l8;
      assert(l9 == s2);
      int64  l10 = s1;
      int64  l11 = l10;
      assert(l11 == s1);
    }
  }
  using L0 for *;
  using L0 for *;
  fallback() external   
  {
    uint240  l0 = s2;
    uint240  l1 = l0;
    assert(l1 == s2);
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:593-1388): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su0.sol:125-188): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:189-199): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:219-229): Unused local variable.
// Warning 5667: (su0.sol:1453-1461): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1462-1472): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:113-345): Function state mutability can be restricted to pure
