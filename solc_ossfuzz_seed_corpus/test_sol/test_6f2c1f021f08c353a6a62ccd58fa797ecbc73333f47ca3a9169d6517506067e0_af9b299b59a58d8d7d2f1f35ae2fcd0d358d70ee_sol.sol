
==== Source: su0.sol ====
library L0 {
  modifier m0() 
  {
    unchecked {
      for(      address(0x0000000000000000000000000000000000000008);
true;
)
      {
        do
        {
          function (bytes19[7][] memory, bool) external   l0;
        }
        while (true);
        int192 l1 = (true ? ((~(int192(-2637399499094647503859014877856103725272634391230766403183))) ** uint8((~(uint8(181))))) : int192(0));
      }
      int216 l2 = int216(0);
      int88[][] memory l3 = new int88[][](7);
    }
    address(0x0000000000000000000000000000000000000002);
    address l4 = ((false ? false : false) ? address(0x0000000000000000000000000000000000000005) : address(0x0000000000000000000000000000000000000007));
    _;
  }
  function f0(address payable i0,int168 i1,bool i2) external   
  {
    assembly
    {
      {
        switch i0
        case 53296730209927259245917822160490518142868832207331348732465583667769945406718
        {
          pop(i1)
          extcodecopy(115792089237316195423570985008687907853269984665640564039457584007913129639935, add(0x80, mod(i1, 1024)), i1, mod(0, 1024))
        }
        case 0
        {
        }
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(i0, 11)) { yulinit0 := add(yulinit0, 1) }
        {
        }
      }
      if i0
      {
        function af0(ai0, ai1, ai2, ai3, ai4, ai5, ai6, ai7, ai8) -> ao0, ao1, ao2, ao3
        {
          switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
          case 0
          {
            let al0, al1, al2, al3 := af0(mload(add(0x80, mod(ai4, 2048))), 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 56646563073190301640394076611967811081680649883093446093224785425500875601725, 0, 0, 2386436866569371568828129114859871914701857336353725243190544410440123723586, 56280020649717361095577403460257380191699740815855721346038857094184629381180, 97993610632004050577090516844337908150988990078620501486905032536008320158234)
          }
        }
      }
      for 
      {
        i0 := mload(add(0x80, mod(i1, 1024)))
        {
          let al4 := sload(i1)
        }
        for 
        {
        }
        75071720489561519409390814314306834456691591833669227479649251078992177781882
        {
        }
        {
          i1 := mload(add(0x80, mod(i1, 1024)))
        }
      }
      iszero(i2)
      {
      }
      {
      }
      return(add(0x80, mod(i1, 1024)), i2)
    }
  }
  event ev0();
}
pragma solidity >= 0.0.0;
using L0 for address payable;
using L0 for address payable;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bytes20 el0;
  function (uint64, address) external   el1;
  uint80[8] el2;
}
// ====
// ----
