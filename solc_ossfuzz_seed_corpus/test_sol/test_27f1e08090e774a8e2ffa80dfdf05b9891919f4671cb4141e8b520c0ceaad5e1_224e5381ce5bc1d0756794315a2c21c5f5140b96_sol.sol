
==== Source: su0.sol ====
library L0 {
  event ev0();
}
contract C0 {
  fallback() external virtual  
  {
    string storage l0;
  }
  uint136   s0 = uint136(69461459357418880243244140580051064845816);
  uint64 immutable  s1 = uint64(0);
  int232   s2;
  bool  public s3 = true;
  constructor(int232 i0)   {
    s2 %= (int232(0) | (-(int232(3450873173395281893717377931138512726225554486085193277581262111899647))));
    unchecked {
      while (((int120(664613997892457936451903530140172287) | int120(0)) < ((-(int120(664613997892457936451903530140172287))) % int120(664613997892457936451903530140172287))))
      {
        bytes22 l0 = bytes22(0x00000000000000000000000000000000000000000000);
      }
      payable(this).transfer(0);
      int232  l1 = s2;
      int232  l2 = l1;
      assert(l2 == s2);
      {
        (bool l3) = payable(this).send(14103461808445669191);
        bool  l4 = s3;
        bool  l5 = l4;
        assert(l5 == s3);
        int232  l6 = s2;
        int232  l7 = l6;
        assert(l7 == s2);
        uint64  l8 = s1;
        uint64  l9 = l8;
        assert(l9 == s1);
      }
    }
  }
  receive() external   payable
  {
    bool  l0 = s3;
    bool  l1 = l0;
    assert(l1 == s3);
  }
  using L0 for *;
  using L0 for *;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  string el0;
  uint192[4][6][][] el1;
  string el2;
  uint208 el3;
}
contract C1 {
  bool   s4;
  address   s5 = address(this);
  uint256   s6;
  constructor(bool i0,uint256 i1)   {
    s4 = ((((((true ? uint8(234) : uint8(255)) ^ uint8(0)) + uint8(0)) % uint8(135)) >> uint64(uint64(12669039692975424125))) != uint8(0));
    s6 += uint256(0);
    unchecked {
      {
        uint256  l0 = s6;
        uint256  l1 = l0;
        assert(l1 == s6);
        bool  l2 = s4;
        bool  l3 = l2;
        assert(l3 == s4);
      }
    }
  }
}
library L1 {
  error er0();
}
pragma solidity >= 0.0.0;
// ====
// ----
