
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
bool constant cons0 = true;
struct St0 {
  bytes28 el0;
}

==== Source: su1.sol ====
contract C0 {
  int120  public s0;
  bytes9   s1;
  constructor(int120 i0,bytes9 i1)   {
    s0 |= int120(664613997892457936451903530140172287);
    s1 &= bytes9(0x000000000000000000);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call((false ? bytes("00000000000000000000000000000000000000000000000000000076f982a3cc48e56c903469ad467a2dcd68f4cb28ba6fe8e13529c6") : bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000")));
    }
  }
  function f0(bytes9 i0) external   payable  returns(function () external   returns (bytes memory, bytes memory, function (bool, bytes23) external  ) o0)  {
    while (true)
    {
      break;
    }
    delete s0;
  }
  event ev0(function () external   indexed ep0, int240 indexed ep1);
  error er0();
}
pragma solidity >= 0.0.0;
contract C1 {
  bytes32   s2 = bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  C0   s3 = C0(address(this));
  address payable  public s4 = payable(address(this));
  bytes17 immutable  s5 = bytes17(0x0000000000000000000000000000000000);
  receive() external virtual  payable
  {
    assert(false);
  }
  type T0 is bool;
  error er1(bool ep0, int256 ep1);
  struct St1 {
    mapping(bytes18 => int112)[] el0;
    int136 el1;
  }
}
// ====
// ----
