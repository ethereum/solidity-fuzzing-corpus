
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is uint96;
  fallback() external virtual  
  {
    return;
  }
  event ev0(int8  ep0);
  receive() external   payable
  {
    if (false)
    {
    }
    else if (true)
    {
      while (true)
      {
        return;
      }
    }
  }
  bytes6   s0;
  constructor(bytes6 i0)   {
    s0 ^= bytes6(0x55148b84c699);
    unchecked {
    }
  }
}
contract C1 is C0 {
  mapping(address => int88)   s1;
  address payable immutable public s2;
  C0 immutable public s3 = C0(payable(address(this)));
  constructor(bytes6 i0,address payable i1)  C0(bytes6(0x000000000000))
  {
    s0 &= bytes6(0xffffffffffff);
    s2 = payable(address(this));
    s1[address(this)] /= int88(0);
    {
    }
  }
  type T1 is int80;
  fallback() external override  
  {
    if (true)
    {
      delete s0;
      emit ev0(((int8(127) * (int8(0) % (~(int8(0))))) % int8(63)));
    }
    emit ev0(((int8(42) & (true ? (int8(0) ^ int8(127)) : int8(0))) ** uint112(uint112(2439459423853126502468946609166252))));
  }
}
error er0();
error er1(bool ep0);

==== Source: su1.sol ====
type T2 is address payable;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,

eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }





function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(payable(address(bytes20(address(T2.unwrap(x))) | bytes20(address(T2.unwrap(y)))))); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(payable(address(bytes20(address(T2.unwrap(x))) & bytes20(address(T2.unwrap(y)))))); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(payable(address(bytes20(address(T2.unwrap(x))) ^ bytes20(address(T2.unwrap(y)))))); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(payable(address(~bytes20(address(T2.unwrap(x)))))); }






function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



pragma solidity >= 0.0.0;
// ====
// ----
