
==== Source: su0.sol ====
contract C0 {
  address[7]  public s0;

	function compareMemoryAndStorage(address[7] memory v1, address[7] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  address payable immutable public s1 = payable(address(this));
  bool   s2;
  uint8   s3 = uint8(255);
  constructor(address[7] memory i0,bool i1)   {
    s0 = i0;
    s2 = true;
    {
      for(      bytes1 l0 = (~(bytes1(0x00)));
(i1 = true);
)
      {
        for(        ((uint8(((uint8(249) | (uint8(0) - uint8(255))) / uint8(0))) * uint8(255)) ^ uint8(0));
(payable(address((bytes20(address(0x0000000000000000000000000000000000000000)) ^ bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))))) == payable(address(this)));
)
        {
        }
        delete s0[(uint256(0) ** uint8(((uint8(0) * (uint8(0) | uint8(0))) + uint8(255))))];
      }
    }
  }
  struct St0 {
    address el0;
    uint40 el1;
    bytes8 el2;
    address payable el3;
  }
  function f0() public virtual    returns(bool o0,bytes5 o1)  {
    o1 &= bytes5(0x82ce8dc3f6);
      assert(i1 == true);
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f1(bytes memory i0)    pure suffix returns(int216 o0){
  if (i0.length < (uint256(50856686994473130715552872159529827514349101079075850479098312953032669143693) + (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) + ((uint256(100717915212590465742302918466307652360931555507108690604900176969176573897544) ^ uint256(0)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))))
  {
    int200 l0 = (int56(36028797018963967) | int200(803469022129495137770981046170581301261101496891396417650687));
    if (i0.length <= uint192(6277101735386680763835789423207666416102355444464034512895))
    {
      o0 = int216(((true ? (int216(-36063574805307289388597033079881116284043933388300368244332282449) | (int216(0) * int216(52656145834278593348959013841835216159447547700274555627155488767))) : int216(0)) / int216(16169328498875408259222694282764434957001560969764868442624703878)));
      assert(o0 == int216(((true ? (int216(-36063574805307289388597033079881116284043933388300368244332282449) | (int216(0) * int216(52656145834278593348959013841835216159447547700274555627155488767))) : int216(0)) / int216(16169328498875408259222694282764434957001560969764868442624703878))));
    }
  }
  else if (i0.length != uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))
  {
    (o0) = (int216(7644560514595308649361053634461043286576207904540790123619233205));
    assert(o0 == int216(7644560514595308649361053634461043286576207904540790123619233205));
    o0 ^= int216(0);
  }
  assert(false);
  o0 *= ((((int216(0) | int216(-37714844814878687007528748498910241379754066399689776219230001426)) & int216(0)) * int216(52656145834278593348959013841835216159447547700274555627155488767)) ^ int216(52656145834278593348959013841835216159447547700274555627155488767));
}
error er0(bool ep0, bool ep1);
// ====
// ----
