==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
    require((false ? (address(this) < address(bytes20(address(0x88CbA02A6be0DB09190e4Edd6581fE0f6f1546D1)))) : true), string("781bc3dba7cb141400000000000000000000000000000000000000"));
    assembly
    {
      returndatacopy(add(0x80, mod(sub(number(), 0), 1024)), 0, mod(sload(or(0, 0)), 1024))
      switch 0
      case 92291856629405621229008696652666210486578898374801256445427470996430940252132
      {
        function af0(ai0) -> ao0, ao1, ao2, ao3
        {
          returndatacopy(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), ai0, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024))
          let al0 := 69133491277645088754479194851261138803084209767619431564807292761964195471369
          let al1, al2, al3, al4 := af0(0)
        }
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        for 
        {
        }
        calldataload(mod(44268299369775809972979181863734086378434658736257985036252585484979513743609, calldatasize()))
        {
        }
        {
        }
      }
      case 31222576838711730013204894770335321505457112317226731480340604729955944030966
      {
        extcodecopy(mload(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 2048))), add(0x80, mod(42041111545595510754971513700301039659909999172104704115320541128893871823367, 1024)), shr(call(0, 0, 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 79852917260639250580295512893240266294351460507060303283488942557877403522772), 0), mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024))
      }
      codecopy(add(0x80, mod(52255071166555211149063342619776900710170583628398006624956076016445182550298, 1024)), 115792089237316195423570985008687907853269984665640564039457584007913129639935, mod(33849562438767509220514260856114346539248247498894860234562757032121921364204, 1024))
    }
    int128 l0 = ((((false ? false : false) ? int128(136505002814841448735023890125775483814) : int128(0)) | int128(-649130256562540251924001258494903446)) + int128(170141183460469231731687303715884105727));
  }
  address   s0 = address(this);
  mapping(address => bytes21)   s1;
  bool   s2;
  constructor(bool i0)   {
    s2 = (bytes10(0x58bfeabe3e423bcf6ef4) >= (~(bytes1(0x5a))));
    s1[(true ? address(this) : (false ? address(this) : address(this)))] ^= bytes21(0xffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  function f1(address i0) internal   
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
    unchecked {
      for(;
;
)
      {
        assembly
        {
        }
      }
      address  l2 = s0;
      address  l3 = l2;
      assert(l3 == s0);
      bool  l4 = s2;
      bool  l5 = l4;
      assert(l5 == s2);
    }
  }
}
error er0();

==== Source: su1.sol ====
uint152 constant cons0 = 0;
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:2288-2297): Unused local variable.
// Warning 5667: (su0.sol:2590-2597): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2839-2849): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:2827-3159): Function state mutability can be restricted to view
