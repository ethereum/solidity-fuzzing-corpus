
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  
  {
    assembly
    {
      {
      }
      return(mload(add(0x80, mod(0, 2048))), create(0, 17192537615049364544559080476030628998727184353437580770378946564905202827490, 101944578449243542356200885358499693119019457080678918018227117756945278487153))
    }
    uint240 l0 = (uint240(1765379056851975520780870981481368748286626912777017970114029554537757451) ^ uint240(1766847064778384329583297500742918515827483896875618958121606201292619775));
  }
  receive() external virtual  payable
  {
  }
  modifier m0() 
  {
    assembly
    {
      switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
      case 67622754156747081413976608966785518223651921783994357102236100861008763337359
      {
        let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      }
    }
    bytes19 l0 = (~(bytes19(bytes("24f8574eb09cbff946e9b017fe4e4f5151ecd25e1431c72c8744d12d2d87c86288151f745ed74df53fe9400bd79000b0fa18f138"))));
    _;
  }
  int152[6]   s0 = [int152(0), int152(0), int152(2854495385411919762116571938898990272765493247), int152(0), int152(0), int152(2854495385411919762116571938898990272765493247)];

	function compareMemoryAndStorage(int152[6] memory v1, int152[6] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
}
// ====
// ----
