
==== Source: su0.sol ====
library L0 {
  function f0() public    returns(bytes12[1][][] memory o0,int104 o1,bytes29 o2)
  {
    o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] = new bytes12[1][](9);
  }
  event ev0(bool  ep0, int192  ep1, bool  ep2, uint232  ep3);
}
contract C0 {
  using L0 for *;
  function f1() public   payable
  {
    emit L0.ev0((uint184(0) >= ((((uint184(6699808009403927120442760710512048939248068925875474044) - uint184(4515813078260833099479007573454384055583017708565174736)) & uint184(0)) * uint184(19612564782416690734361390841873501204932586887859375931)) + uint184(0))), int192(0), true, uint232(323307818119907075892301768857610587534401320967633385718271561503587));
    (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000000000000000000000000000000000000000000000000000ffffffffffff"));
    address payable l2 = payable(address(this));
  }
  address payable   s0 = payable(address(this));
  bool   s1 = false;
  uint104   s2;
  address   s3 = address(this);
  constructor(uint104 i0)   {
    s2 &= uint104(20282409603651670423947251286015);
    unchecked {
      address payable  l0 = s0;
      address payable  l1 = l0;
      assert(l1 == s0);
      uint104  l2 = s2;
      uint104  l3 = l2;
      assert(l3 == s2);
      address  l4 = s3;
      address  l5 = l4;
      assert(l5 == s3);
      address  l6 = s3;
      address  l7 = l6;
      assert(l7 == s3);
    }
  }
  using L0 for *;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  uint8[] el0;
  address payable el1;
  uint24[] el2;
  bool el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
