==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  uint8 el0;
  mapping(bool => bytes21) el1;
  function () external   returns (address, address) el2;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81
}
library L0 {
  modifier m0(int104 i0,uint80 i1) 
  {
    while ((((true && ((!(false)) && false)) || true) && true))
    {
      _;
      break;
    }
    _;
    for(;
true;
EN0.M17)
    {
      (i1) = ((~(((uint80(1208925819614629174706175) & ((uint80(0) | uint80(892228616605695978684485)) ^ uint80(1208925819614629174706175))) & uint80(0)))));
      if ((bytes9(0xffffffffffffffffff) >= bytes9(0xffffffffffffffffff)))
      {
      }
      else if (true)
      {
        continue;
      }
      else if (false)
      {
        _;
        delete i1;
      }
      if (false)
      {
      }
      else if (true)
      {
        assembly
        {
          let al0 := sdiv(not(31630928883172926233969253386738231544300440056453945581174071315347516734379), 0)
          switch 0
          case 97684776906557137308560008403192848111163574109551924061261528686974043779823
          {
          }
          case 0
          {
            if 0
            {
            }
            switch al0
            default
            {
            }
          }
        }
        _;
        if (true)
        {
        }
        else if ((bytes3(0x000000) <= bytes3(0xffffff)))
        {
          _;
          continue;
        }
        else
        {
        }
        break;
      }
    }
    _;
  }
  modifier m1() 
  {
    assembly
    {
      switch 75345121907542540058881746531499788739398817550317399306277495421648853517063
      default
      {
        for 
        {
        }
        115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
          case 67880201431414589767411012240326991740074756351042265515103195027861616923355
          {
            switch byte(0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
            case 0
            {
            }
            return(115792089237316195423570985008687907853269984665640564039457584007913129639935, 74019033623886048893374194392594937664424878418920966660476437857017713290792)
          }
        }
        {
          switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
          default
          {
          }
          break
          continue
          let al1 := 0
          al1 := 8366099726980840923234218518795137092420754526346305128854747250105590346951
        }
      }
      stop()
    }
    uint120 l0 = ((((((uint120(1329227995784915872903807060280344575) * uint120(1329227995784915872903807060280344575)) ^ uint120(0)) << uint24(uint24(16777215))) & uint120(0)) ** uint216(uint216(14529939673472056433778169187377419837284171166006797368398584129))) >> uint152(uint152(4048683098675868626625701151536175374613471912)));
    _;
  }
  address public constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
  using L0 for *;
  modifier m2() 
  {
    _;
  }
}
pragma solidity >= 0.0.0;
bytes8 constant cons1 = bytes8(0x0000000000000000);
// ----
// Warning 9592: (su0.sol:1535-1593): "switch" statement with only a default case.
// Warning 9592: (su0.sol:1894-3003): "switch" statement with only a default case.
// Warning 9592: (su0.sol:2706-2833): "switch" statement with only a default case.
// Warning 3149: (su0.sol:3042-3286): The result type of the exponentiation operation is equal to the type of the first operand (uint120) ignoring the (larger) type of the second operand (uint216) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 6133: (su0.sol:725-732): Statement has no effect.
