
==== Source: su0.sol ====
contract C0 {
  event ev0(bool  ep0);
  function f0(bool i0) public virtual  payable  returns(address o0,function (string memory, bool, uint80[10] memory) external   returns (int160, bool, int40)[] memory o1)  {
    o0 = address(this);
    assert(o0 == address(this));
    (o1) = (new function (string memory, bool, uint80[10] memory) external   returns (int160, bool, int40)[](5));
    delete o1[(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) & ((uint256(66931261609221921533906765924200315054978057043565241253131796887732617387295) + (uint256(6436701164733809532530165023520195603213476709458023187182639953186697480788) ^ uint256(23818386364918914056453091396188014132983007417262221235825835927772304043168))) >> uint32(uint32(0))))];
  }
  struct St0 {
    uint224 el0;
  }
  receive() external   payable
  {
    if (false)
    {
      emit ev0((uint48(63890431589807) == ((uint48(uint80(0)) - uint48(43422607874102)) % uint48(72295928822834))));
      (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
      emit ev0(true);
      return;
    }
  }
  bool   s0 = true;
  C0.St0  public s1;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  C0.St0   s2;
  bytes25[4]   s3;

	function compareMemoryAndStorage(bytes25[4] memory v1, bytes25[4] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(bytes25[4] memory i0) payable  {
    s3 = i0;
    unchecked {
      (s1.el0, s3[type(uint256).max], s3) = (uint224(uint232(6686664799661769954395252574727362422069493894780123944596609355603129)), s3[(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(0)) + uint256(0)) % uint256(67009652019101384597652734135312119637455438253418363502868402081216377943783))], [bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff), bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff), bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff), bytes25(0x00000000000000000000000000000000000000000000000000)]);
      assert(s1.el0 == uint224(uint232(6686664799661769954395252574727362422069493894780123944596609355603129)));
      assert(s3[type(uint256).max] == s3[(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(0)) + uint256(0)) % uint256(67009652019101384597652734135312119637455438253418363502868402081216377943783))]);
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16
}
// ====
// ----
