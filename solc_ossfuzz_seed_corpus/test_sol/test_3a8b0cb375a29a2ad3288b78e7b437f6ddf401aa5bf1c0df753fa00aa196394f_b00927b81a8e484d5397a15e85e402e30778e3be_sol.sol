
==== Source: su0.sol ====
struct St0 {
  bool el0;
  address el1;
}
contract C0 {
  receive() external virtual  payable
  {
    bool l0 = (int256((int256(-5297682836605786771958389710402838541641830301932667421497906065222772093245) / (~(((-(int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) - int256(-43117834295948770966439681084976776368613091200377182777825354629689278483172)))))) > int256(6913727765718111404353877480051149264036156030517429974646982838046714204199));
  }
  fallback() external   
  {
    assembly
    {
      stop()
    }
    function (bool, uint96, int248) external   returns (bool, uint160) l0;
  }
  uint128   s0 = uint128(0);
  bytes3   s1;
  constructor(bytes3 i0)   {
    s1 |= bytes3(bytes("000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    unchecked {
      require(false, string.concat(string("00000000000000000000000000000000000000000000000000000000000000004d08abd3cdfd22ebfccdeeddd528a4e60ff4dbecd2df367b"), ((true ? true : true) ? string("0000000000000000000000000000000000000000000000") : string("000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff")), string("0000000000000000000000000000000000000000000000000000000000005891ada18148061d95ed2247575cdb025e3e622f7a"), string("3212095b735e43b2662c931bf196c563fa79893e5bffffffffff")));
      bytes3  l0 = s1;
      bytes3  l1 = l0;
      assert(l1 == s1);
      (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
      (bool l4, bytes memory l5) = payable(this).call{value: 0}("");
      uint128  l6 = s0;
      uint128  l7 = l6;
      assert(l7 == s0);
      uint128  l8 = s0;
      uint128  l9 = l8;
      assert(l9 == s0);
      bytes3  l10 = s1;
      bytes3  l11 = l10;
      assert(l11 == s1);
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
