
==== Source: su0.sol ====
function f0(int128 i0,bool i1)    
{
  function () internal   returns (bool, bytes17, int104) l0;
}
library L0 {
  function f1(bytes21 i0) external    returns(bool o0,int152[2] memory o1)
  {
    function (int256, bytes19, bytes13) external   returns (bool, uint88, function (address) external   returns (bool, function (uint192, bool) external  )) l0;
  }
  bool public constant cons0 = true;
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67
  }
  modifier m0() 
  {
    while (((((int184(0) | (int184(0) | int184(-1103389076304195231970631813239767359116160401383268277))) ** uint24(uint24(0))) & int184(-6350201866885587616084873884140148968812566137015556901)) <= int184(1439638214579746868450499107914739769540533050034067748)))
    {
      if ((bytes1(0x88) >= bytes1(0x00)))
      {
        _;
      }
    }
    _;
    uint72 l0 = (uint72((uint72(((((uint72(3503786540876965980076) % uint72(0)) | uint72(1031444897504861546638)) >> uint192(uint192(767103881708351506438482934001670658170125095340210931654))) / uint72(0))) / uint72(4722366482869645213695))) << uint136(uint136(54226772286577376345537463893772958861592)));
  }
  function f2() external  m0() m0() 
  {
    assembly
    {
      switch 0
      default
      {
      }
      function af0(ai0) -> ao0, ao1, ao2
      {
        switch ai0
        default
        {
        }
      }
    }
  }
  type T0 is int48;
}
error er0(function (address, L0.EN0, int208) external   ep0);
pragma solidity >= 0.0.0;
struct St0 {
  function (uint112, int136[] memory, string memory) external   el0;
  bytes1 el1;
}

==== Source: su1.sol ====
type T1 is uint168;
contract C0 {
  type T2 is bytes13;
  address   s0 = address(this);
  bytes32   s1;
  mapping(address => bool)   s2;
  function (bool, uint216) external   returns (int128)[]  public s3;
  constructor(bytes32 i0,function (bool, uint216) external   returns (int128)[] memory i1)   {
    s1 &= bytes32(0x7a98be7225f816d7c984f42039f093a04c10de084d6b20b5bce60ccaf5194ff0);
    s3 = i1;
    s2[address(this)] = true;
    unchecked {
      bool l0 = (false && false);
    }
  }
  function f3() public virtual  payable returns(bool o0)
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffff0000000000000000000000"));
    uint64[] memory l2 = new uint64[](1);
  }
  error er1(address payable ep0);
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
