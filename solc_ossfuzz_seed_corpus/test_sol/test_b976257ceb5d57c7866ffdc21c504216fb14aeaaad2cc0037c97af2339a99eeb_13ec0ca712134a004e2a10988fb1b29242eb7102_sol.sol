
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    if (true)
    {
      return;
    }
    else if (false)
    {
      if (false)
      {
      }
    }
  }
  mapping(uint16 => bool)  public s0;
  constructor() payable  {
    s0[uint16(24923)] = true;
    unchecked {
    }
  }
  function f1() public   payable  returns(uint32 o0)  {
    o0 >>= (uint32(4294967295) << uint240(uint240(228952893366311419113271020959609023000708459023983870523411185946525713)));
    o0 -= ((uint32(685613086) | (uint32(4294967295) | uint32((uint32(4109281469) / uint32(0))))) + uint32(1410549327));
  }
  function f2(address i0,uint168 i1) private     returns(bool o0)  {
    if (i1 >= (uint168(0) % (~(uint168(374144419156711147060143317175368453031918731001855)))))
    {
      return (true);
    }
    else
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("f1349e586741ed08aca9136a44f858d4b1a0c25942a850dbb2ebac0977a10d540000000000000000000000000000000000000000"));
    }
  }
  struct St0 {
    function (int48, bytes14, string memory) external   returns (bytes18, int144, address) el0;
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  bool el0;
  bool el1;
  int104[] el2;
}
bool constant cons0 = true;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  fallback() external virtual  payable
  {
    return;
  }
  function f4(function (bytes6) external   returns (bool, uint104) i0) public virtual    returns(bytes11 o0,function (bytes29, address[1] memory) external   returns (address) o1,int184 o2)  {
  }
  function f5(int152 i0) internal      {
  }
  error er0(bool ep0);
  uint136   s1;
  bool  public s2;
  bool immutable public s3 = false;
  constructor(uint136 i0,bool i1)   {
    s1 >>= (i0 &= ((uint24(16575263) * uint136(19379691179867580191681660892781204208868)) ** uint208(uint208((uint208(0) / uint208(411376139330301510538742295639337626245683966408394965837152255))))));
    s2 = true;
    unchecked {
    }
  }
}
function f6(int240 i0)    pure suffix returns(function () external   returns (uint48) o0){
  (uint48 l0) = o0();
}
contract C2 {
  struct St2 {
    bytes el0;
    uint136 el1;
  }
  uint232   s4;
  constructor(uint232 i0)   {
    s4 <<= uint232(6901746346790563787434755862277025452451108972170386555162524223799295);
    unchecked {
    }
  }
}
type T0 is bytes20;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



import "su0.sol";
// ====
// ----
