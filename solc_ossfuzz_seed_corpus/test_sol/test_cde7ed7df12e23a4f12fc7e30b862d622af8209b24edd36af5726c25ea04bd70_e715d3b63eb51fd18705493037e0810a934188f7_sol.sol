
==== Source: su0.sol ====
contract C0 {
  function f0() private    returns(uint120 o0)
  {
    uint128 l0 = uint128(0);
    assembly
    {
      if sgt(o0, 0)
      {
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(50440729790227480127237503864450142353644615364155662775012296765423658310020, 11)) { yulinit0 := add(yulinit0, 1) }
        {
          let al0 := o0
          {
            break
          }
          stop()
        }
        o0 := l0
        stop()
      }
    }
  }
  bytes17  public s0;
  constructor(bytes17 i0)   {
    s0 &= (bytes6(0x57abc9933872) & (bytes17(0xffffffffffffffffffffffffffffffffff) ^ bytes17(0x0468ed6184043395efb4b33937cb030ec0)));
    unchecked {
      bytes17  l0 = s0;
      bytes17  l1 = l0;
      assert(l1 == s0);
    }
  }
}
library L0 {
  function f1() private    returns(bool o0)
  {
  }
  type T0 is bool;
}
pragma solidity >= 0.0.0;
library L1 {
  function f2(uint48[][][][][7][7] memory i0,bytes13 i1) public   
  {
    string memory l0 = string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
}

==== Source: su1.sol ====
function f3(int168 i0)     returns(uint160 o0)
{
  assembly
  {
    o0 := 0
  }
  uint8 l0 = (((uint8(112) ^ uint8((uint8(0) / uint8(255)))) + uint8(255)) << uint144(uint144(0)));
  address payable l1 = payable(address(0x0000000000000000000000000000000000000002));
}
pragma solidity >= 0.0.0;
// ====
// ----
