
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  function () external   returns (int192) el0;
  bool el1;
  uint80 el2;
  mapping(address => bytes12) el3;
}

==== Source: su1.sol ====
library L0 {
  function f0(bytes32 i0,bool i1,uint56 i2) private   
  {
  }
  function f1(uint152 i0) external    returns(function (address payable, int56[1][] memory) external   returns (uint216[] memory, bytes6[3] memory, bool) o0,bool o1,uint152 o2)
  {
    o2 <<= uint152((uint152(5708990770823839524233143877797980545530986495) / uint152(0)));
    unchecked {
      bytes32[10][] memory l0 = new bytes32[10][](5);
      int104 l1 = int104(10141204801825835211973625643007);
      function (address, bool) external   returns (int120) l2;
      (int120 l3) = l2(address(bytes20(address(0x0000000000000000000000000000000000000000))),(false ? ((address(0x0000000000000000000000000000000000000005) > address(0x0000000000000000000000000000000000000008)) == false) : false));
      address payable l4 = payable(msg.sender);
      assert(true);
    }
  }
}
library L1 {
  function f2(bool i0,int240 i1) public   
  {
  }
  function f3() public    returns(address payable o0,int216 o1,bool o2)
  {
  }
}
library L2 {
  function f4(uint136 i0,uint192 i1) external   
  {
    bool l0 = true;
    address payable l1 = payable(msg.sender);
  }
  function f5() internal    returns(address o0)
  {
    address l0 = address(0x0000000000000000000000000000000000000002);
    require((false != true));
  }
  function f6() private    returns(int208 o0)
  {
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  mapping(address => bool) el0;
  bytes el1;
  bytes el2;
}
// ====
// ----
