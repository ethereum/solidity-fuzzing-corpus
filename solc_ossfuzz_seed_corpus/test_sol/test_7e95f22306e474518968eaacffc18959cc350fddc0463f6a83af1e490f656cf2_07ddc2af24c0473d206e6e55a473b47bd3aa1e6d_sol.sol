
==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
    uint56 l0 = ((uint56(19552451893338995) << uint152(uint152(2100041847874550504904230185531155160941157489))) ^ uint56(72057594037927935));
    function (address payable[][][] memory) external   returns (bytes3, uint152) l1;
    (bytes3 l2, uint152 l3) = l1(new address payable[][][](1));
  }
  uint8  public s0 = uint8(255);
  bool  public s1;
  constructor(bool i0)   {
    s1 = false;
    unchecked {
      uint8  l0 = s0;
      uint8  l1 = l0;
      assert(l1 == s0);
    }
  }
}
library L0 {
  error er0(bytes ep0, address ep1);
  event ev0();
}
pragma solidity >= 0.0.0;
library L1 {
  function f1(bytes memory i0,bytes17 i1) external    returns(int56 o0,bytes23 o1)
  {
  }
  function f2(function (int96, address, bytes27) external   i0,bool i1,function (bytes22) external   returns (bool) i2) external   
  {
    assembly
    {
      {
        if i1
        {
          let al0 := mload(add(0x80, mod(90878462724450989455801134593128624637273892395070483215575186908015146063040, 2048)))
        }
        if 108529176795615559760004342635672711663509205638830921179835016982407594293984
        {
        }
      }
      let al1 := calldataload(mod(i1, calldatasize()))
      if 100701135179650219770842869607156628729286185798583936951684735169222315100775
      {
      }
      function af0(ai0, ai1, ai2, ai3, ai4, ai5, ai6, ai7, ai8, ai9, ai10, ai11, ai12) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12, ao13, ao14
      {
        let al2 := extcodehash(calldataload(mod(0, calldatasize())))
        ao3 := ai4
      }
      switch mload(add(0x80, mod(i1, 2048)))
      case 0
      {
      }
    }
    function (int208, bytes7[][][][][] memory) internal   returns (bytes memory) l0;
    address l1 = address(0x0000000000000000000000000000000000000005);
  }
}
// ====
// ----
