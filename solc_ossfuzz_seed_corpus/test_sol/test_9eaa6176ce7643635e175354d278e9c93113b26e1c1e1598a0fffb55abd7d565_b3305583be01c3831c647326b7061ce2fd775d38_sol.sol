
==== Source: su0.sol ====
function f0()     {
  bytes15 l0 = (((uint80(83491333351336970555701) >> uint240(uint240(1224935819886786805453403168391278300509174811885177726094244514495856921))) >= uint80(int80(604462909807314587353087))) ? bytes15(0x328eeb59937d9480877ffd556a0ab8) : bytes15(0x000000000000000000000000000000));
  if ((int56(-4673401425112658) < int56(0)))
  {
    if (((uint232(0) % uint232(6901746346790563787434755862277025452451108972170386555162524223799295)) == ((uint232(0) << uint168(uint168(374144419156711147060143317175368453031918731001855))) | uint232(0))))
    {
    }
    else if (((~(uint136(0))) != (((uint136(87112285931760246646623899502532662132735) >> uint16(uint16(0))) & uint136(87112285931760246646623899502532662132735)) & uint136(43259295537140766845941925899764199433634))))
    {
      function (uint104, bool) external  [8] memory l1;
      if (false)
      {
      }
    }
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  else
  {
    bool l2 = true;
  }
}
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8
}
contract C0 {
  int144   s0 = int144(0);
  address  public s1 = address(this);
  uint24  public s2;
  constructor(uint24 i0)   {
    s2 /= (uint24(0) << uint168(uint168(uint96(0))));
    unchecked {
    }
  }
  function f1(int144 i0,address i1) private     returns(EN0 o0)  {
    if (i0 > (-(int144(11150372599265311570767859136324180752990207))))
    {
      (s2, o0) = (uint24((((true ? (s2 >>= ((((((uint24(0) | uint24(16625751)) ^ uint24(16777215)) ^ uint24(16777215)) & uint24(0)) - uint24(0)) >> uint64(uint64(18446744073709551615)))) : (uint24(5414232) % uint24(16777215))) >> uint184(uint184(0))) / uint24(0))), EN0(uint8(0)));
      assert(s2 == uint24((((true ? (s2 >>= ((((((uint24(0) | uint24(16625751)) ^ uint24(16777215)) ^ uint24(16777215)) & uint24(0)) - uint24(0)) >> uint64(uint64(18446744073709551615)))) : (uint24(5414232) % uint24(16777215))) >> uint184(uint184(0))) / uint24(0))));
      assert(o0 == EN0(uint8(0)));
    }
  }
  event ev0();
  error er0(EN0 ep0);
  function f2(int144 i0) external virtual    returns(bool o0)  {
    return (true);
  }
}

==== Source: su1.sol ====
struct St0 {
  function (address payable, address payable, int8) external   el0;
  bytes el1;
  bool el2;
  bool el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
