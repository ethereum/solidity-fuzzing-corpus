
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    mapping(bool => bytes22) el0;
    uint32 el1;
  }
  event ev0(address[]  ep0, function () external   returns (int32, address payable) indexed ep1);
  event ev1();
  bool   s0 = false;
  int88 immutable public s1 = int88(0);
  function f0() public    returns(bytes10 o0)
  {
    s0 = false;
    (o0) = (bytes10(0xe6c2d4897b7e3ad5b5f3));
  }
  error er0(int144 ep0, bytes21 ep1);
  modifier m0(address payable i0,address payable i1) virtual
  {
    if (false)
    {
      if (true)
      {
        _;
      }
      else
      {
        payable(this).transfer(4605234654128161139);
      }
      _;
    }
    else
    {
    }
    _;
    if ((bytes1(0xff) != bytes1(0xff)))
    {
      if ((false ? false : ((uint144(0) + uint144(8898501194664641545251720203861238236275091)) == uint144(8103980299573604038403624657460824241998714))))
      {
      }
      else if (false)
      {
        unchecked {
        }
      }
      else if (false)
      {
      }
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18
  }
  receive() external virtual m0(payable(address(this)),payable(address(this))) m0(payable(address(this)),payable(address(this))) payable
  {
    if (true)
    {
      if (false)
      {
      }
      0;
    }
    else if (((!(false)) || false))
    {
    }
  }
  function f2(function (int208, bytes29) external   returns (C0.EN0) i0) external virtual m0(payable(address(this)),payable(address(this))) 
  {
    { }
  }
  fallback() external virtual m0(payable(address(this)),payable(address(this))) payable
  {
  }
}
error er1(address payable[] ep0);
pragma solidity >= 0.0.0;
// ====
// ----
