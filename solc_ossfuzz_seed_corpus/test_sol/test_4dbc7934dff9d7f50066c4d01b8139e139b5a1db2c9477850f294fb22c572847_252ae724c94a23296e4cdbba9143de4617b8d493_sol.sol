
==== Source: su0.sol ====
struct St0 {
  int192 el0;
  uint8 el1;
  uint8 el2;
  mapping(uint96 => int232) el3;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f0()      returns(bool o0,function (function () external   returns (uint8)) external   o1){
  return (false, o1);
}
contract C0 {
  function f1() internal virtual    returns(function (function (uint168) external   returns (bytes11), int144) external   returns (function () external   returns (bool[8] memory), address payable) o0)  {
    uint232 l0 = uint232((uint232(0) / uint40(1099511627775)));
    return (o0);
  }
  function f2(bytes12 i0,int64 i1) private     returns(function () external   returns (uint64, bytes28, uint232[6] memory) o0)  {
    delete o0;
    for(uint solinit0 = 0; solinit0 < ((uint256(0) << uint136(((uint136(0) - (uint136(0) ^ uint136(0))) | uint136(87112285931760246646623899502532662132735)))) % 11); solinit0++)
    {
      do
      {
        if (i1 >= ((int64(5836676239515843990) + ((~((int64(-2793233309521949504) * int64(6290130702671308934)))) % int64(0))) % int64(9223372036854775807)))
        {
          continue;
        }
      }
      while ((((uint120(102893820677388534637209938275213198) | ((uint120(0) | uint120(55609345862265238960212378145492207)) | uint120(0))) & uint120(1329227995784915872903807060280344575)) == uint120(0)));
      delete o0;
    }
  }
  event ev0(bytes15[]  ep0);
  string  public s0;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  address   s1 = address(this);
  mapping(address => address)[]  public s2;
  constructor(string memory i0) payable  {
    s0 = string("This is a really long string that must ideally be random but is currently hard coded");
    unchecked {
    }
  }
}
// ====
// ----
