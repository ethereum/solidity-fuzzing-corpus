
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  address payable  public s0 = payable(address(this));
  uint208   s1 = uint208(0);
  int168   s2;
  bool   s3 = false;
  constructor(int168 i0)   {
    s2 *= (int168(187072209578355573530071658587684226515959365500927) ^ int168(187072209578355573530071658587684226515959365500927));
    {
    }
  }
  function f0() public      {
    if (false)
    {
      if (true)
      {
        assert(true);
      }
    }
  }
  struct St0 {
    address payable el0;
    bool el1;
    uint120 el2;
    uint200 el3;
  }
  function f1() external   payable  returns(function (function (int256, address payable) external   returns (uint168), C0.St0 memory, address) external   o0)  {
    (bool l0) = payable(this).send(9843046328565982464);
  }
  function f2(bool i0,uint208 i1,uint208 i2) external   payable   {
    if (i1 >= uint208((uint208(411376139330301510538742295639337626245683966408394965837152255) / (uint208(225809674675386223844091938603669599954348403019518357344287796) + ((uint208(0) % uint208(411376139330301510538742295639337626245683966408394965837152255)) % uint208(108810138621602644367491817764281418484735589900622407419256907))))))
    {
      payable(this).transfer(0);
      if (i0)
      {
      }
      else
      {
        uint208  l0 = s1;
        uint208  l1 = l0;
        assert(l1 == s1);
        (bool l2, bytes memory l3) = address(this).call(abi.encodeWithSelector(this.f1.selector));
      }
    }
    return;
  }
  receive() external virtual  payable
  {
    address payable  l0 = s0;
    address payable  l1 = l0;
    assert(l1 == s0);
    do
    {
      (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
    }
    while (true);
    payable(this.f0.address);
  }
  struct St1 {
    mapping(bytes6 => address) el0;
    address el1;
  }
}
contract C1 {
  event ev0(uint248 indexed ep0, address  ep1);
  C0.St0   s4;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}  C0.St0  public s5 = C0.St0(payable(address(0x0000000000000000000000000000000000000007)), false, uint120(230167020814182934249154524446452201), uint200(0));
  address   s6 = address(this);
  bytes25   s7;
  constructor(bytes25 i0)   {
    s7 &= bytes25(0x00000000000000000000000000000000000000000000000000);
    unchecked {
    }
  }
  fallback() external   
  {
    if (false)
    {
    }
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
error er0();
struct St2 {
  bool el0;
  uint208 el1;
  function (bool, string memory, address payable) external   returns (uint8, address) el2;
  int48 el3;
}
// ====
// ----
