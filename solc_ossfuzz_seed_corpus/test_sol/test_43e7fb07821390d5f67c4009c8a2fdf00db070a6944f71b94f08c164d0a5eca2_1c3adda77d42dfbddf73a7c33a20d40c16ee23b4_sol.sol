
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    address payable l0 = payable(address(this));
    (l0) = (payable(address(this)));
    assert(l0 == payable(address(this)));
  }
  int120   s0;
  mapping(uint80 => uint240)   s1;
  int200  public s2;
  constructor(int120 i0,int200 i1) payable  {
    s0 |= (int120(((~(((payable(address(this)) > payable(address(this))) ? int40(-443675765046) : int40(549755813887)))) & int40(326646446079))) & int120(-530704871557644531354717579000520828));
    s2 -= int200((((int200(803469022129495137770981046170581301261101496891396417650687) | (true ? int200(-155828770455938333682577770284656813516359616994934161487926) : int200(0))) - int200(0)) / int200(-504117554190365895317624702697341906477233577084754559998489)));
    s1[uint80((((int80(604462909807314587353087) - int80(-161715362982650565916103)) | int80(604462909807314587353087)) & int80(315071834675513096313838)))] = uint240(1766847064778384329583297500742918515827483896875618958121606201292619775);
    {
      int120  l0 = s0;
      int120  l1 = l0;
      assert(l1 == s0);
    }
  }
  receive() external virtual  payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    int120  l2 = s0;
    int120  l3 = l2;
    assert(l3 == s0);
  }
}
pragma solidity >= 0.0.0;
library L0 {
  function f2() external    returns(function (address payable, int176) external   returns (address payable[3][][][][][] memory) o0)
  {
    try o0(payable(address(0x0000000000000000000000000000000000000004)),int176(37112421159749786889970560999912499165964561123401450)) returns (address payable[3][][][][][] memory l0)
    {
      uint112 l1 = ((uint112(5192296858534827628530496329220095) & ((uint88(309485009821345068724781055) % uint88(305169013773535177649621777)) | uint88(157050172553601859692641995))) | uint112(0));
    }
    catch
    {
    }
    catch Error(string memory l2)
    {
      function (uint120, uint224) external   l3;
    }
  }
  function f3(address i0) public   
  {
    i0 = address(0x0000000000000000000000000000000000000005);
    assert(i0 == address(0x0000000000000000000000000000000000000005));
  }
  function f4(function () external   returns (address payable, bytes12) i0,bytes32 i1) external    returns(function (int144) external   returns (bytes18[] memory, int88[6][2] memory) o0,int176 o1,bytes19 o2)
  {
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
