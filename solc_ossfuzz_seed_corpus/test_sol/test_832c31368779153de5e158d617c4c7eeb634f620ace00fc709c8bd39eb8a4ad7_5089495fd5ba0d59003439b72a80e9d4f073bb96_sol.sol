
==== Source: su0.sol ====
function f0(int48[] memory i0,int256 i1,bytes9 i2)      returns(int104 o0,uint72 o1,bool o2){
  if (i2 >= ((true ? true : (bytes4(0x00000000) >= bytes4(0x200a1d77))) ? bytes9(0xffffffffffffffffff) : bytes9(0x000000000000000000)))
  {
    for(;
;
((uint200(1057422042635968707616400749761402673859291770597552040598856) >> uint240(((uint240((uint240(0) / uint240(0))) * uint240(0)) * uint240(0)))) << uint80(uint80(110699501298350136429242))))
    {
      return (int104(((int104(3899502700266748069678809013105) % ((int104(0) - int104(0)) + int104(10141204801825835211973625643007))) / int104(10141204801825835211973625643007))), uint72(4722366482869645213695), false);
    }
    if (i0.length > uint256(0))
    {
      if (i0.length < uint256(17772895751586268051042571675650495061359868774714605824090569440669686031714))
      {
      }
      else
      {
        return (int104(-615323240544550924183429081418), ((uint72(4674488410843771576165) * uint72(806305975646801539426)) + uint72(0)), false);
      }
    }
  }
}
pragma solidity >= 0.0.0;
error er0();
function f1(int240 i0) pure suffix  returns(bytes1 o0)
{
}

==== Source: su1.sol ====
contract C0 {
  int144 public constant cons0 = 0;
  mapping(int88 => bytes32)   s0;
  bool  public s1 = false;
  uint216   s2 = uint216(86799372987788924712168759944923613196362816973939784593827787712);
  constructor()   {
    s0[(((int88(((int200(803469022129495137770981046170581301261101496891396417650687) - int200(803469022129495137770981046170581301261101496891396417650687)) + int200(803469022129495137770981046170581301261101496891396417650687))) - int88(-35601350089091268101617228)) ^ int88(0)) % int88(154742504910672534362390527))] |= bytes32(0x0000000000000000000000000000000000000000000000000000000000000000);
    unchecked {
      do
      {
        break;
      }
      while (true);
    }
  }
  struct St0 {
    uint16 el0;
    bytes30 el1;
    int224 el2;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
