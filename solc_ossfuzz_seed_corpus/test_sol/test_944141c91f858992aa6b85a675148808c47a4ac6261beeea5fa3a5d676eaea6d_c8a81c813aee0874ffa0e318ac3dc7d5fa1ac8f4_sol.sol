==== Source:  ====

==== Source: su0.sol ====
library L0 {
  error er0(bool ep0);
  error er1(function (int48, uint256) internal   returns (function (uint88, uint240) external   returns (int176), bytes29[1] memory) ep0);
  bool public constant cons0 = ((((~(((uint248(452312848583266388373324160190187140051835877600158453279131187530910662655) >> uint224(uint224(0))) * uint248(0)))) ** uint88(uint88(0))) % uint248(390605211071110441806201901149397770112443559261863562901214588293369620132)) != uint248(12249894130972283417384120320390759101388509599270243066207126021332305180));
  function f0(int40 i0) private    returns(int80 o0)
  {
  }
  modifier m0() 
  {
    _;
  }
  uint104 public constant cons1 = ((((((uint104(20282409603651670423947251286015) >> uint64(uint64(4472491790754660019))) & uint104(20282409603651670423947251286015)) % uint104(0)) >> uint16(uint16(32526))) ^ uint104(0)) << uint128(uint128(0)));
  error er2();
  function f1() public  m0()  returns(function (int160) external   o0,address o1)
  {
  }
  function f2(bool i0,bool i1) public   
  {
  }
  function f3() external   
  {
    return;
  }
  using L0 for *;
}
using L0 for uint;
using L0 for uint;
using L0 for uint;
pragma solidity >= 0.0.0;
// ----
// TypeError 3417: (su0.sol:48-172): Internal or recursive type is not allowed as error parameter type.
// Warning 3149: (su0.sol:666-874): The result type of the shift operation is equal to the type of the first operand (uint104) ignoring the (larger) type of the second operand (uint128) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
