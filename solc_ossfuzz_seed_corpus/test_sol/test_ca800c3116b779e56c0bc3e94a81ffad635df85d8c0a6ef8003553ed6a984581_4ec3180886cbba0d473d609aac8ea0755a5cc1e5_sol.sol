
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    mapping(bytes23 => bool) el0;
  }
  mapping(bool => bool)   s0;
  bool  public s1;
  int208   s2 = int208(205688069665150755269371147819668813122841983204197482918576127);
  bool  public s3 = false;
  constructor(bool i0)   {
    s1 = true;
    s0[false] = (bytes7(0x00000000000000) < (bytes7(0xffffffffffffff) ^ ((~(bytes7(0x6d81e4e77a5b2d))) ^ bytes7(0x54ebd43c2d9517))));
    {
      (s3) = (true);
      assert(s3 == true);
      int208  l0 = s2;
      int208  l1 = l0;
      assert(l1 == s2);
      if ((((int136((((int136(43556142965880123323311949751266331066367) ** uint48(uint48(281474976710655))) - int136(43556142965880123323311949751266331066367)) / int136(43556142965880123323311949751266331066367))) | int136(43556142965880123323311949751266331066367)) & int136(-33999257740044714273852427335942182102903)) < int136(43556142965880123323311949751266331066367)))
      {
      }
      else if ((bytes12(0x000000000000000000000000) < bytes12(0xffffffffffffffffffffffff)))
      {
        (bool l2, bytes memory l3) = address(this).call(bytes(string("99898cfe1eab3170f6ae52838ff2e5d89731812e99ffffffffffffffffffffffffffff")));
      }
      revert(string.concat(string("7b62c9ba7b3f648a55a80138036dc36a99b91139")));
    }
  }
  modifier m0(function (bytes31, function (function (bool, address payable, address) external  , bytes memory, bool) external   returns (uint176, uint120)) internal   returns (uint200) i0) 
  {
    _;
  }
  event ev0();
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
