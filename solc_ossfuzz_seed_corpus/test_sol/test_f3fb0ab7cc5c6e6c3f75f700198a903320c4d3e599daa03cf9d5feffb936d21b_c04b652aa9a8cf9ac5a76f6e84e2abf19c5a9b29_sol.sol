
==== Source: su0.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94, M95

}
pragma solidity >= 0.0.0;
error er0();
contract C0 {
  bytes[]   s0 = ["ffffffffffffffffffffff5d21521ca33ecf869f73cc7269b93869"];
  address payable   s1 = payable(address(this));
  int120   s2;
  constructor(int120 i0)   {
    s2 %= int120(-581899712819404675767651288712593251);
    {
      for(      bytes[] storage l0;
;
false)
      {
      }
      if (false)
      {
      }
      s0[0] = "939fc4875f78e289b869d13b72b535924636381fc305be44e3878d00000000000000000000000000000000000000000000";
    }
  }
  modifier m0(int56 i0,function (bool, int40, bytes memory) internal   returns (uint232, EN0, bytes11)[] memory i1) 
  {
    address(this);
    _;
  }
  type T0 is bool;
  function f0() external virtual  
  {
  }
  error er1();
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8
  }
  error er2(int32 ep0);
  fallback() external virtual m0((int56(36028797018963967) + (int56(0) | (int56(36028797018963967) & int56(36028797018963967)))),new function (bool, int40, bytes memory) internal   returns (uint232, EN0, bytes11)[](2)) 
  {
    (bool l0, bytes memory l1) = address(this).call("4fdbff08000000000000");
    (s0[0]) = ("000000000000000000000000000000000000000047259b3d0303c606d3fbd96ce41abdb86b44cd58a9942c13");
    if (false)
    {
      return;
    }
    else
    {
    }
    (s0[1], s0) = (bytes("0000000000000000000000000000000000000000000000000000000000"), ["00000000000000000000000000000000000000000000000000", bytes("4dde4bb7960364b799991d0a4e")]);
    return;
  }
  enum EN2 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  enum EN3 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81
  }
  enum EN4 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20
  }
  error er3();
  bytes15   s3 = bytes15(0x000000000000000000000000000000);
  address payable public constant cons0 = payable(address(bytes20(address(0x414400d69860C7c0Fb468A22D1a45031c94F9Ae8))));
  function f2() private   
  {
  }
  modifier m1(int168 i0) 
  {
    _;
  }
  type T1 is bool;
  function f3(bytes31 i0,C1.EN4[] calldata i1) internal virtual  
  {
    if ((!(((uint112(0) * ((uint112(5192296858534827628530496329220095) | uint112(1086498230169457736636510803649060)) - uint112(0))) != uint112(0)))))
    {
    }
    else if ((true || true))
    {
      (s3) = (bytes15(0xffffffffffffffffffffffffffffff));
    }
  }
}
import "su0.sol";
error er4(address payable ep0);
library L0 {
  error er5(bytes[2] ep0);
  function f4(C1.EN4 i0,function (int176, int208) external   returns (bool, C1.EN3, uint184) i1) internal    returns(address[2][] memory o0,uint144 o1)
  {
  }
  C0.T0 public constant cons1 = C0.T0.wrap(false);
}
using L0 for uint;
struct St0 {
  mapping(int184 => address) el0;
  uint88[] el1;
}
// ====
// ----
