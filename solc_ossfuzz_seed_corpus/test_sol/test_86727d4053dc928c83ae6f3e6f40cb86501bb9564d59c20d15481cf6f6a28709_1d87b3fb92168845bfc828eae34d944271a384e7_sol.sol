
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() public   payable returns(function (bytes memory, bool) external   returns (address payable[][9][8][] memory, uint64) o0,int128 o1,uint152 o2)
  {
    address payable l0 = payable(address(this));
    uint56 l1 = uint56(72057594037927935);
    function () external   returns (address payable) l2;
  }
  bytes9   s0;
  uint160   s1;
  mapping(uint232 => bytes8)   s2;
  int112 immutable  s3;
  constructor(bytes9 i0,uint160 i1,int112 i2)   {
    s0 = bytes9(0xe16f3b48c92258af8b);
    s1 >>= uint160(1461501637330902918203684832716283019655932542975);
    s3 = (((((int64(9223372036854775807) & int64(9223372036854775807)) + int112(0)) & int112(2596148429267413814265248164610047)) * int112(0)) - int112(2596148429267413814265248164610047));
    s2[uint232(0)] ^= ((bytes8(0xb0f9a1d8f63a5010) | (bytes8(0xffffffffffffffff) & bytes8(0xffffffffffffffff))) ^ bytes8(0x0000000000000000));
    unchecked {
      (s0) = (bytes9(0xffffffffffffffffff));
      assert(s0 == bytes9(0xffffffffffffffffff));
      (function (bytes memory, bool) external   returns (address payable[][9][8][] memory, uint64) l0, int128 l1, uint152 l2) = this.f0();
      uint160  l3 = s1;
      uint160  l4 = l3;
      assert(l4 == s1);
      int112  l5 = s3;
      int112  l6 = l5;
      assert(l6 == s3);
      int120(((int120(0) ** uint8(uint8(255))) / (int120(664613997892457936451903530140172287) * int120(201317114835034423530151517161682778))));
      bytes9  l7 = s0;
      bytes9  l8 = l7;
      assert(l8 == s0);
    }
  }
}
// ====
// ----
