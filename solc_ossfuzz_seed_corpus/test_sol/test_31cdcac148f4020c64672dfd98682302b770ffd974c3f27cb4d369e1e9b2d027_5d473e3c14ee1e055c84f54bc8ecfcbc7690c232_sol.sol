
==== Source: su0.sol ====
struct St0 {
  address payable el0;
  int168 el1;
}
struct St1 {
  bytes el0;
  bool el1;
  address payable el2;
}
struct St2 {
  St0 el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  function f0() public virtual    returns(string memory o0,bytes8 o1)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    for(uint solinit0 = 0; solinit0 < (l1.length % 11); solinit0++)
    {
      break;
    }
    (bool l2, bytes memory l3) = address(this).call(bytes("3baa0e2391b3ab25730a3c7242f002795be16a62f329df40d176c3323d1fc3ffff"));
  }
  event ev0(function (int8[] memory) external   returns (uint120, bool)  ep0, bool  ep1);
  function f1() internal     returns(bool o0)  {
    return (false f2 /*suffix expr*/);
  }
  mapping(int104 => uint160)   s0;
  int248   s1;
  mapping(uint56 => bool)  public s2;
  bool   s3 = true;
  constructor(int248 i0)   {
    s1 += (int248(0) - int56(0));
    s0[(~((int104(0) ^ int40(0))))] |= uint160(0);
    s2[(uint56(((((uint48(281474976710655) % uint48(281474976710655)) - uint48(281474976710655)) << uint216(uint216(97825613573451557816736751202098584545913227330027214172681402066))) | uint48(0))) | uint56(72057594037927935))] = false;
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
function f2(bool i0) pure suffix  returns(bool o0)
{
  o0 = false;
  assert(o0 == false);
  if (i0)
  {
    uint184 l0 = uint184(24519928653854221733733552434404946937899825954937634815);
    for(uint solinit1 = 0; solinit1 < (hex"c305be1ef03d492ff217317c" f3 /*suffix expr*/ % 11); solinit1++)
    {
      if (i0)
      {
        return (false);
      }
    }
    return (true);
  }
}
function f3(bytes12 i0) pure suffix  returns(uint256 o0)
{
}
// ====
// ----
