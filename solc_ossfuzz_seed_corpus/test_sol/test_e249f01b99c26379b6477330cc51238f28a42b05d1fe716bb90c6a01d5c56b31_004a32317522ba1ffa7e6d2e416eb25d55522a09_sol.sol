
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
uint80 constant cons0 = 1208925819614629174706175;
contract C0 {
  bool   s0;
  uint112   s1 = uint112(0);
  constructor(bool i0) payable  {
    s0 = (bytes26(0x69b0f1e2755d381132e93b9d099994aa937794f3fff8ffdc2d65) >= bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
    {
      payable(this).transfer(3257631021647440021);
    }
  }
  receive() external   payable
  {
    uint112  l0 = s1;
    uint112  l1 = l0;
    assert(l1 == s1);
    bool  l2 = s0;
    bool  l3 = l2;
    assert(l3 == s0);
  }
  fallback() external   payable
  {
    (s1) = ((((~(uint112(0))) % uint112(0)) * uint112(849100848127927354444976829770065)));
    assert(s1 == (((~(uint112(0))) % uint112(0)) * uint112(849100848127927354444976829770065)));
    unchecked {
      bool  l0 = s0;
      bool  l1 = l0;
      assert(l1 == s0);
      uint112  l2 = s1;
      uint112  l3 = l2;
      assert(l3 == s1);
      {
        (bool l4, bytes memory l5) = payable(this).call{value: 0}("");
      }
    }
    bool  l6 = s0;
    bool  l7 = l6;
    assert(l7 == s0);
    assembly
    {
      switch 70367114046050894144729970208968705004905997247607620471789204053214484146868
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      default
      {
        l7 := s0.offset
      }
      l7 := l7
      function af0(ai0, ai1, ai2, ai3, ai4, ai5, ai6, ai7, ai8) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12, ao13, ao14
      {
        function af1(ai9, ai10, ai11, ai12, ai13, ai14, ai15, ai16, ai17, ai18, ai19, ai20, ai21, ai22) -> ao15, ao16, ao17, ao18, ao19, ao20, ao21
        {
        }
        pop(ai0)
        let al0 := s0.offset
      }
      let al1 := l6
      let al2 := l7
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
