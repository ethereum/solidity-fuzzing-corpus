
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  bytes11   s0 = bytes11(0x0000000000000000000000);
  mapping(address => bytes27)  public s1;
  uint40  public s2;
  uint152   s3;
  constructor(uint40 i0,uint152 i1)   {
    s2 %= (false ? ((((uint40(1099511627775) % uint40(0)) ^ uint40(1099511627775)) * uint40(0)) ^ uint40(0)) : uint40(970228807542));
    s3 ^= (((uint80(1208925819614629174706175) ** uint32(uint32(0))) - uint80(0)) - uint80(439878071178229772776193));
    s1[address(this)] = bytes27(bytes8(0x0000000000000000));
    unchecked {
      uint152  l0 = s3;
      uint152  l1 = l0;
      assert(l1 == s3);
    }
  }
  struct St0 {
    address el0;
    mapping(bool => int112) el1;
    uint96 el2;
    mapping(bool => bytes23) el3;
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  C0.St0   s4;
  mapping(C0 => address[][])  public s5;
  constructor(uint40 i0,uint152 i1) payable C0(uint40(710254275123), uint152(97582744961019087173348953794896964355186973))
  {
    s2 <<= ((false ? uint40(((uint40(0) ^ uint40(0)) / uint40(1099511627775))) : uint40(0)) << uint56(uint56(62336567936824152)));
    s3 >>= (uint152(1258671776250226509326490897711121850862762663) % (((uint152(0) & uint152(5708990770823839524233143877797980545530986495)) % uint152(2011200123241691060243491580929125080177487219)) * uint152(3393873913350379262507216041690401872298096254)));
    s1[address(this)] &= bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    {
      require(false);
    }
  }
}
// ====
// ----
