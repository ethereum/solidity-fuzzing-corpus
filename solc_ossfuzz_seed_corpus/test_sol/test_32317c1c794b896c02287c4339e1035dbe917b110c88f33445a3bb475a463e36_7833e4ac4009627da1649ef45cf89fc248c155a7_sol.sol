
==== Source: su0.sol ====
library L0 {
  function f0() external    returns(int144 o0)
  {
    uint240 l0 = ((uint240((uint240(0) / ((uint240(163468237719768543990023664655600977914533175190983638859466784773400742) * uint240(0)) - uint240(0)))) ^ uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) | uint240(1766847064778384329583297500742918515827483896875618958121606201292619775));
  }
  function f1(bytes memory i0,int224 i1) external   
  {
    unchecked {
      require(false, string(bytes("ffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000")));
      require(true, string("000000000000000000000000000024637e1e"));
    }
    assert(false);
    uint144 l0 = uint144((uint144(0) / (uint144(22300745198530623141535718272648361505980415) | uint144(0))));
  }
}
contract C0 {
  bool immutable  s0;
  bool  public s1;
  bool   s2;
  constructor(bool i0,bool i1,bool i2)   {
    s0 = false;
    s1 = true;
    s2 = false;
    unchecked {
      for(uint solinit0 = 0; solinit0 < ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) ** uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) % 11); solinit0++)
      {
      }
    }
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  receive() external virtual  payable
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
  }
  fallback() external   
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
    bool  l2 = s2;
    bool  l3 = l2;
    assert(l3 == s2);
    s2 = (msg.sender == address(this));
    assert(s2 == (msg.sender == address(this)));
  }
  using L0 for *;
  using L0 for *;
}
using L0 for bytes;
pragma solidity >= 0.0.0;
library L1 {
  function f4() public   
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000001));
    return;
  }
  function f5(bytes28 i0) external    returns(address payable o0,function () external   returns (int16, address, bool[][] memory) o1,address payable o2)
  {
    revert(((bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff) <= bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff)) ? string("0000000000000000000000000000000000ffffffffffffffffffffffffffffffffffff") : string("0000000000000000000000000000000000000000000000000000000000699d")));
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
