==== Source:  ====

==== Source: su0.sol ====
error er0();
library L0 {
  using L0 for *;
  function f0() public   
  {
    do
    {
    }
    while (true);
  }
  modifier m0(int32 i0) 
  {
    for(    string memory l0 = string("36d489e1a30e1f5ebc686fdfd7d76e868156d833b916e90eb93e87ae221d4508475639d01e5cd4f5d6bc9a9abb3cb8c7c4ac");
false;
string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))
    {
      _;
    }
  }
  function f1() internal  m0((~(((int32(-1618391977) ** uint144(6485883848030187685941051212486209620889899)) ** (uint112(5192296858534827628530496329220095) ** uint224(7848063248916712499783485909997600799658379336782563740657736960414))))))  returns(address o0,bool o1,string memory o2)
  {
    revert er0();
  }
  function f2(bool[1] memory i0,string memory i1) internal    returns(bytes17 o0)
  {
    i0[0] = true;
  }
}
int192 constant cons0 = (((((~((int192(0) ** uint208(0)))) ** uint208(263781204335162038379351624266355408479294774492146655278732643)) ** uint96(24326279036484038543883282867)) ** uint224(0)) ** uint88(309485009821345068724781055));
using L0 for uint;
pragma solidity >= 0.0.0;
contract C0 {
  function f3(address i0) public   
  {
    i0 = address(this);
  }
  modifier m1(uint56 i0,function (int16, bool[1] memory, bytes memory) external   returns (bytes memory) i1) 
  {
    assembly
    {
    }
    _;
    _;
  }
  uint168 public constant cons1 = (~(((~((((~(uint168(58811324432077468040554862934203438249112591883391))) ** uint200(661920088261155119952186732872806164787603380183852178626857)) ** uint200(1109465320453337466156047371185371186836262409049356649407301)))) ** uint48(281474976710655))));
  modifier m2(bytes29 i0) virtual
  {
    _;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112, M113, M114, M115, M116, M117, M118, M119,
    M120, M121, M122, M123, M124, M125, M126, M127,
    M128, M129, M130, M131, M132, M133, M134, M135,
    M136, M137, M138, M139
  }
  struct St0 {
    bytes15 el0;
  }
  bool immutable s0;
  C0.St0  s1;
  C0.St0  s2;
  bytes  s3;
  constructor(bool i0,bytes memory i1) payable  {
    s0 = i0;
    s3 = i1;
    unchecked {
      if (false)
      {
        s2.el0 |= bytes15(0xffffffffffffffffffffffffffffff);
        s3.pop();
      }
      else if (false)
      {
        for(        C0.St0 memory l0 = C0.St0(bytes15(0x000000000000000000000000000000));
true;
)
        {
          revert er0();
        }
        delete s3;
      }
      else
      {
        revert er0();
        (s1.el0) = (bytes15(0xffffffffffffffffffffffffffffff));
      }
      s3.pop();
    }
  }
  function f4() external   payable returns(C0.St0 memory o0)
  {
    assembly
    {
      let al0 := o0
    }
    revert er0();
    s3.push("\x32");
  }
  function f5(bytes32 i0,C0.St0 memory i1,address i2) public virtual   returns(int176 o0)
  {
    require(s0, string(bytes("0000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffff")));
    i1.el0 &= bytes15(bytes23(0x8aab9219d38251f013f5a2a9e51474a60b0772b72473d8));
  }
}
function f6(address i0,bytes memory i1,bool[2] memory i2)     returns(C0.St0 memory o0,int256 o1,C0.St0[] memory o2)
{
  assert(i2[1]);
  o0.el0 = bytes15(0xffffffffffffffffffffffffffffff);
}
// ----
// Warning 3149: (su0.sol:429-503): The result type of the exponentiation operation is equal to the type of the first operand (int32) ignoring the (larger) type of the second operand (uint144) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:509-632): The result type of the exponentiation operation is equal to the type of the first operand (uint112) ignoring the (larger) type of the second operand (uint224) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:428-633): The result type of the exponentiation operation is equal to the type of the first operand (int32) ignoring the (larger) type of the second operand (uint112) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:852-875): The result type of the exponentiation operation is equal to the type of the first operand (int192) ignoring the (larger) type of the second operand (uint208) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:848-954): The result type of the exponentiation operation is equal to the type of the first operand (int192) ignoring the (larger) type of the second operand (uint208) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:846-1011): The result type of the exponentiation operation is equal to the type of the first operand (int192) ignoring the (larger) type of the second operand (uint224) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:1381-1518): The result type of the exponentiation operation is equal to the type of the first operand (uint168) ignoring the (larger) type of the second operand (uint200) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:1380-1593): The result type of the exponentiation operation is equal to the type of the first operand (uint168) ignoring the (larger) type of the second operand (uint200) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:294-368): Unreachable code.
// Warning 5740: (su0.sol:3045-3099): Unreachable code.
// Warning 5740: (su0.sol:3267-3282): Unreachable code.
// Warning 6133: (su0.sol:294-368): Statement has no effect.
// Warning 5667: (su0.sol:647-657): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:658-665): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:666-682): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:742-758): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:780-790): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2847-2863): Unused local variable.
// Warning 5667: (su0.sol:3302-3312): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3330-3340): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3367-3376): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3596-3606): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3607-3622): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3671-3680): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3681-3699): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:46-114): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:397-709): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:712-817): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:1115-1180): Function state mutability can be restricted to view
// Warning 2018: (su0.sol:3584-3775): Function state mutability can be restricted to pure
// CodeGenerationError 1284: Some immutables were read from but never assigned, possibly because of optimization.
