
==== Source: su0.sol ====
contract C0 {
  modifier m0() 
  {
    while (false)
    {
      assembly
      {
        invalid()
      }
      _;
    }
  }
  function f0() external virtual m0()  returns(uint32 o0,int104 o1)
  {
    revert("ffffffffffffffffffffffffffffffffff0000000000000000");
    return (uint32(2282905258), int104(0));
  }
  int96   s0;
  bool  public s1 = true;
  constructor(int96 i0)   {
    s0 *= int96(34108735452095124075038922420);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000");
      for(      int120 l2 = int120((int120(0) / int120(664613997892457936451903530140172287)));
;
address(this))
      {
        continue;
      }
      function (int112, uint176) external   returns (bytes1) l3;
      if (true)
      {
        if ((true && true))
        {
        }
        else if (false)
        {
        }
        else if (true)
        {
          s0 *= int96(((int96(13764136290952478581556210528) + int96(-13188866250012121236693032074)) / int96(((int96(1775417292114488283047883525) ** uint128(uint128(340282366920938463463374607431768211455))) / int96(22275520000062156076469702266)))));
        }
      }
      else
      {
      }
    }
  }
  fallback() external   
  {
    uint72 l0 = (~((((~(uint72(0))) - (uint72(4722366482869645213695) | uint72(0))) ^ uint72(4722366482869645213695))));
  }
  event ev0(uint176[]  ep0);
  modifier m1(int56 i0) 
  {
    _;
  }
  error er0(address payable ep0);
}
type T0 is int128;
struct St0 {
  string[1] el0;
  int240 el1;
  int208 el2;
  int136 el3;
}
pragma solidity >= 0.0.0;
uint88 constant cons0 = (((((~((uint88(0) * uint88(0)))) & uint88(309485009821345068724781055)) % uint88(309485009821345068724781055)) ^ uint88(0)) ^ uint88(309485009821345068724781055));
error er1();
function f2(bytes24 i0)    
{
  if (false)
  {
  }
}
// ====
// ----
