
==== Source: su0.sol ====
library L0 {
  type T0 is bool;
  modifier m0(uint16 i0,L0.T0 i1) 
  {
    revert(string(bytes("1d0e13b644ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")));
    _;
  }
  error er0();
  event ev0();
  event ev1(bytes12 indexed ep0, L0.T0  ep1) anonymous;
  using L0 for *;
  modifier m1(address payable i0,uint168 i1) 
  {
    _;
  }
  error er1();
}
struct St0 {
  bytes11 el0;
  mapping(uint48 => bytes27)[] el1;
}
contract C0 {
  modifier m2() 
  {
    _;
  }
  fallback() external virtual  payable
  {
    if (true)
    {
    }
    (bool l0) = payable(this).send(13375511391111516926);
    (l0) = ((false ? (true || false) : l0));
  }
  uint152   s0;
  constructor(uint152 i0)   {
    s0 += ((((uint152(0) | (uint152(0) - uint152(5708990770823839524233143877797980545530986495))) & uint152(5088797400796846613979563214913702576727694186)) | uint152(0)) & uint152(4624867677439131309324899942615509627609733953));
    unchecked {
      revert L0.er1();
      (bool l0, bytes memory l1) = payable(this).call{value: 1701161078963179282}("");
    }
  }
  event ev2(bool  ep0, uint208  ep1);
  modifier m3(bytes[] memory i0) 
  {
    bool l0 = ((true || ((bytes8(0x0a04f46686991583) < bytes8(0x28d7f020944e9b45)) && false)) ? true : false);
    _;
  }
  event ev3();
  function f1() internal    returns(int96 o0)
  {
    (o0) = ((int96((((((int96(0) & int96(39614081257132168796771975167)) | int96(39614081257132168796771975167)) ^ int96(0)) % int96(0)) / int96(0))) * int96(-10066269198955912708391099469)));
  }
  error er2();
  struct St1 {
    mapping(bool => uint160) el0;
    int232 el1;
    mapping(L0.T0 => address) el2;
    L0.T0[2] el3;
  }
  uint8 public constant cons0 = ((((((uint8(0) >> uint120(uint120(161591973281162597340844552186187944))) * uint8(210)) - uint8(255)) * uint8(58)) & uint8(255)) ^ uint8(0));
}
function f2(uint96 i0,bytes7 i1)     returns(L0.T0[2] memory o0)
{
}
pragma solidity >= 0.0.0;
using L0 for uint;
// ====
// ----
