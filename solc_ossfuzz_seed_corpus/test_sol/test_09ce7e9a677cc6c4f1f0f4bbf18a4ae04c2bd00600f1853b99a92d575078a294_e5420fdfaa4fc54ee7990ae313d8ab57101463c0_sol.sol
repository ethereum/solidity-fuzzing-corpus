
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() internal virtual    returns(function (address[1] memory, address payable) external   returns (bool, uint144, address) o0,function (function (address, bool, uint208) external  , function (bool, function (bytes3, uint136) external   returns (uint8, int176, uint24), bool) external   returns (bool)) external   o1,uint144 o2)  {
    do
    {
      o2 = (((((uint144(1015304670587218357883014222296934712148703) + uint144(0)) + uint144(0)) & uint144(0)) ** uint80(uint80(657471900606942969317754))) ^ uint144(21662565911975004729095382308418191103418129));
      assert(o2 == (((((uint144(1015304670587218357883014222296934712148703) + uint144(0)) + uint144(0)) & uint144(0)) ** uint80(uint80(657471900606942969317754))) ^ uint144(21662565911975004729095382308418191103418129)));
      continue;
    }
    while (true);
    return (o0, o1, uint144(0));
  }

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f1(bytes calldata i0) public virtual  payable  returns(function () external   o0,bytes1[][7] memory o1,function () external   o2)  {
    return (o0, (true ? [new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1)] : [new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1), new bytes1[](1)]), o2);
  }
  bool   s0;
  constructor(bool i0)   {
    s0 = false;
    unchecked {
    }
  }
  event ev0(uint88 indexed ep0, bytes11  ep1);
}

==== Source: su1.sol ====
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
function f2()      returns(function (bool, bytes10, uint184) external   returns (address payable) o0,bytes1 o1){
  assert(true);
}
pragma solidity >= 0.0.0;
// ====
// ----
