
==== Source: su0.sol ====
struct St0 {
  address payable el0;
  bytes29 el1;
  string el2;
  uint248 el3;
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   payable
  {
    int248 l0 = (int248(((~(((~((~(int248(16575563597085827220595666415193607562176636749474917416834436447763573769))))) - int248(-128667693600694897571536756122892542685603216770114549795640284287706261680)))) / int248(0))) & int248(-219849690304935980293589301836461195743323213762613216591312796869941311475));
    (l0) = (((int248(-68140234158186531354908008360106486963841508587963224799062802730856715565) ^ int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) % (int248(0) & int248(-67030820421038697905136358399513745146000981284470926440189200262145340755))));
    assert(l0 == ((int248(-68140234158186531354908008360106486963841508587963224799062802730856715565) ^ int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) % (int248(0) & int248(-67030820421038697905136358399513745146000981284470926440189200262145340755))));
  }
  int24   s0 = int24(8388607);
  function f1(int24 i0) external   payable returns(int200 o0,int8 o1)
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    int24  l2 = s0;
    int24  l3 = l2;
    assert(l3 == s0);
  }
  event ev0();
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
