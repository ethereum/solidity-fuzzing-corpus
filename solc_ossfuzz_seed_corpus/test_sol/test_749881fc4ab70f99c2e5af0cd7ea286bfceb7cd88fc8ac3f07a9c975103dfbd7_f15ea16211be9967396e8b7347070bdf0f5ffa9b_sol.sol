
==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
    if (true)
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 13550998003283421435}("");
    }
    require(true);
    do
    {
      break;
    }
    while (false);
  }
  function f1() external   payable   {
    function () internal   returns (address, int232) l0;
  }
  int176   s0;
  uint240 immutable  s1;
  bool   s2 = true;
  uint160  public s3;
  constructor(int176 i0,uint240 i1,uint160 i2)   {
    s0 += ((-((((-(int32(2147483647))) + int32(1463278415)) ^ int176(-25417511796409635513636299057999971411137774425192149)))) - int176(25010377371754617462102416266492190805967172381742883));
    s1 = uint240(1766847064778384329583297500742918515827483896875618958121606201292619775);
    s3 += (uint160(0) % ((true ? (uint160(1461501637330902918203684832716283019655932542975) * uint160(380901801772266679773531724204232303998990705249)) : uint160(1461501637330902918203684832716283019655932542975)) >> uint48(uint48(37897673463760))));
    unchecked {
    }
  }
  function f3(uint240 i0,bool i1) public      {
    (bool l0) = payable(this).send(0);
    return;
  }
  function f4() public virtual  payable   {
  }
}
struct St0 {
  uint208 el0;
  function (bytes[9] memory, bool, int112) external   el1;
}
struct St1 {
  St0 el0;
  string el1;
  bytes17 el2;
}
pragma solidity >= 0.0.0;
function f2(address i0) pure suffix  returns(bool o0)
{
  (o0) = (false);
  assert(o0 == false);
}

==== Source: su1.sol ====
struct St2 {
  uint168 el0;
  bytes30[] el1;
}
type T0 is uint168;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function f5(bool i0)      returns(int240 o0){
}
pragma solidity >= 0.0.0;
// ====
// ----
