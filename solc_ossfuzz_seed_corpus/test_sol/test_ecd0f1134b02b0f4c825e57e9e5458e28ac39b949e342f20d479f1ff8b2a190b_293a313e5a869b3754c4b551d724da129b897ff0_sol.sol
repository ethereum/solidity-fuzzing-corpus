
==== Source: su0.sol ====
library L0 {
  function f0(string memory i0,uint80 i1) external   
  {
  }
  event ev0();
}
contract C0 {
  using L0 for *;

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f1(address payable i0,bytes calldata i1) public virtual  payable
  {
    assert(true);
  }
  uint200 immutable public s0;
  int120  public s1 = int120(664613997892457936451903530140172287);
  int176  public s2;
  constructor(uint200 i0,int176 i1) payable  {
    s0 = uint200((((uint200(1606938044258990275541962092341162602522202993782792835301375) << uint200(uint200(((uint200(1606938044258990275541962092341162602522202993782792835301375) * uint200(1606938044258990275541962092341162602522202993782792835301375)) / uint200(1470860759991235967023754098447572661583683418638573853318081))))) & uint200(1606938044258990275541962092341162602522202993782792835301375)) / uint200(283024796042315978999391201631842910600321807832727334378843)));
    s2 = (int176(47890485652059026823698344598447161988085597568237567) & int176(47890485652059026823698344598447161988085597568237567));
    unchecked {
      uint200  l0 = s0;
      uint200  l1 = l0;
      assert(l1 == s0);
      int176  l2 = s2;
      int176  l3 = l2;
      assert(l3 == s2);
      uint200  l4 = s0;
      uint200  l5 = l4;
      assert(l5 == s0);
      uint200  l6 = s0;
      uint200  l7 = l6;
      assert(l7 == s0);
      uint200  l8 = s0;
      uint200  l9 = l8;
      assert(l9 == s0);
    }
  }
}
pragma solidity >= 0.0.0;
using L0 for string;
using L0 for string;
error er0();

==== Source: su1.sol ====
library L1 {
  function f2(function (uint104[8] memory) external   i0) external   
  {
    function (bytes memory, bool) internal   returns (uint88[8][3][][] memory, function (bool, address payable, address) internal  , bytes18) l0;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
