
==== Source: su0.sol ====
function f0()     returns(function (uint32) external   o0)
{
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L0 {
  function f1(address payable i0) external   
  {
    function () external   returns (address) l0;
    bool l1 = (payable(address(0x0000000000000000000000000000000000000004)) <= payable(address(0x0000000000000000000000000000000000000001)));
    (address l2) = l0();
    unchecked {
      function (bytes7[][][][][5][] memory) internal   returns (int88, bool) l3;
      try l0() returns (address l4)
      {
        (i0) = (payable(address(0x0000000000000000000000000000000000000004)));
        assert(i0 == payable(address(0x0000000000000000000000000000000000000004)));
      }
      catch
      {
      }
      catch Error(string memory l5)
      {
      }
      catch Panic(uint256 l6)
      {
      }
      uint144 l7 = uint144(0);
      assembly
      {
        {
          pop(i0)
          i0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
        }
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(13222047939310624638143790118441235315420321410765608081433122071858293290143, 11)) { yulinit0 := add(yulinit0, 1) }
        {
        }
        let al0 := 43231453846047185821684102353017302350181488555840199006644667838431832840426
      }
    }
  }
}
pragma solidity >= 0.0.0;
using L0 for address payable;
// ====
// ----
