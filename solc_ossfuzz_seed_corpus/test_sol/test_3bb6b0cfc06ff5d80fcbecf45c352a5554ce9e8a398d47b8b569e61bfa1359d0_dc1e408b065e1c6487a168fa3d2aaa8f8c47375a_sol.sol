
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    address el0;
    function (function (function () external   returns (function (address payable) external  ), uint24, address) external   returns (uint216, function (bool[6] memory, bool, bytes22) external  ), bytes18) external   returns (uint168[7][] memory, int224, address payable) el1;
    mapping(address => uint96) el2;
  }
  receive() external   payable
  {
    bytes memory l0 = bytes(string("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    bool l1 = false;
  }
  address   s0 = address(this);
  C0.St0  public s1;
  mapping(bool => bool)   s2;
  constructor() payable  {
    s2[true] = true;
    unchecked {
      delete s1.el1;
      s0 = (((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) ^ int256(0)) == (int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) - int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) ? address(this) : address(this));
      assert(s0 == (((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) ^ int256(0)) == (int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) - int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) ? address(this) : address(this)));
      address  l0 = s0;
      address  l1 = l0;
      assert(l1 == s0);
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
