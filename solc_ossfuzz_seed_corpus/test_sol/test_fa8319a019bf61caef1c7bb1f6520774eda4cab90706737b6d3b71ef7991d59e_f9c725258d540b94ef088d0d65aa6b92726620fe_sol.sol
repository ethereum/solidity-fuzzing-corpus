
==== Source: su0.sol ====
contract C0 {
  bytes1  public s0;
  constructor(bytes1 i0)   {
    s0 = (~(bytes1(bytes9(0x895eda82523b0db13c))));
    {
      if (i0 < bytes1(0x69))
      {
        if (i0 < bytes1(bytes6(0x000000000000)))
        {
          delete s0;
        }
      }
    }
  }
  struct St0 {
    mapping(uint40 => bool)[] el0;
    function () external   returns (bytes21)[] el1;
    bytes5 el2;
  }
  struct St1 {
    int152 el0;
  }
  receive() external virtual  payable
  {
    return;
  }
  function f1(bytes1 i0) internal virtual    returns(bytes30 o0,bytes27 o1)  {
    revert(string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")));
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  function f2(bool i0,int256 i1) private      {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  fallback() external   
  {
    for(;
;
payable(address(this)))
    {
      return;
    }
    int240 l0 = (-(int240((int240(883423532389192164791648750371459257913741948437809479060803100646309887) / int240(860367751151674296388154870918188958201857441455586727848479150895024085)))));
    if (false)
    {
    }
  }
  int224   s1 = int224(0);
  int80   s2;
  constructor(int80 i0) payable  {
    s2 %= (true ? (int80(0) ** uint112((~(uint112(0))))) : int80(0));
    unchecked {
    }
  }
  error er0();
  receive() external virtual  payable
  {
    (bool l0) = payable(this).send(0);
    for(uint solinit0 = 0; solinit0 < ((((((~(uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / uint256(93818085922283817514783092868732120005105448573730953602221997459859831511707))))) ^ uint256(35965686289985041208866307283048111601682229716979122771579925118730043622943)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(61914217340334467855321466933566546007800659582285438086445782991684640296226)) % 11); solinit0++)
    {
      (bool l1) = payable(this).send(1451174451014865456);
      return;
    }
    if ((((int48(140737488355327) ^ (int48(0) & int48(107223980547821))) & int48(-100569409691198)) <= int48(0)))
    {
      for(uint solinit1 = 0; solinit1 < (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % 11); solinit1++)
      {
        bytes22[] memory l2 = new bytes22[](9);
      }
    }
  }
}
bytes15 constant cons0 = bytes15(0xa7af1ca5600b6b92491b3141854ba4);
pragma solidity >= 0.0.0;
int232 constant cons1 = -811035485734669528259462125292299197047571024663840535578836839395618;
struct St2 {
  bytes21 el0;
  mapping(uint48 => mapping(bytes17 => int240)) el1;
  bytes19 el2;
  int32 el3;
}
// ====
// ----
