==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  type T0 is bytes17;
  address payable  public s0 = payable(address(this));
  int208  public s1;
  address payable   s2 = payable(address(this));
  constructor(int208 i0)   {
    s1 ^= int208(0);
    {
    }
  }
  struct St0 {
    bool el0;
    mapping(int8 => uint208) el1;
    uint224 el2;
    uint48 el3;
  }
  function f0(int208 i0,address payable i1) external     returns(uint152 o0)  {
  }
  receive() external   payable
  {
    try this.f0(((int208(0) * int208(-196403259746511469342270777205224300788821279891024608759902109)) ** uint104(((~(uint104(20282409603651670423947251286015))) % uint104(0)))),(true ? payable(address(this)) : payable(address(bytes20(address(0x0000000000000000000000000000000000000000)))))) returns (uint152 l0)
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    catch
    {
      address payable  l1 = s0;
      address payable  l2 = l1;
      assert(l2 == s0);
    }
    catch Panic(uint256 l3)
    {
      if (0x0000000000000000000000000000000000000001 f2 /*suffix expr*/)
      {
        if (true)
        {
          try this.f0((int208(0) - (((int208(11426342201301728422914970793943802067948735732911358011118163) & int208(205688069665150755269371147819668813122841983204197482918576127)) * int208(19090163224260902618421843566188563816544487532574313364518967)) + int208(0))),payable(address(this))) returns (uint152 l4)
          {
            try this.f0({i0: int208(205688069665150755269371147819668813122841983204197482918576127), i1: payable(address(this))}) returns (uint152 l5)
            {
            }
            catch
            {
              return;
            }
            catch Panic(uint256 l6)
            {
            }
          }
          catch
          {
            revert(false f3 /*suffix expr*/);
          }
        }
        else if (true)
        {
        }
      }
      else if (false)
      {
      }
    }
  }
}
pragma solidity >= 0.0.0;
function f4()     {
}
function f2(address i0) pure suffix  returns(bool o0)
{
}
function f3(bool i0) pure suffix  returns(string memory o0)
{
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bytes26 constant cons0 = bytes26(0x0000000000000000000000000000000000000000000000000000);
struct St1 {
  bytes32 el0;
}
struct St2 {
  address payable el0;
  int120 el1;
  bool el2;
}
// ----
// Warning 5667: (su0.sol:175-184): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:748-758): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1008-1018): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1440-1450): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1604-1614): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1736-1746): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
