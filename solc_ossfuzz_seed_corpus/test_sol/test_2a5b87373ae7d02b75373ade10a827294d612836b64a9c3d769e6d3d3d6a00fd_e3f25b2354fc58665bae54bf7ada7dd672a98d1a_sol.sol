==== Source:  ====

==== Source: su0.sol ====
function f0()     {
}
struct St0 {
  address el0;
  uint16 el1;
  bytes el2;
  int128 el3;
}
struct St1 {
  mapping(int240 => address) el0;
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    if (true)
    {
      for(uint solinit0 = 0; solinit0 < (((uint256(((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(0)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) >> uint88(uint88(309485009821345068724781055))) << uint128(uint128(41743481388210353168194543024706062265))) % 11); solinit0++)
      {
        if (true)
        {
        }
        else
        {
          if (true)
          {
            continue;
          }
          return;
        }
        uint64(7283338651389171920);
        if (true)
        {
          continue;
        }
        else if (true)
        {
          if (true)
          {
          }
          continue;
        }
      }
    }
  }
  type T0 is address;
  function f2() private     returns(address o0)  {
  }
  mapping(bytes5 => uint24)   s0;
  mapping(bytes5 => bytes)  public s1;
  address  public s2;
  St1   s3;
  constructor(address i0)   {
    s2 = address(this);
    s0[bytes5(0xffffffffff)] = uint24(16777215);
    s1[-29 f3 /*suffix expr*/] = abi.encodePacked(int240(((((int72(2361183241434822606847) - int72(2361183241434822606847)) - int72(-570328215563182708096)) | int72(-711660645422166796564)) ** uint176(uint176(0)))), address(address(this)), bool(true));
    unchecked {
    }
  }
}
function f3(int8 i0) pure suffix  returns(bytes5 o0)
{
  if (i0 >= int8(0))
  {
    ((false ? uint128(340282366920938463463374607431768211455) : ((uint128(184845703693481583967822189945497240688) - uint128(14389092694516765042742838081579644542)) * uint128(0))) - uint128(340282366920938463463374607431768211455));
  }
  else
  {
    if (i0 > int8(0))
    {
      for(      function (bool, int128, C0.T0) external   returns (address payable, bytes24) l0;
true;
string("This is a really long string that must ideally be random but is currently hard coded"))
      {
      }
    }
  }
}

==== Source: su1.sol ====
contract C1 {
  receive() external virtual  payable
  {
  }
  function f5(address payable i0,function (bool, bool) external   i1) public     returns(bool o0)  {
  }
  mapping(int176 => address)  public s4;
  uint24   s5 = uint24(16777215);
  uint48   s6;
  mapping(uint56 => uint104[])  public s7;
  constructor(uint48 i0) payable  {
    s6 /= (false ? (~(uint48((uint48(220974724484978) / uint48(66439737823309))))) : uint48(281474976710655));
    s4[int176(47890485652059026823698344598447161988085597568237567)] = address(this);
    unchecked {
    }
  }
  function f6(uint8 i0,address i1) external virtual  payable  returns(function (function () external   returns (bytes memory, uint80, uint80[] memory)) external   returns (uint32) o0,uint256 o1)  {
  }
}
pragma solidity >= 0.0.0;
struct St2 {
  int176 el0;
  uint112 el1;
}
// ----
// TypeError 4907: (su0.sol:1467-1473): Built-in unary operator - cannot be applied to type bytes5.
// Warning 3149: (su0.sol:1518-1672): The result type of the exponentiation operation is equal to the type of the first operand (int72) ignoring the (larger) type of the second operand (uint176) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
