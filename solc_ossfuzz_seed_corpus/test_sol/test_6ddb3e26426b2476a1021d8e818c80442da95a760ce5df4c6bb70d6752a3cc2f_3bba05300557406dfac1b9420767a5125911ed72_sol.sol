
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  
  {
    assembly
    {
      {
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(0, 11)) { yulinit0 := add(yulinit0, 1) }
        {
          switch 18601256131395417198407546513268386510663094774258502433262934850044216666361
          default
          {
            break
          }
        }
      }
      for 
      { let yulinit1 := 0 } lt(yulinit1, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 11)) { yulinit1 := add(yulinit1, 1) }
      {
        break
      }
    }
    assembly
    {
      if 0
      {
        {
        }
        {
          if sload(sload(115792089237316195423570985008687907853269984665640564039457584007913129639935))
          {
          }
        }
        switch 71974299365958554662163856943998568371067603367983567219722768812995891390098
        case 17404219672002208048644792705803308785083041578229811557362343862204487747812
        {
        }
      }
      stop()
    }
    function () internal   returns (bytes27, bytes20, function (function (uint240, address[6] memory) internal   returns (bool, bool, address payable), int96) internal   returns (bool, bytes8, int120)) l0;
  }
  uint176   s0;
  uint144   s1 = uint144(6844822019023328152838795661664406747609119);
  uint80   s2;
  constructor(uint176 i0,uint80 i1) payable  {
    s0 >>= uint56(72057594037927935);
    s2 /= ((~(((uint80(0) - uint80(0)) ^ uint80(1208925819614629174706175)))) - uint80(364926696241203972961816));
    unchecked {
    }
  }
}
address constant cons0 = 0x0000000000000000000000000000000000000000;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
