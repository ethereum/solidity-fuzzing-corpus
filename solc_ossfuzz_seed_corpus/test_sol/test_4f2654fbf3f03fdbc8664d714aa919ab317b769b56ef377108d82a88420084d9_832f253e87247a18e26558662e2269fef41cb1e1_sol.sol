
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    bytes4 l0 = (((~((bytes3(0x265a63) | bytes3(0xffffff)))) | bytes4(0x00000000)) ^ bytes4(0xffffffff));
    bool l1 = (true ? false : ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) >> uint240(uint240(858076739129471775089311913278769782658906677284109277168009341406127680))) != uint256(0)));
    function (address) internal   returns (address) l2;
  }
  function f1(address payable i0) private    returns(bytes24 o0,string memory o1)
  {
  }
  receive() external   payable
  {
    assembly
    {
      codecopy(add(0x80, mod(calldataload(mod(5344326725409890588260065043090364544904756229742022846688986599724543752454, calldatasize())), 1024)), 110693107456472768219146983030567445540572106787498763094508232022319010326412, mod(86149746671526170381427172759737962608627118265683433411278920368290779595051, 1024))
      let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      function af0(ai0, ai1, ai2, ai3, ai4) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12, ao13
      {
        calldatacopy(add(0x80, mod(0, 1024)), ai1, mod(blockhash(115792089237316195423570985008687907853269984665640564039457584007913129639935), 1024))
        function af1(ai5, ai6, ai7, ai8, ai9, ai10, ai11, ai12, ai13) -> ao14, ao15, ao16, ao17, ao18, ao19, ao20, ao21, ao22, ao23, ao24, ao25, ao26, ao27, ao28, ao29, ao30
        {
          for 
          { let yulinit0 := 0 } lt(yulinit0, mod(sar(ai5, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 11)) { yulinit0 := add(yulinit0, 1) }
          {
            let al1 := 68636258041975712164453643361164247847701032027771447589160917849447319732658
            if mload(add(0x80, mod(calldataload(mod(5344326725409890588260065043090364544904756229742022846688986599724543752454, calldatasize())), 1024)))
            {
              for 
              {
              }
              call(ai6, 70948044689760119610295825483433291187696544573116672111766111207993567009540, 115792089237316195423570985008687907853269984665640564039457584007913129639935, add(0x80, mod(calldataload(mod(5344326725409890588260065043090364544904756229742022846688986599724543752454, calldatasize())), 1024)), 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 107098912268628014075987366532243687301365796043506304908201171725396111485744)
              {
              }
              {
                for 
                { let yulinit1 := 0 } lt(yulinit1, mod(ai10, 11)) { yulinit1 := add(yulinit1, 1) }
                {
                  leave
                }
                return(ai10, 99700807378610377346648817541902420913531669605016536404692846680524735150290)
              }
              switch 0
              case 61521758006115326169869104851329271045419683507909513603044271389889780976937
              {
                ao22 := 0
                ao29 := ai13
                let al2 := 37632251468887104245211889613676530204449846221422159008059762181854831423218
              }
            }
            leave
          }
        }
        let al3 := ai2
        ao5 := 19946435771197893653258493378730082142421352610093317456445263387776808730565
      }
    }
  }
  uint32  public s0;
  constructor(uint32 i0)   {
    s0 ^= uint32(0);
    {
      uint32  l0 = s0;
      uint32  l1 = l0;
      assert(l1 == s0);
      unchecked {
        uint32  l2 = s0;
        uint32  l3 = l2;
        assert(l3 == s0);
        uint32  l4 = s0;
        uint32  l5 = l4;
        assert(l5 == s0);
      }
      uint32  l6 = s0;
      uint32  l7 = l6;
      assert(l7 == s0);
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
