
==== Source: su0.sol ====
struct St0 {
  bytes1 el0;
  bytes5 el1;
  bytes10 el2;
  int200 el3;
}
error er0();
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  modifier m0() 
  {
    uint144 l0 = (~(((uint144(8812976714387626316602727724495008777370646) + uint144(((uint144(21643183567980393435798651951676862450217869) ^ uint144(2128103427767411498510716803021531046964260)) / uint144(0)))) >> uint240(uint240(0)))));
    _;
  }
  fallback() external virtual m0() m0() 
  {
    bytes3 l0 = bytes3(0xffffff);
    unchecked {
    }
    for(    uint8 l1 = (uint8(255) << uint8(((uint8(((uint8(251) - uint8(255)) / uint8(61))) + uint8(26)) + uint8(0))));
false;
)
    {
    }
  }
  address   s0 = address(this);
  uint96 immutable  s1;
  constructor(uint96 i0) payable  {
    s1 = (uint96(79228162514264337593543950335) - (uint96(1944403215822205089714380951) * (~((uint96(0) * uint96(79228162514264337593543950335))))));
    { }
  }
}
contract C1 is C0 {
  int56  public s2 = int56(0);
  constructor()  C0((uint96((int96(0) & ((int96(18760106102526978802139228209) * int96(13465460678349843805601163231)) * int96(-9034425896743306252864624247)))) << uint184(uint184(21964883114895501770059868490930574028818978578609718620))))
  {
    {
      address  l0 = s0;
      address  l1 = l0;
      assert(l1 == s0);
      (bool l2, bytes memory l3) = address(this).call(bytes("c137525920b53785fc29770142719364aa1cccacce483c0d7d4a8ec006"));
      address  l4 = s0;
      address  l5 = l4;
      assert(l5 == s0);
      (bool l6, bytes memory l7) = address(this).call(abi.encodePacked(int104(int104(2261738924731008571733849723268)), uint168(uint168(205862225959224308066782531505159794842844038362153)), uint48(((true ? uint48(281474976710655) : uint48(281474976710655)) - uint48(281474976710655)))));
    }
  }
  fallback() external override m0() 
  {
    uint96  l0 = s1;
    uint96  l1 = l0;
    assert(l1 == s1);
  }
}
// ====
// ----
