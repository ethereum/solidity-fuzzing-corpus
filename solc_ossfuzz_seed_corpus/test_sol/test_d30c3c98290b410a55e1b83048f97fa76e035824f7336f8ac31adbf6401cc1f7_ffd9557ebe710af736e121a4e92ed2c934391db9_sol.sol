
==== Source: su0.sol ====
contract C0 {
  event ev0(address indexed ep0, bool  ep1) anonymous;
  function f0(bytes21 i0) public virtual  
  {
    emit ev0(address(this), ((uint72(((uint72(0) >> uint128(uint128(340282366920938463463374607431768211455))) / uint72(0))) * uint72(0)) == uint72(4722366482869645213695)));
    for(    bool l0 = false;
false;
address(this))
    {
    }
    assembly
    {
      return(115792089237316195423570985008687907853269984665640564039457584007913129639935, i0)
    }
  }
  modifier m0(int48 i0,address payable i1) 
  {
    _;
  }
  int48  public s0;
  bool   s1;
  bool  public s2 = false;
  constructor(int48 i0,bool i1) payable  {
    s0 %= int48(-110771058614753);
    s1 = false;
    unchecked {
      {
        {
          (bool l0, bytes memory l1) = address(this).delegatecall(abi.encodeWithSelector(this.f0.selector, bytes21(0x000000000000000000000000000000000000000000)));
        }
      }
    }
  }
  function f1(address payable i0) public  m0((int48(140737488355327) % int48(0)),payable(address(this))) payable
  {
    emit ev0(address(this), (true && true));
  }
  struct St0 {
    bytes27 el0;
    bytes[] el1;
  }
  int168 public constant cons0 = ((int168((int168(-25348847794229613474507409074102880180311071035554) / ((int168(-61901229062662940963388059008409753698463393816403) ** uint8(uint8(255))) - int168(-179884929614670946825049744518465103919113495427401)))) + int168(-72735043591842579706750174696689730724497253348013)) + int168(0));
  event ev1(C0.St0  ep0);
  type T0 is uint184;
}
struct St1 {
  bytes22 el0;
  C0.T0[1] el1;
  address payable el2;
}
error er0();
bytes11 constant cons1 = (bytes11(0xffffffffffffffffffffff) ^ (((bytes11(0xffffffffffffffffffffff) & bytes11(0x31c9440c4493be41351d03)) ^ bytes11(0x89ace66397e28f6c5f787a)) | bytes11(0x24d73b017d9bc268069f8a)));
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St2 {
  bytes el0;
  address payable el1;
  address el2;
  bool el3;
}
pragma solidity >= 0.0.0;
type T1 is address;
// ====
// ----
