
==== Source: su0.sol ====
function f0(bytes11 i0)     returns(uint256 o0)
{
  int192[][7][5] memory l0 = (true ? [[new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)]] : [[new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)], [new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2), new int192[](2)]]);
  require((true ? ((uint136(0) * (~(uint136(24249787801124987190443201669386345503655)))) == uint136(0)) : false), string(bytes("3afbecc1702635ffffffffffff")));
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L0 {
  modifier m0() 
  {
    assembly
    {
      return(17922367018152315979285558057749965976801832642478563577070742618986789950065, 0)
    }
    _;
  }
  function f1(function (bytes9, bool) external   i0) internal  m0()  returns(address payable o0,uint200 o1)
  {
  }
  error er0();
}
struct St0 {
  int8 el0;
  function (int48, int160, bool) external   returns (bytes30, uint216) el1;
  uint48 el2;
  int72 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
