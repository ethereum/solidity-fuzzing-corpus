==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    bool l2 = false;
    function (address payable, bytes memory) external   returns (int152) l3;
  }
  int168   s0 = int168(0);
  address   s1 = address(this);
  int232 immutable  s2;
  bytes  public s3;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  constructor(int232 i0,bytes memory i1) payable  {
    s2 = ((int232((int232(3450873173395281893717377931138512726225554486085193277581262111899647) / (int232(0) + int232(-3442423291068106197351679644924060028449002578978169380368077579127280)))) - int232(0)) & int232(-514087078868673635734113880980465787693178960498068071052806988771864));
    s3 = bytes("ffffffffffffffff000000000000");
    unchecked {
      (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    }
  }
  fallback() external virtual  
  {
  }
  event ev0(int256  ep0) anonymous;
}
contract C1 {
  bytes   s4;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint248   s5;
  constructor(bytes memory i0,uint248 i1)   {
    s4 = ((address(this) == address(this)) ? bytes("0000000000000000000000000000000000000000000000000000") : bytes("000000000000000000000000000000ffffffffffffffffff"));
    s5 >>= uint248(0);
    {
      s5 &= uint248(0);
      uint248  l0 = s5;
      uint248  l1 = l0;
      assert(l1 == s5);
    }
  }

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(uint248 i0,uint248 i1,bytes calldata i2) external virtual  
  {
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
function f3()     returns(address o0)
{
  uint56 l0 = uint56(0);
  bytes3 l1 = bytes3(0x529fe9);
}
struct St0 {
  bool el0;
  bool el1;
}
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:54-61): Unused local variable.
// Warning 2072: (su0.sol:63-78): Unused local variable.
// Warning 2072: (su0.sol:120-127): Unused local variable.
// Warning 2072: (su0.sol:141-212): Unused local variable.
// Warning 5667: (su0.sol:494-503): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:504-519): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:895-902): Unused local variable.
// Warning 2072: (su0.sol:904-919): Unused local variable.
// Warning 5667: (su0.sol:1262-1277): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1278-1288): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:26-36): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:42-51): Unused local variable.
// Warning 2072: (su1.sol:67-76): Unused local variable.
// Warning 2018: (su1.sol:0-98): Function state mutability can be restricted to pure
