==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  function f0(bytes6 i0) external virtual  
  {
  }
  int248  public s0;
  constructor(int248 i0)   {
    s0 -= (int248(80446977256676643338599548112780507243862880595017818999324110385645667161) & (((true ? int168(0) : int168(187072209578355573530071658587684226515959365500927)) + int168(-96539652173227273986675567555546985365622170601277)) | int168(187072209578355573530071658587684226515959365500927)));
    {
      address(bytes20(address(0x6B72BAD77dE0A2b37b2442509CadBc4352b1B04D)));
      int248  l0 = s0;
      int248  l1 = l0;
      assert(l1 == s0);
      int248  l2 = s0;
      int248  l3 = l2;
      assert(l3 == s0);
      (bool l4, bytes memory l5) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffcb46f725e748c648ed9ee5f5c9e8ca96a5412747172bf7"));
      (bool l6, bytes memory l7) = address(this).call(bytes.concat(bytes7(0xffffffffffffff), bytes16(0x00000000000000000000000000000000), (bytes15(0xffffffffffffffffffffffffffffff) | (bytes15(0xffffffffffffffffffffffffffffff) ^ bytes15(0xffffffffffffffffffffffffffffff)))));
      this.f0((~(bytes5(0x0000000000))));
    }
  }
}
library L0 {
  function f1() internal    returns(string memory o0)
  {
  }
  function f2(address payable i0) private   
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000003));
  }
}
library L1 {
  modifier m0(int224 i0) 
  {
    bool l0 = true;
    bool l1 = ((bytes4(0xffffffff) & bytes1(0x5a)) >= (bytes4(0xffffffff) | bytes4(0x41d40585)));
    _;
    int232 l2 = (int232(((int232((int232(3401702387153343754736799473421749270735841160332943083049371959574516) / int232(3450873173395281893717377931138512726225554486085193277581262111899647))) | int232(3450873173395281893717377931138512726225554486085193277581262111899647)) / int232(3450873173395281893717377931138512726225554486085193277581262111899647))) | int232(3450873173395281893717377931138512726225554486085193277581262111899647));
  }
}
contract C1 is C0 {
  receive() external   payable
  {
    int248  l0 = s0;
    int248  l1 = l0;
    assert(l1 == s0);
    int248  l2 = s0;
    int248  l3 = l2;
    assert(l3 == s0);
  }
  bool   s1 = false;
  int184   s2 = int184(0);
  int256  public s3 = int256(0);
  C0  public s4 = C0(address(this));
  constructor(int248 i0)  C0(int248(94355226503376758919795915662951968691131609857299018150208731633474172403))
  {
    s0 += (int248(((-(int16(((int16(0) ** uint112(uint112(4635827703481684277422438479549008))) / int16(0))))) / int248(102864696537338734162593028234976324043934027600185409372551308094840564398))) % int248(-188443977743813426433471722987071058372180305798694097638972528499438926661));
    unchecked {
      (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
      bool  l2 = s1;
      bool  l3 = l2;
      assert(l3 == s1);
      assert(true);
      assert((true ? false : true));
      C0  l4 = s4;
      C0  l5 = l4;
      assert(l5 == s4);
      {
        int184  l6 = s2;
        int184  l7 = l6;
        assert(l7 == s2);
      }
    }
  }
  using L1 for *;
  function f0(bytes6 i0) external virtual override  
  {
    C0  l0 = s4;
    C0  l1 = l0;
    assert(l1 == s4);
    int184  l2 = s2;
    int184  l3 = l2;
    assert(l3 == s2);
    bool  l4 = s1;
    bool  l5 = l4;
    assert(l5 == s1);
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 3149: (su1.sol:2422-2486): The result type of the exponentiation operation is equal to the type of the first operand (int16) ignoring the (larger) type of the second operand (uint112) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 6133: (su1.sol:435-504): Statement has no effect.
// Warning 5805: (su1.sol:1087-1091): "this" used in constructor. Note that external functions of a contract cannot be called while it is being constructed.
// Warning 5667: (su1.sol:101-110): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:653-660): Unused local variable.
// Warning 2072: (su1.sol:662-677): Unused local variable.
// Warning 2072: (su1.sol:813-820): Unused local variable.
// Warning 2072: (su1.sol:822-837): Unused local variable.
// Warning 5667: (su1.sol:1224-1242): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1263-1281): Unused local variable.
// Warning 5667: (su1.sol:2289-2298): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:2703-2710): Unused local variable.
// Warning 2072: (su1.sol:2712-2727): Unused local variable.
// Warning 5667: (su1.sol:3084-3093): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:1212-1349): Function state mutability can be restricted to pure
