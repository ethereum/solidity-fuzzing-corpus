
==== Source: su0.sol ====
contract C0 {
  uint160 immutable  s0 = uint160(0);
  bool  public s1 = false;
  bool  public s2 = true;
  struct St0 {
    bool el0;
    bytes3 el1;
    int72 el2;
  }
  struct St1 {
    bytes19 el0;
  }
  function f0(bool i0,bool i1) internal virtual     {
    if (i1)
    {
      return;
    }
    if (i0)
    {
      if (i0)
      {
      }
      else if (i0)
      {
      }
    }
    else if (i1)
    {
      if (i1)
      {
      }
      else
      {
        if (i0)
        {
        }
        else
        {
          (s1) = ((((((uint16(0) % uint16(0)) | uint16(0)) >> uint224(uint224(0))) <= uint16(0)) ? true : true));
          assert(s1 == (((((uint16(0) % uint16(0)) | uint16(0)) >> uint224(uint224(0))) <= uint16(0)) ? true : true));
        }
        if (i0)
        {
        }
        else
        {
          if (i0)
          {
          }
          else if (i0)
          {
            while (false)
            {
              return;
            }
          }
        }
      }
    }
  }
  fallback() external virtual  payable
  {
    (s1) = (true);
    assert(s1 == true);
  }
  receive() external virtual  payable
  {
  }
}
function f3(address i0)    pure suffix returns(bool o0){
  return (true);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St2 {
  uint176 el0;
  function (address) external   returns (bytes4) el1;
  uint168 el2;
}
pragma solidity >= 0.0.0;
contract C1 {
  function f4(address payable i0,function () external   returns (uint48, bytes18, bytes20) i1) external virtual    returns(bytes27 o0)  {
    return (bytes27(0x1c637383768d7a4d7092fdedd54970cc7849b82942f4acf0eae22b));
  }

	function compareMemoryAndCalldata(St2 memory v1, St2 calldata v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}  function f5(St2 memory i0) public virtual  payable  returns(int200 o0,bool o1)  {
    o0 &= int200(-384713618948043223324999259267309109836149156648255102791858);
  }
  address payable public constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
  St2   s3;

	function compareMemoryAndStorage(St2 memory v1, St2 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}  int192   s4;
  int88   s5;
  St2   s6;
  constructor(int192 i0,int88 i1)   {
    s4 %= (int192(3138550867693340381917894711603833208051177722232017256447) & (int192(0) + int192(969247311664988752195102079081187374752646132377308980534)));
    s5 %= ((-(hex"0000000000000000000000000000000000000000000000000000" f6 /*suffix expr*/)) - int88(154742504910672534362390527));
    unchecked {
    }
  }
}
function f7()     {
  revert(string("This is a really long string that must ideally be random but is currently hard coded"));
}
function f6(bytes26 i0) pure suffix  returns(int88 o0)
{
  require((bytes16(0xffffffffffffffffffffffffffffffff) <= (~(bytes16(0x00000000000000000000000000000000)))));
}
// ====
// ----
