
==== Source: su0.sol ====
contract C0 {
  int152   s0;
  uint8   s1 = uint8(0);
  constructor(int152 i0)   {
    s0 |= ((int152(353674117492505677205739109555160832593005180) ** uint192((((~(uint192(6277101735386680763835789423207666416102355444464034512895))) | uint192(0)) * uint192(486908207373388801403557319662245367142374635682379975060)))) + int152(2854495385411919762116571938898990272765493247));
    {
      {
        while (true)
        {
        }
        uint8  l0 = s1;
        uint8  l1 = l0;
        assert(l1 == s1);
      }
      revert(string("0000000000000000000000000000000000000000000000001623e40dc966006faa1730d09b"));
    }
  }
}
library L0 {
  error er0(bool ep0);
  error er1();
}
pragma solidity >= 0.0.0;
struct St0 {
  address el0;
  address payable[][3][][][][] el1;
  mapping(bytes28 => bool) el2;
  bytes el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L1 {
  error er2(uint104 ep0);
  function f0(address payable i0,bytes memory i1) internal    returns(uint56 o0,int136 o1)
  {
    bool[9] memory l0 = [false, false, false, false, false, false, true, true, false];
  }
}
using L1 for address payable;
// ====
// ----
