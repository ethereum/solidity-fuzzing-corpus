
==== Source: su0.sol ====
struct St0 {
  mapping(int80 => bytes27) el0;
  address[7][][] el1;
  int40 el2;
  bool el3;
}
pragma solidity >= 0.0.0;
struct St1 {
  bool el0;
  bytes30 el1;
  uint248[5][1][10][] el2;
  address el3;
}

==== Source: su1.sol ====
struct St2 {
  address payable el0;
  bool el1;
  int48 el2;
  uint40[7][10] el3;
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
    uint16 l0 = ((((uint16(0) + (uint16(48240) | uint16(50965))) + uint16(14648)) << uint256(uint256(26298927482518326358743156954366534807262479785662964081277217148961166082507))) | uint16(65535));
  }
  modifier m0(int184 i0) 
  {
    int120 l0 = int120(664613997892457936451903530140172287);
    address l1 = address(this);
    do
    {
      _;
    }
    while (false);
    string storage l2;
  }
  address   s0;
  uint208   s1 = uint208(99382812480757078971875785270623720141798825711061711618122784);
  uint112   s2;
  bool   s3 = false;
  constructor(address i0,uint112 i1)   {
    s0 = address(this);
    s2 -= ((((uint112(0) % (uint112(753626129682775324662541863919681) % uint112(5192296858534827628530496329220095))) + uint112(5192296858534827628530496329220095)) | uint112(573990479747611249527308025776158)) << uint104(uint104(20282409603651670423947251286015)));
    unchecked {
      uint112  l0 = s2;
      uint112  l1 = l0;
      assert(l1 == s2);
      bool  l2 = s3;
      bool  l3 = l2;
      assert(l3 == s3);
      address  l4 = s0;
      address  l5 = l4;
      assert(l5 == s0);
    }
  }
}
// ====
// ----
