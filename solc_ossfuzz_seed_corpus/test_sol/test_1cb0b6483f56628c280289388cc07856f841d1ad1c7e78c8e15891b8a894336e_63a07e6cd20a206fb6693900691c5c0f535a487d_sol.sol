
==== Source: su0.sol ====
struct St0 {
  bytes3 el0;
  bytes18 el1;
}
pragma solidity >= 0.0.0;
struct St1 {
  int192 el0;
}
struct St2 {
  address payable el0;
  address el1;
}
contract C0 {
  address  public s0;
  int192  public s1;
  uint144   s2;
  constructor(address i0,int192 i1,uint144 i2) payable  {
    s0 = address(this);
    s1 -= ((false ? (int176(0) >= (int176(0) ** uint168(uint168(0)))) : false) ? int192(0) : int192(2925491215426488960568412869732635741654146116798742515307));
    s2 >>= true f0 /*suffix expr*/;
    {
    }
  }
  event ev0();
  event ev1(bytes30  ep0, string  ep1, bytes23  ep2);
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call((false ? bytes("000000000000000000000000000000ffffffffffffffffffffffffff") : bytes("00000000000000000000000000000000000000000000000000000000000000000000000000")));
    emit ev0();
    assert((true ? false : false));
    require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
function f2(uint48 i0)    pure suffix returns(St1 memory o0){
  if (i0 != (uint48(281474976710655) + (uint48(168794591537219) | uint48(256920113602428))))
  {
    (o0) = (St1(int192(2034209728905519893331515128844748316318615842948039841042)));
    bool l0 = true;
    do
    {
      break;
    }
    while ((uint40(0) == uint40(1099511627775)));
  }
}
function f0(bool i0) pure suffix  returns(uint136 o0)
{
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bytes23 constant cons0 = bytes23(0x0000000000000000000000000000000000000000000000);
contract C1 {
  fallback() external virtual  
  {
    for(    int16 l0 = int16(((int16(0) + (((int16(32767) + int16(0)) & int16(32767)) ^ int16(32767))) / int16(-29571)));
;
)
    {
      continue;
    }
  }
  int112  public s3 = int112(0);
  function f4() external      {
    do
    {
      if (false)
      {
        if (false)
        {
          continue;
        }
        else
        {
          continue;
        }
        break;
      }
      else if (true)
      {
        try this.f4()
        {
          continue;
        }
        catch
        {
          (s3) = (((~(int112((((int112(2596148429267413814265248164610047) & int112(-1534384475814468552828621036777244)) % int112(0)) / int112(2596148429267413814265248164610047))))) - int112(0)));
          assert(s3 == ((~(int112((((int112(2596148429267413814265248164610047) & int112(-1534384475814468552828621036777244)) % int112(0)) / int112(2596148429267413814265248164610047))))) - int112(0)));
        }
        break;
      }
      continue;
    }
    while (true);
  }
  error er0(bytes23 ep0, bytes7 ep1);
  modifier m0() virtual
  {
    if ((payable(address(this)) == payable(address(this))))
    {
      int112  l0 = s3;
      int112  l1 = l0;
      assert(l1 == s3);
      try this.f4()
      {
        if (true)
        {
          _;
        }
        else
        {
          while (0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f5 /*suffix expr*/)
          {
            continue;
          }
        }
        int112  l2 = s3;
        int112  l3 = l2;
        assert(l3 == s3);
      }
      catch
      {
        _;
        _;
        if ((payable(address(this)) <= payable(address(this))))
        {
          if (true)
          {
            require((uint120(0) >= ((uint120(1329227995784915872903807060280344575) - (uint120(1098914304933809748093996578514196625) ^ uint120(1329227995784915872903807060280344575))) % uint120(0))));
          }
          else if (true)
          {
            (s3) = (int112(2596148429267413814265248164610047));
            assert(s3 == int112(2596148429267413814265248164610047));
            this.f4();
          }
        }
        _;
      }
    }
    else if (true)
    {
    }
  }
}
function f5(address i0) pure suffix  returns(bool o0)
{
}
// ====
// ----
