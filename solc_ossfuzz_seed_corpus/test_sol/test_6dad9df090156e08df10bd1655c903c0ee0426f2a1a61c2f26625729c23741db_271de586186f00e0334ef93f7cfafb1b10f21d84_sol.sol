
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  fallback() external   payable
  {
  }
  uint240   s0;
  int144  public s1;
  bytes5   s2;
  constructor(uint240 i0,int144 i1,bytes5 i2) payable  {
    s0 *= (((bytes8(0xffffffffffffffff) <= bytes8(0xffffffffffffffff)) ? uint240(1073399000690942653254387140291193399836587287482788591069990518344161861) : uint240(936125652357352638918003541601905741112759374926099693463623186540077482)) - uint240(109368725581232789342299556146347366382665529218294246064850218056923888));
    s1 *= (int144((uint144(22300745198530623141535718272648361505980415) - ((uint144(22300745198530623141535718272648361505980415) ** uint160(uint160(1461501637330902918203684832716283019655932542975))) | uint144(0)))) & int144(4237337893561437254681540662325229278343044));
    s2 ^= bytes5(0x0000000000);
    unchecked {
      bytes5  l0 = s2;
      bytes5  l1 = l0;
      assert(l1 == s2);
      (bool l2) = payable(this).send(9979373490314566069);
      uint240  l3 = s0;
      uint240  l4 = l3;
      assert(l4 == s0);
      int144  l5 = s1;
      int144  l6 = l5;
      assert(l6 == s1);
    }
  }
  function f1(int144 i0,int144 i1) external   
  {
    uint240  l0 = s0;
    uint240  l1 = l0;
    assert(l1 == s0);
    int144  l2 = s1;
    int144  l3 = l2;
    assert(l3 == s1);
    int144  l4 = s1;
    int144  l5 = l4;
    assert(l5 == s1);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
