
==== Source: su0.sol ====
type T0 is address payable;
pragma solidity >= 0.0.0;
struct St0 {
  function (int80) external   returns (bool, bytes31)[2] el0;
}
function f0(function (address) external   returns (uint120, bool, St0[2] memory) i0,function (T0, bool) external   returns (bytes32, bool, St0 memory) i1)     returns(address payable o0,uint232[2] memory o1)
{
}
contract C0 {
  function f1(function (bytes25, function (bytes memory) external   returns (bytes1, bytes memory)) external   returns (bytes memory, bytes memory, St0 memory) i0) external    returns(function () external   returns (bool, uint176) o0)
  {
  }
  int128 public constant cons0 = (int128(170141183460469231731687303715884105727) ** uint240((uint240(1766847064778384329583297500742918515827483896875618958121606201292619775) & ((uint240(1766847064778384329583297500742918515827483896875618958121606201292619775) << uint64(uint64(18446744073709551615))) ^ uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)))));
  event ev0();
  type T1 is address payable;
  address   s0;
  constructor(address i0) payable  {
    s0 = address(ripemd160("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    unchecked {
    }
  }
  function f2(address payable i0,int56 i1) public   
  {
    bytes21(0xa9538cd188071b50d36947ae72e631bfaefe31a033);
    unchecked {
      if ((uint240(1239772861295546882619839256585604942317840469000361853807812316208862304) < uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)))
      {
      }
      else
      {
      }
      emit ev0();
      assembly
      {
        for 
        {
          for 
          {
            pop(i0)
          }
          115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
            if s0.offset
            {
            }
            i1 := shl(and(115792089237316195423570985008687907853269984665640564039457584007913129639935, 7964874225217387257169955301550362089698668143285159329933637644280883497130), 0)
          }
          {
            let al0 := cons0
            if i1
            {
            }
          }
          mstore(mod(s0.offset, 2048), gasprice())
        }
        mload(mod(i0, 2048))
        {
        }
        {
          if mload(mod(s0, 2048))
          {
          }
          stop()
          for 
          {
            i0 := i0
          }
          i1
          {
          }
          {
            break
          }
        }
        {
        }
        i0 := caller()
      }
      {
        (bool l0, bytes memory l1) = address(this).call("e482f44d34126cc524451c3a8a8c0775cf86bc0e1438c28e2cdedf151e7fe084d9e8096a86eb1621112df674d2");
        emit ev0();
        return;
        string storage l2;
        return;
      }
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38
}
// ====
// ----
