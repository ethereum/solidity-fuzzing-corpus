
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  mapping(int144 => int152)  public s0;
  address payable immutable  s1;
  constructor(address payable i0)   {
    s1 = (((uint152(((uint152(5708990770823839524233143877797980545530986495) >> uint88(uint88(309485009821345068724781055))) / uint152(0))) + uint152(825587890605483187840396925182628186223711766)) != uint152(5003233133776740628656894264262717077670768768)) ? payable(address(this)) : payable(address(this)));
    s0[(-((false ? int144(11150372599265311570767859136324180752990207) : int144(0))))] %= int152(0);
    {
    }
  }
  struct St0 {
    bool el0;
    bytes31 el1;
    uint152 el2;
    int232 el3;
  }
}
function f0()    
{
  function (uint240, bytes10, address payable) internal   returns (int144[][9][] memory) l0;
  int96[8][][9] memory l1 = [new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10), new int96[8][](10)];
  return;
}
library L0 {
  function f1(address i0,bool i1) public   
  {
    (i0) = (address(0x0000000000000000000000000000000000000007));
    assert(i0 == address(0x0000000000000000000000000000000000000007));
  }
  function f2(C0.St0 memory i0) public    returns(bytes21 o0,C0.St0 memory o1)
  {
    address l0 = address(0x0000000000000000000000000000000000000004);
    assembly
    {
      returndatacopy(add(0x80, mod(i0, 1024)), i0, mod(create(i0, 13307407702793147710386646794965787494088411885197529153450317466108999648149, 74882451324855669144120592031494874507526439308290322869247984699615324174668), 1024))
    }
    unchecked {
      (o1.el1, i0.el0) = ((i0.el1 ^ i0.el1), (bytes29(0xf90b5b65ff02e9332ad7ed2ce6cd987c67313732157ef13df45df13eeb) < bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
      assert(o1.el1 == (i0.el1 ^ i0.el1));
      assert(i0.el0 == (bytes29(0xf90b5b65ff02e9332ad7ed2ce6cd987c67313732157ef13df45df13eeb) < bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
      function (bool, uint136, int64) internal   l1;
      assert(true);
      bool l2 = false;
    }
  }
}
using L0 for address;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
