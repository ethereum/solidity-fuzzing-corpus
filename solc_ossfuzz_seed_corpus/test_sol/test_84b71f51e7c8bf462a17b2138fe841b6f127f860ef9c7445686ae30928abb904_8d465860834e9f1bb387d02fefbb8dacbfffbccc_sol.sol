
==== Source: su0.sol ====
struct St0 {
  uint40 el0;
  int16 el1;
  int216 el2;
  mapping(bool => address) el3;
}
pragma solidity >= 0.0.0;
struct St1 {
  St0 el0;
  string el1;
  address el2;
  bool el3;
}

==== Source: su1.sol ====
bool constant cons0 = true;
contract C0 {
  function f0() public   payable  returns(bool[2] memory o0)  {
    if (false)
    {
      o0 = [false, true];
      bytes8 l0 = bytes8(0xffffffffffffffff);
    }
    else if ((true ? true : cons0))
    {
      if (true)
      {
        abi.encode((~(bytes1(0x20))), bytes29((bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) ^ bytes28(0x00000000000000000000000000000000000000000000000000000000))), payable(address(this)));
        if ((false ? true : cons0))
        {
        }
        else if (true)
        {
          while (false)
          {
            o0 = [true, false];
            assert(cons0);
          }
        }
      }
      else if (true)
      {
        for(        (cons0 ? false : true);
;
)
        {
          return ((((bytes11(0xffffffffffffffffffffff) >= bytes11(0x51a3928ab52e1a05ec656b)) ? (int208(205688069665150755269371147819668813122841983204197482918576127) > int208(-8546305619576839433487735104263060408271489592274610411092091)) : true) ? [true, true] : [false, false]));
        }
      }
    }
  }
  bytes9   s0;
  constructor(bytes9 i0)   {
    s0 ^= bytes9(0x000000000000000000);
    unchecked {
    }
  }
  struct St2 {
    function (bool, function (address) external  , bool) external   returns (address payable, bytes4) el0;
    address payable el1;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
