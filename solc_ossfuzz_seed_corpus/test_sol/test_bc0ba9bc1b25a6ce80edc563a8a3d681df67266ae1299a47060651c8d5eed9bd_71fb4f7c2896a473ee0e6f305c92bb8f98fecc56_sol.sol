
==== Source: su0.sol ====
error er0();
type T0 is int208;
function f0(T0 i0)    
{
  string memory l0 = string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000");
  ((((((uint96(79228162514264337593543950335) ** uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) & uint96(12172764818411440789931450237)) % uint96(79228162514264337593543950335)) ** uint8(uint8(0))) + uint96(0)) << uint8(uint8(0)));
}
pragma solidity >= 0.0.0;
library L0 {
  type T1 is uint176;
  error er1(function (string memory) external   ep0);
  modifier m0() 
  {
    _;
    if (true)
    {
      {
        function () internal   returns (bytes2, address) l0;
      }
    }
    if (false)
    {
      _;
    }
    else if ((true && (true ? false : false)))
    {
    }
    _;
  }
  using L0 for *;
  error er2(bytes19 ep0, address ep1);
  modifier m1(uint136 i0,bytes17 i1) 
  {
    _;
  }
}
contract C0 {
  modifier m2(int88 i0) virtual
  {
    { }
    assert(true);
    if (true)
    {
      { }
      _;
    }
    else if ((true && (!((!(false))))))
    {
    }
    else
    {
      _;
      (i0) = (((int88(139647219953834762160193358) % (~(int88(0)))) & int88(0)));
      _;
    }
  }
  error er3();
  int192 public constant cons0 = int192(((uint192((((uint192(0) & uint192(0)) & uint192(0)) / uint192(6277101735386680763835789423207666416102355444464034512895))) - uint192(6277101735386680763835789423207666416102355444464034512895)) << uint8(uint8(0))));
  receive() external virtual m2(((int88(1940317119666082790679089) * int88(0)) & int88((int88(85918024981271540367337623) / int88(0))))) payable
  {
    while (false)
    {
      continue;
      return;
      for(      int120 l0 = int120((int120(199016103242413805706507785538269279) / int120((int120(-526485252131504839435043565648404072) / (int120(394856511035359573967436315693748664) * int120(0))))));
((((int240(883423532389192164791648750371459257913741948437809479060803100646309887) % (int240(172616994685972526590451745820748777546388382992330564220153872810964675) + int240(-179231647440341924471299314789974440707450137740261137946213529498760981))) % int240(883423532389192164791648750371459257913741948437809479060803100646309887)) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) != int240(0));
)
      {
      }
    }
  }
  modifier m3() virtual
  {
    _;
  }
  modifier m4(bytes20 i0) 
  {
    f0(T0.wrap(int208(0)));
    _;
    _;
    if (true)
    {
    }
    else if (true)
    {
    }
  }
  function f2(bool i0) external virtual m4(bytes20(address(0xb2ca3e44591E6BeFeCdab0Cfe86ab73b2566507D)))  returns(bytes4 o0)
  {
    return (bytes4(0x00000000));
    return (msg.sig);
    payable(this).transfer(10376475990578533738);
  }
  bool   s0;
  mapping(L0.T1 => L0.T1)  public s1;
  int208 immutable  s2 = int208(205688069665150755269371147819668813122841983204197482918576127);
  mapping(int176 => bool)  public s3;
  constructor(bool i0)   {
    s0 = (!((s3[int176(47890485652059026823698344598447161988085597568237567)] || true)));
    s1[L0.T1.wrap(uint176(0))] = L0.T1.wrap(uint176(7221636700086140321872973796545855002637775645619731));
    s3[(((int176(-47787400176280816082339929147724188642318991449233563) ** uint32(((uint32(3969081571) - uint32(0)) ^ uint32(4294967295)))) + int176(0)) ^ int176(0))] = false;
    unchecked {
      revert er0();
      assert(((((uint32(0) << uint136(uint136(0))) << uint8(uint8(255))) ^ uint32(4294967295)) == uint32(4175528133)));
    }
  }
  using L0 for *;
  struct St0 {
    address payable el0;
    bool el1;
    mapping(uint104 => mapping(int104 => int16)) el2;
  }
}
struct St1 {
  address el0;
  bytes5 el1;
  address el2;
}
// ====
// ----
