==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  error er0(function (bytes31, uint8) external   ep0);
  function f0(bytes27 i0) private   
  {
    if (((false && false) && false))
    {
      uint176 l0 = (((uint176((((uint176(73298012887480215654439576502392259225225819848424924) ^ uint176(0)) % uint176(14701818460171366566135140243292987680537193244158521)) / uint176(23072451310597467683857995045065529673295623706325184))) * uint176(0)) ^ uint176(0)) - uint176(0));
    }
    else if (((int96(0) | (((int96(0) % int96(0)) & int96(39614081257132168796771975167)) * int96(39614081257132168796771975167))) < int96(39614081257132168796771975167)))
    {
    }
    else
    {
      (i0) = (bytes27(0x3a1bd2e5128e69a52b19232f916b4c54b62c06ec1bc235a96931b6));
    }
  }
  type T0 is bytes3;
  function f1(int56 i0,uint8[] calldata i1) external    returns(bytes17 o0,string memory o1)
  {
  }
  uint152  public s0 = uint152(5708990770823839524233143877797980545530986495);
  C0.T0   s1;
  bool  public s2;
  bytes1[1][2]   s3 = [[bytes1(0xff)], [bytes1(0xff)]];
  constructor(C0.T0 i0,bool i1)   {
    s1 = C0.T0.wrap(bytes3(0xffffff));
    s2 = (true || true);
    unchecked {
    }
  }
  modifier m0(bool i0,int248 i1) 
  {
    revert(string("ffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000"));
    _;
    do
    {
      break;
      (s3[1], s3[1]) = (s3[1], [bytes1(0xff)]);
    }
    while ((!(false)));
    _;
  }
  fallback() external virtual  
  {
  }
  error er1();
}
type T1 is uint128;
function f3()    
{
  if (false)
  {
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  int200 el0;
  uint40 el1;
}
contract C1 {
  struct St1 {
    bool el0;
    uint32[2] el1;
  }
  type T2 is int176;
  modifier m1() virtual
  {
    0;
    _;
  }
  bytes21 public constant cons0 = (bytes21(0xffffffffffffffffffffffffffffffffffffffffff) & (((bytes21(0xc0f60408e640babdeb838b66a17b1b702891b25ea6) & bytes21(0xffffffffffffffffffffffffffffffffffffffffff)) | bytes21(0xffffffffffffffffffffffffffffffffffffffffff)) & bytes21(0x000000000000000000000000000000000000000000)));
  function f4(uint136[] calldata i0) external  m1() m1() payable returns(C1.T2 o0,address payable o1)
  {
  }
  mapping(bool => St0)[1][2]  public s4;
  bytes  public s5 = "6f909615bcade8137e9b6a513412bf67ef51d22d8a";
  fallback() external  m1() 
  {
  }
  event ev0(bytes  ep0, int128 indexed ep1);
  function f6() private  m1()  returns(C1.St1 memory o0,uint24 o1)
  {
    return (C1.St1(true, [uint32(4294967295), uint32(4294967295)]), ((((uint24(10361932) * uint24(1377322)) % uint24(0)) << uint216(uint216(105312291668557186697918027683670432318895095400549111254310977535))) ** uint144(uint144(22300745198530623141535718272648361505980415))));
    revert("0000000000000000000000000000000000000000000000000000000000000000d93491e7c809");
    St0 memory l0 = St0(int200(803469022129495137770981046170581301261101496891396417650687), uint40(0));
  }
  modifier m2(bool i0,address i1) 
  {
    _;
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 7238: (su0.sol:1320-1360): This assignment performs two copies to storage. Since storage copies do not first copy to a temporary location, one of them might be overwritten before the second is executed and thus may have unexpected effects. It is safer to perform the copies separately or assign to storage pointers first.
// Warning 3149: (su1.sol:938-1076): The result type of the shift operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint216) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su1.sol:937-1143): The result type of the exponentiation operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint144) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su1.sol:1151-1237): Unreachable code.
// Warning 5740: (su1.sol:1243-1343): Unreachable code.
// Warning 2072: (su0.sol:159-169): Unused local variable.
// Warning 5667: (su0.sol:1041-1049): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1050-1057): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su1.sol:162-163): Statement has no effect.
// Warning 2072: (su1.sol:1243-1256): Unused local variable.
// Warning 2018: (su0.sol:71-735): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:1480-1522): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:799-1348): Function state mutability can be restricted to pure
