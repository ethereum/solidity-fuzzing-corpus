
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(int208 i0)      returns(function (bool, bytes memory, uint176) external   returns (function (int208) external  , bool, bytes12) o0){
  do
  {
    do
    {
      try o0(false,bytes("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"),uint176(95780971304118053647396689196894323976171195136475135)) returns (function (int208) external   l0, bool l1, bytes12 l2)
      {
      }
      catch
      {
        continue;
      }
      if (i0 <= int208(205688069665150755269371147819668813122841983204197482918576127))
      {
        continue;
      }
      else if (i0 >= ((int208(205688069665150755269371147819668813122841983204197482918576127) - (((int208(205688069665150755269371147819668813122841983204197482918576127) + int208(-100086188458788686084276275992048732299688131922483203625818060)) - int208(-56234976857236909606121063542397088526795322720891480932374312)) & int208(0))) ^ int208(-190501197772961764325253746544295932071331624852283221982816589)))
      {
        continue;
      }
    }
    while (false);
    continue;
  }
  while ((int232(1569927516452200313808612852040381135506309747790309770455676561833083) <= int232(-1054008106480286176959668907575149845076538934573988724474728419923709)));
}
struct St0 {
  bytes10 el0;
  int160 el1;
}

==== Source: su1.sol ====
struct St1 {
  mapping(uint192 => int248) el0;
  int32 el1;
  int112 el2;
}
error er0();
import "su0.sol";
pragma solidity >= 0.0.0;
contract C0 {
  event ev0();
  receive() external virtual  payable
  {
    payable(this).transfer(0);
  }
  bool   s0 = false;
  bytes13   s1 = bytes13(0xffffffffffffffffffffffffff);
  struct St2 {
    address el0;
    bytes el1;
    bytes4 el2;
    address payable el3;
  }
}
struct St3 {
  St0 el0;
  uint120 el1;
}
// ====
// ----
