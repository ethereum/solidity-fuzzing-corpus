
==== Source: su0.sol ====
struct St0 {
  bool el0;
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
    if (((int80(0) < ((-(int80(604462909807314587353087))) * int80(0))) ? true : true))
    {
      if (((uint200(0) ^ uint200(0)) != ((uint200(1360909558653509065680927011028894633612599312326339042000805) ^ uint200(287781818177762577525916917126986247907976463682857661343729)) & uint200(0))))
      {
        require(false);
        do
        {
          break;
        }
        while ((false ? false : (uint192(0) == uint192(0))));
        for(uint solinit0 = 0; solinit0 < ((uint256(0) >> uint120(uint120(0))) % 11); solinit0++)
        {
        }
      }
      else if (((true == false) ? false : true))
      {
        address payable l0 = payable(address(this));
      }
      return;
    }
    else if (false)
    {
      payable(this).transfer(13487909934936715837);
    }
  }
  St0  public s0 = St0({el0: false});

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}
	function compareMemoryAndCalldata(St0 memory v1, St0 calldata v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  function f1(St0 calldata i0) public     returns(bytes18 o0,St0 memory o1)  {
  }
  function f2(St0 calldata i0) internal      {
    return;
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bytes6 constant cons0 = bytes6(0x000000000000);
// ====
// ----
