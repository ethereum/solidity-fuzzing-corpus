
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bool[] el0;
  mapping(address => bool) el1;
  function (address, function () external   returns (function (address) external  , address, bytes memory), int216) external   returns (int216) el2;
  address el3;
}
contract C0 {
  receive() external   payable
  {
    if (false)
    {
      do
      {
        break;
      }
      while (true);
      if (true)
      {
        for(;
;
(true ? ((-((int224(13479973333575319897333507543509815336818572211270286240551805124607) ** uint184(uint184(14287273321174582414281900909501998137182588744631885542))))) != int224(0)) : false))
        {
          revert(string(bytes("038ee7088d652d9fd03bbc66a80650294311d0a4045d47ffff")));
        }
        return;
      }
      else
      {
      }
    }
  }
  bytes31 immutable  s0 = bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  address payable   s1;
  constructor(address payable i0)   {
    s1 = payable(address(this));
    unchecked {
    }
  }
  event ev0();
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bytes el0;
}
struct St2 {
  address payable[] el0;
  mapping(bytes18 => address) el1;
  bytes2 el2;
}
import "su0.sol";
contract C1 {
  uint248   s2 = uint248(0);
  bytes15   s3 = bytes15(0x1b0773842d8b928aca77a7084bfc4d);
  function f1(bytes15 i0,uint248 i1) public     returns(bool o0,St1 memory o1)  {
  }
}
// ====
// ----
