
==== Source: su0.sol ====
contract C0 {
  address immutable  s0 = address(this);
  address  public s1 = address(this);
  function f0(address i0,address i1) public virtual  payable   {
    if (i0 >= this.f0.address)
    {
      if (i1 >= (true ? address(this) : address(this)))
      {
        (s1) = ((false ? address(this) : address(this)));
        assert(s1 == (false ? address(this) : address(this)));
      }
      else
      {
        if (i1 <= address(this))
        {
          return;
        }
        else if (i0 >= address(this))
        {
        }
      }
      if (i1 == address(this))
      {
      }
      else if (i0 >= ecrecover(sha256(bytes("ffffffffffffffffffffffffffffffffffffffffff")), uint8(0), (bytes30(0x84aa044eca1328a4d68f801d8e9baf244d80e3d29b14c7b29c0d295a37de) & bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), bytes32(0x5caf267042fd0f08d55121f06c600f87299f994824ea1597eeaacdbaa1458f07)))
      {
        s1 = address(bytes20(address(0x8f17af30f1536Eb3b59dc4f65ba86eAE6bA7eEaC)));
        assert(s1 == address(bytes20(address(0x8f17af30f1536Eb3b59dc4f65ba86eAE6bA7eEaC))));
        (s1) = (address(this));
        assert(s1 == address(this));
      }
    }
    else if (i1 > address(this))
    {
      return;
    }
  }
  function f1(address i0,address i1,address i2) public virtual    returns(int208 o0,address o1)  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  function f2(address i0,address i1) external   payable   {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffff"));
  }
}
function f3()      returns(function (uint32, bool) external   o0){
  return (o0);
}
bool constant cons0 = false;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  receive() external   payable
  {
    return;
  }
  type T0 is uint72;
  C1.T0   s2;
  uint184  public s3;
  bool   s4 = false;
  uint88   s5;
  constructor(C1.T0 i0,uint184 i1,uint88 i2) payable  {
    s2 = (false ? ((false ? false : true) ? C1.T0.wrap(uint72(0)) : C1.T0.wrap(uint72(0))) : C1.T0.wrap(uint72(0)));
    s3 <<= (uint184(((uint184(((false ? uint24(0) : uint24(15573809)) / uint184(16583258016512132521033873146813675532152353909035014353))) >> uint16(uint16(23581))) / uint184(24519928653854221733733552434404946937899825954937634815))) * uint184(0));
    s5 <<= uint88(309485009821345068724781055);
    unchecked {
    }
  }
  struct St0 {
    int224 el0;
  }
  struct St1 {
    address el0;
  }
  fallback() external   
  {
    assert(false);
  }
  function f6() public virtual  payable   {
    C1.T0  l0 = s2;
    C1.T0  l1 = l0;
    assert(l1 == s2);
  }
}
import "su0.sol";
// ====
// ----
