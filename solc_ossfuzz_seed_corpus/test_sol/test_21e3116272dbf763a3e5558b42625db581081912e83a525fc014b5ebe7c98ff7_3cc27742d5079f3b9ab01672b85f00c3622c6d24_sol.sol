
==== Source: su0.sol ====
bool constant cons0 = true;
library L0 {
  function f0(function (function (uint48, bool) external   returns (uint232, function (uint40, int208) external  ), bool, address payable) external   returns (uint192, address) i0,string memory i1) external   
  {
    int112 l0 = int112(-67047254118820521704365413313569);
  }
  function f1(int128 i0) internal   
  {
  }
}
pragma solidity >= 0.0.0;
error er0();
contract C0 {
  uint232  public s0;
  uint32   s1 = uint32(0);
  address payable   s2 = payable(address(this));
  bool immutable  s3 = false;
  constructor(uint232 i0)   {
    s0 >>= (false ? ((~(((uint232(6127210477210528046239900257399697498546395704223810321598823954772058) ^ uint232(5935547207705863514608576216044401902722451676074142612180344354016121)) ^ uint232(0)))) - uint232(6901746346790563787434755862277025452451108972170386555162524223799295)) : uint232(0));
    unchecked {
      {
        assert((address(this) == address(this)));
        uint32  l0 = s1;
        uint32  l1 = l0;
        assert(l1 == s1);
        {
          revert er0();
        }
        {
          address payable  l2 = s2;
          address payable  l3 = l2;
          assert(l3 == s2);
          {
            address payable  l4 = s2;
            address payable  l5 = l4;
            assert(l5 == s2);
            assert((int8(uint8(255)) <= (int8(0) + int8(0))));
            bool  l6 = s3;
            bool  l7 = l6;
            assert(l7 == s3);
            address payable  l8 = s2;
            address payable  l9 = l8;
            assert(l9 == s2);
            {
              assert(cons0);
              (bool l10) = payable(this).send(17852180239717302190);
              {
                address payable  l11 = s2;
                address payable  l12 = l11;
                assert(l12 == s2);
              }
            }
            s1 %= (uint32(0) + (~(uint32(4294967295))));
            uint32  l13 = s1;
            uint32  l14 = l13;
            assert(l14 == s1);
          }
          require((payable(address(this)) >= payable(address(this))));
        }
      }
    }
  }
  event ev0(string  ep0);
  receive() external   payable
  {
    uint32  l0 = s1;
    uint32  l1 = l0;
    assert(l1 == s1);
  }
  using L0 for *;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L1 {
  function f3(function () external   i0) public   
  {
    bool l0 = false;
  }
}
library L2 {
  function f4(function (string memory, address) external   returns (int24, function () external   returns (bytes5, uint208), uint56) i0,bool i1,address payable i2) external    returns(address o0)
  {
  }
}
// ====
// ----
