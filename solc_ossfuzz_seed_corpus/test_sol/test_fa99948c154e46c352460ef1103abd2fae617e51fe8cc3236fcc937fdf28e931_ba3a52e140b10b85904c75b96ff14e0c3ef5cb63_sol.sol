==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0(int216 i0,int96 i1,function (uint48, bytes4[1] memory, address[2] memory) external   returns (string memory)[2] calldata i2) private    returns(address o0)
  {
  }
  function f1() external   payable returns(bool o0,function (bytes14) external   returns (address) o1,bool o2)
  {
  }
  bytes23  s0;
  uint184  s1;
  constructor(bytes23 i0,uint184 i1) payable  {
    s0 |= bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff);
    s1 <<= (uint184(0) ** ((((uint32(0) ** uint232(0)) ** uint96(0)) ** uint112(3024775554042555818665385957344046)) + uint32(0)));
    unchecked {
      revert(string("ffffffa850d8c5"));
    }
  }
  modifier m0(bytes2 i0) virtual
  {
    _;
  }
  int96 public constant cons0 = (~((~(((int96(-18707757903298703919093267977) ** (uint184(0) ** uint88(160851268452344115377562534))) ** uint96(61680072668190506385173334270))))));
  type T0 is bool;
  fallback() external virtual  
  {
    string memory l0 = string("b0e81bee06c3b0605294c523651f3425a682eb4ade62dd03a5c51b71df31f099e8f327364bc774");
    revert(string("ffffffffffffffffff8e33c2e14036aaad191e82fa0b8b68118e117c15056b7b64ffb6"));
    require(true);
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19
  }
  error er0();
  modifier m1() 
  {
    assembly
    {
    }
    _;
  }
  event ev0();
}
function f3()     returns(int64 o0,int184 o1)
{
  if (false)
  {
  }
  else if (false)
  {
    return (((~((int64(0) ** (~(uint48(281474976710655)))))) ** uint8(0)), int184(0));
    assert(false);
  }
  else
  {
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
  int56 el1;
}
contract C1 {
  function f4(C0 i0) external virtual   returns(C0 o0)
  {
    function () external   returns (string memory, C0, St0 memory) l0;
  }
  modifier m2() 
  {
    _;
    try this.f4(new C0{salt: sha256(type(C0).creationCode)}(bytes23(0x2f3c22de9ffc883bd1cadfb458f5ac3ca611036a2793dd), (((~(uint184(16786205072421621758959417804447639742398428755881495573))) ** uint8(0)) ** uint136(51281838161638706577223275592168791752496)))) returns (C0 l0)
    {
      do
      {
      }
      while (true);
      assembly
      {
        let al0 := 69169767196516682492566183160921085892188905822375060750526645827686566631442
        let al1 := 0
        for 
        {
        }
        al1
        {
        }
        {
        }
      }
      _;
    }
    catch
    {
    }
    catch Panic(uint256 l1)
    {
    }
    assert(true);
    assembly
    {
    }
  }
  St0  s2;
  type T1 is bytes14;
  struct St1 {
    C1.T1 el0;
    St0 el1;
    mapping(C0 => St0) el2;
  }
  event ev1();
  receive() external  m2() payable
  {
    revert(string("798b74bbf6bcb32143a6c474b6861f9d3b77a53ee39fdc957318e9f2dfe259bcf66d88b70846f1"));
    delete s2.el0;
  }
  modifier m3() virtual
  {
    _;
  }
}
// ----
// Warning 3149: (su0.sol:488-511): The result type of the exponentiation operation is equal to the type of the first operand (uint32) ignoring the (larger) type of the second operand (uint232) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:487-525): The result type of the exponentiation operation is equal to the type of the first operand (uint32) ignoring the (larger) type of the second operand (uint96) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:486-573): The result type of the exponentiation operation is equal to the type of the first operand (uint32) ignoring the (larger) type of the second operand (uint112) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:744-836): The result type of the exponentiation operation is equal to the type of the first operand (int96) ignoring the (larger) type of the second operand (uint184) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:1559-1572): Unreachable code.
// Warning 5740: (su0.sol:1151-1164): Unreachable code.
// Warning 5740: (su0.sol:1845-2098): Unreachable code.
// Warning 5740: (su0.sol:2119-2414): Unreachable code.
// Warning 5740: (su0.sol:2429-2436): Unreachable code.
// Warning 5740: (su0.sol:2469-2476): Unreachable code.
// Warning 5740: (su0.sol:2481-2493): Unreachable code.
// Warning 5740: (su0.sol:2792-2805): Unreachable code.
// Warning 5667: (su0.sol:355-365): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:366-376): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:944-960): Unused local variable.
// Warning 5667: (su0.sol:1689-1694): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1723-1728): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1738-1803): Unused local variable.
// Warning 2018: (su0.sol:1377-1594): Function state mutability can be restricted to pure
