==== Source:  ====

==== Source: su0.sol ====
library L0 {
  modifier m0(bytes24 i0) 
  {
    _;
    _;
    uint112 l0 = (~((~(uint112((((uint112(5192296858534827628530496329220095) + uint112(5192296858534827628530496329220095)) - uint112(0)) / uint112(5192296858534827628530496329220095)))))));
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  using L0 for *;
  fallback() external   
  {
    bytes6(0xffffffffffff);
    int224 l0 = (int224(13479973333575319897333507543509815336818572211270286240551805124607) - int224(13479973333575319897333507543509815336818572211270286240551805124607));
  }
  event ev0(int200 indexed ep0, address[]  ep1);
  uint24  public s0 = uint24(13175435);
  int88[2][][]  public s1;

	function compareMemoryAndStorage(int88[2][][] memory v1, int88[2][][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int88[2][] memory v1, int88[2][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int88[2] memory v1, int88[2] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bytes31  public s2 = bytes31(0x52d00f2206ab696e44d1cb4491ccfd699b35a4c800a4932e3ea05573435ba8);
  constructor(int88[2][][] memory i0) payable  {
    s1 = i0;
    unchecked {
      bytes31  l0 = s2;
      bytes31  l1 = l0;
      assert(l1 == s2);
      s1.push(new int88[2][](7));
      int88[2][][] memory l2 = s1;
      int88[2][][] memory l3 = l2;
      assert(compareMemoryAndStorage(l3, s1));
      int88[2][][] memory l4 = s1;
      int88[2][][] memory l5 = l4;
      assert(compareMemoryAndStorage(l5, s1));
      s1 = [new int88[2][](7), new int88[2][](7), new int88[2][](7), new int88[2][](7), new int88[2][](7)];
    }
  }
}

==== Source: su1.sol ====
library L1 {
  function f2(bytes memory i0,bool i1) public    returns(int112[][10][][6] memory o0,bytes15 o1)
  {
    function () external   l0;
  }
  function f3(bool i0) external    returns(bool o0,uint8 o1)
  {
    function () external   returns (uint32, uint112, uint224) l0;
  }
}
using L1 for bytes;
pragma solidity >= 0.0.0;
// ----
// Warning 6133: (su0.sol:393-415): Statement has no effect.
// Warning 2072: (su0.sol:421-430): Unused local variable.
// Warning 5667: (su1.sol:27-42): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:43-50): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:70-97): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:98-108): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:118-143): Unused local variable.
// Warning 5667: (su1.sol:163-170): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:192-199): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:200-208): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:218-278): Unused local variable.
// Warning 2018: (su0.sol:1272-1518): Function state mutability can be restricted to view
// Warning 2018: (su1.sol:15-148): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:151-283): Function state mutability can be restricted to pure
