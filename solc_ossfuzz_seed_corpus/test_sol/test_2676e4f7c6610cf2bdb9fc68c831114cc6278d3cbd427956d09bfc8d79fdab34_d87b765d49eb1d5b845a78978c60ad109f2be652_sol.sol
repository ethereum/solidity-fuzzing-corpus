==== Source:  ====

==== Source: su0.sol ====
uint24 constant cons0 = (uint24(0) - ((((uint24(4299283) << uint56(uint56(0))) + uint24(16777215)) ^ uint24(0)) + uint24(16777215)));
function f0(int192 i0)     returns(uint96 o0,function (bool) external   returns (uint136, bytes memory) o1,uint64 o2)
{
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72
}
contract C0 {
  type T0 is uint136;
  error er0();
  function f1() internal   
  {
    if (false)
    {
    }
    else if (false)
    {
    }
  }
  address payable[]  public s0 = [payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000006))];
  mapping(EN0 => int80)   s1;
  constructor()   {
    s1[EN0.M65] |= int80(0);
    unchecked {
      s0.pop();
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000");
      int112 l2 = (~(int112(-1327478796074611420116759801502335)));
      if (((((uint248(337924761170297123176955244522353424438988918426548091100515155088633642487) - uint248(0)) >> uint16(uint16(63277))) + uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)) == uint248(188589564318473984160772069204599369946594916418204916313741167368626723558)))
      {
      }
      bytes memory l3 = "5de7423ce9b4be0f117ddbb654d29a";
    }
  }
  function f2(function () external   returns (uint192) i0) external virtual  
  {
    if (((!(true)) || false))
    {
    }
    else if ((false || (true || ((!(false)) || true))))
    {
    }
    assembly
    {
      return(s0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      {
      }
    }
    (s0[1], s0[0], s0[1]) = (payable(address(this)), payable(address(this)), payable(address(this)));
  }
  function f3(bytes23 i0) internal    returns(function (bytes18) external   returns (bool, bool) o0)
  {
    (s0, s0, s0[1]) = ([payable(address(0x0000000000000000000000000000000000000006))], [payable(address(0x0000000000000000000000000000000000000008))], payable(address(this)));
    (s0[0]) = (payable(address(this)));
    string storage l0;
    (s0[0], s0[1], s0[0]) = (payable(address(ripemd160("9e129df1cceb80b96aa30000000000000000000000"))), payable(address(this)), payable(address(this)));
    while (false)
    {
      (bool l1, bytes memory l2) = address(this).call("3cd6df931fbd324b799f69d4fd452f");
      (bool l3, bytes memory l4) = address(this).call("eec317b36ba575e687968498c7f36c743c0f");
      continue;
    }
  }
  error er1(int184 ep0);
  int40 public constant cons1 = ((((((~(int40(0))) | int40(549755813887)) ^ int40(549755813887)) % int40(0)) ^ int40(549755813887)) | int40(430998071764));
  struct St0 {
    address el0;
    function (bytes14, uint160, EN0) external   returns (int16, int48, int216[1] memory) el1;
    bool el2;
    EN0 el3;
  }
  modifier m0(bytes20[] memory i0,bytes8 i1) virtual
  {
    if (false)
    {
      if (false)
      {
        _;
      }
      else if (true)
      {
      }
    }
    else
    {
    }
    do
    {
      revert er0();
    }
    while (true);
    _;
    (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe04f9ea2d5891cc11351d2de161892");
    (bool l2, bytes memory l3) = address(this).call("000000000000000000000000000000000000000000000000000000");
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 3149: (su0.sol:41-77): The result type of the shift operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint56) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// TypeError 1408: (su0.sol:1889-1891): Only local variables are supported. To access storage variables, use the ".slot" and ".offset" suffixes.
