
==== Source: su0.sol ====
library L0 {
  function f0(bytes9 i0) external   
  {
    assert(false);
    address payable l0 = payable(address(0x0000000000000000000000000000000000000003));
    int168 l1 = int168(63463276377173976804165714832235868966633114893323);
  }
  event ev0(address payable  ep0, int192  ep1) anonymous;
  function f1(address payable i0) public   
  {
    function (bytes13, address[][][10] memory) external   returns (bytes19) l0;
  }
}
pragma solidity >= 0.0.0;
using L0 for bytes9;
using L0 for bytes9;
library L1 {
  event ev1(uint80  ep0);
  event ev2(uint128  ep0, string  ep1);
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    assembly
    {
    }
    assembly
    {
      switch 0
      case 76906828497020222360120299185227154796749769535342156694119178299112458335984
      {
      }
      sstore(115792089237316195423570985008687907853269984665640564039457584007913129639935, 0)
      returndatacopy(add(0x80, mod(0, 1024)), 92606945805080428538316372719041095597639121703408999209242436446329380293484, mod(0, 1024))
      sstore(mload(add(0x80, mod(0, 1024))), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    }
  }
  bytes5   s0 = bytes5(0xffffffffff);
  bytes14   s1 = bytes14(0xffffffffffffffffffffffffffff);
  event ev3(function () external   returns (bytes25[][4][][][2] memory, bytes28, bool)  ep0) anonymous;
}
struct St0 {
  address el0;
  bool el1;
  int256 el2;
  bytes20 el3;
}
// ====
// ----
