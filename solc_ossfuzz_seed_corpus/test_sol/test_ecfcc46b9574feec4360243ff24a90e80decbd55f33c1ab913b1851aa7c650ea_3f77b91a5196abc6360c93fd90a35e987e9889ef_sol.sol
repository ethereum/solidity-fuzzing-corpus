==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  struct St0 {
    int152 el0;
    bytes26 el1;
    function (function () external   returns (uint8)) external   returns (address, bool) el2;
  }
  receive() external virtual  payable
  {
    function (int96) external   l0;
    assert(true);
    unchecked {
    }
    (bool l1, bytes memory l2) = payable(this).call{value: 13100945441794075933}("");
  }
  int160 immutable  s0 = int160(-580791747088984036545915420257291704335163689038);
  C0.St0   s1;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}  int136   s2;
  bool   s3 = true;
  constructor(int136 i0)   {
    s2 += (int136((int136(0) / (int136(0) | int136(-40329185335732510412490168736646236449934)))) % int136(43077811019909769660424732073129314062177));
    { }
  }
}
contract C1 {
  mapping(int56 => mapping(C0 => address))   s4;
  constructor()   {
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("33075ff0deffffffffffffffffff"));
      (bool l2, bytes memory l3) = address(this).call(bytes("56fd6837cb2f836c46bfa85b0c1cacbe1a1c236fd56c710000000000000000000000000000000000000000000000"));
    }
  }
  error er0(string ep0);
  error er1(bytes14 ep0);
}
type T0 is bytes18;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:206-236): Unused local variable.
// Warning 2072: (su0.sol:283-290): Unused local variable.
// Warning 2072: (su0.sol:292-307): Unused local variable.
// Warning 5667: (su0.sol:770-779): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1047-1054): Unused local variable.
// Warning 2072: (su0.sol:1056-1071): Unused local variable.
// Warning 2072: (su0.sol:1141-1148): Unused local variable.
// Warning 2072: (su0.sol:1150-1165): Unused local variable.
// Warning 2018: (su0.sol:469-721): Function state mutability can be restricted to view
