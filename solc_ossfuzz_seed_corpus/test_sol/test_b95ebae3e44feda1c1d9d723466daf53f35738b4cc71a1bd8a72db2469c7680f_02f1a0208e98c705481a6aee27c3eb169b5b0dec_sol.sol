
==== Source: su0.sol ====
library L0 {
  type T0 is bool;
  function f0() public    returns(bool o0,bytes16 o1)
  {
    (bool l0, bytes16 l1) = f0();
    do
    {
    }
    while ((!(false)));
    bytes32 l2 = sha256("00000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffff");
  }
  modifier m0(address payable i0) 
  {
    if (false)
    {
      _;
    }
    else if ((int192(0) < int192(544008195482566062403283193616602893093320836332179281336)))
    {
      delete i0;
    }
    else if (true)
    {
      bool l0 = true;
    }
    _;
    _;
    if (false)
    {
      _;
      if (((!((false || true))) || false))
      {
        if (false)
        {
        }
        else if (false)
        {
        }
        _;
      }
      else if (true)
      {
        _;
        _;
      }
      else if ((false || false))
      {
        _;
        (i0) = (payable(address(0x0000000000000000000000000000000000000002)));
      }
      assert(false);
    }
  }
  function f1() public  m0(payable(address(0x0000000000000000000000000000000000000002))) 
  {
  }
  modifier m1() 
  {
    _;
  }
  address payable public constant cons0 = payable(address(bytes20(address(0x3a666C1e97DCE834a50E83B7be8598Bd1BEE629c))));
  event ev0();
}
contract C0 {
  modifier m2() virtual
  {
    _;
    if (true)
    {
    }
    else if (((false && true) && false))
    {
    }
    else
    {
      (bool l0, bytes memory l1) = address(this).call("000000000000ffffffffffffffff");
    }
    uint88 l2 = ((uint88(301749829356705019345564034) ^ ((~((uint88(0) % uint88(309485009821345068724781055)))) & uint88(309485009821345068724781055))) ** uint256(uint256(22496897839594752644989270436967927063932314471407275381221960943328064923145)));
    if (true)
    {
      if (false)
      {
      }
      else if (true)
      {
      }
      else
      {
        int168 l3 = (int168(0) | int168(187072209578355573530071658587684226515959365500927));
        assembly
        {
        }
      }
    }
  }
  struct St0 {
    bool el0;
    address el1;
    function () external   returns (string memory, string memory, bool) el2;
  }
  modifier m3(address payable i0,int176 i1) virtual
  {
    _;
  }
  L0.T0   s0;
  mapping(bytes12 => address)   s1;
  constructor(L0.T0 i0)   {
    s0 = L0.T0.wrap(false);
    s1[bytes12(0xffffffffffffffffffffffff)] = address(this);
    unchecked {
    }
  }
  event ev1(function (bool, L0.T0[1] memory, string memory) external   indexed ep0, address payable[1] indexed ep1, function () external   returns (int136, L0.T0, address)  ep2);
  using L0 for *;
  modifier m4(C0.St0 memory i0) virtual
  {
    _;
    assembly
    {
      {
        {
        }
      }
    }
  }
}
function f2(bool i0)    
{
}
using L0 for uint;
type T1 is bytes15;
pragma solidity >= 0.0.0;
int56 constant cons1 = ((((((int56(-14848621060053390) | int56(36028797018963967)) * int56(-6147397405216194)) * int56(-244968838070412)) + int56(36028797018963967)) ** uint128(uint128(340282366920938463463374607431768211455))) - int56(36028797018963967));

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L1 {
  modifier m5() 
  {
    _;
    while (false)
    {
      unchecked {
        continue;
        {
        }
      }
      if (((((int112(-93520932394031437924877477848701) ^ (int112(-233157823541230720660683181117696) ** uint8(uint8(255)))) % int112(1640079516198223143595685672424633)) | int112(2596148429267413814265248164610047)) >= int112(0)))
      {
      }
    }
  }
  error er0();
  modifier m6(function (uint24, uint72) internal   returns (uint88, address, address) i0,uint128 i1) 
  {
    _;
  }
  modifier m7() 
  {
    _;
  }
  function f3(int168 i0,string memory i1) internal   
  {
  }
}
type T2 is bool;
// ====
// ----
