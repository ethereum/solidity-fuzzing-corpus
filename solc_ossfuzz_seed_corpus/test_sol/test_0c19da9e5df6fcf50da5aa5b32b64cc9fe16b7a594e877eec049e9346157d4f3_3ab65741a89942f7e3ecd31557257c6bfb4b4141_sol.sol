==== Source:  ====

==== Source: su0.sol ====
error er0();
struct St0 {
  uint96 el0;
}
contract C0 {
  modifier m0(bytes17 i0,int152 i1) 
  {
    if (false)
    {
      _;
      revert er0();
    }
  }
  modifier m1(int240 i0) 
  {
    _;
    _;
    _;
  }
  receive() external  m1((~(int240(726789754467888547926465062867145790136640526341970345079711145240322133)))) payable
  {
  }
  int80   s0;
  mapping(address => bool)   s1;
  bool[1]   s2;
  constructor(int80 i0,bool[1] memory i1) payable  {
    s0 %= int80(-441866067898051098761426);
    s2 = i1;
    s1[address(this)] = true;
    unchecked {
      (bool l0, bytes memory l1) = payable(this).call{value: 17482740870016928346}("");
    }
  }
  struct St1 {
    St0 el0;
    int64 el1;
    int16 el2;
    bool el3;
  }
  fallback() external  m1((int240(883423532389192164791648750371459257913741948437809479060803100646309887) * int240(0))) 
  {
  }
  event ev0(bool[1][]  ep0, string  ep1, bool  ep2);
  int56 public constant cons0 = ((((((int56(36028797018963967) % int56(0)) - int56(0)) + int56(-27985455984030737)) ** uint120(uint120(0))) % int56(-35103759625536505)) - int56(0));
  type T0 is address;
}
pragma solidity >= 0.0.0;
type T1 is bool;
contract C1 {
  bytes18 public constant cons1 = bytes18(0xffffffffffffffffffffffffffffffffffff);
  function f2(bytes calldata i0,int176 i1) public virtual  payable
  {
    while (true)
    {
    }
  }
  bool   s3 = true;
  bytes   s4;
  constructor(bytes memory i0)   {
    s4 = "000000000000000000000000000000000000007eccc6821c08f3621bdbb5813fed53";
    {
      int256[2] storage l0;
      revert er0();
    }
  }
  modifier m2() virtual
  {
    if ((false && false))
    {
      _;
    }
    for(    uint176 l0 = uint176(0);
(true && (bytes20(address(0xfAE9243952EE060C512475Df149Df5e18AbD0f2F)) < bytes20(address(0x44ed295aF68EA3808ef8dF7924cf5A4e6fa09d23))));
bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff))
    {
      (s4) = ("000000000000000000000000000000000000000098839e99537bb6c76095252b8094740d3cf5587243");
      break;
    }
    _;
    bytes13 l1 = bytes13(0x8403b7df91bca6e27b34c788eb);
  }
  event ev1();
  modifier m3() virtual
  {
    s4.pop();
    _;
  }
  error er1(C0.T0 ep0, string ep1);
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T2 is address payable;
uint48 constant cons2 = (((uint48((uint48(((uint48(0) << uint80(uint80(896334931351305084710602))) / uint48(281474976710655))) / uint48(0))) | uint48(0)) >> uint208(uint208(67202452840965558577839394583941625874274644838748549455722047))) | uint48(0));
error er2(address payable ep0);
struct St2 {
  uint16 el0;
  bool el1;
}
function f3(uint120 i0)    
{
  if (false)
  {
    revert er2(payable(address(0x0000000000000000000000000000000000000001)));
  }
  else
  {
  }
}
library L0 {
  error er3();
  function f4(int256 i0) private    returns(address o0)
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000007));
  }
  modifier m4() 
  {
    revert er3();
    _;
    while (true)
    {
      if ((true || (true || (false || true))))
      {
      }
    }
  }
  event ev2(string  ep0);
  using L0 for *;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38
}
// ----
// Warning 3149: (su0.sol:952-1055): The result type of the exponentiation operation is equal to the type of the first operand (int56) ignoring the (larger) type of the second operand (uint120) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su1.sol:98-151): The result type of the shift operation is equal to the type of the first operand (uint48) ignoring the (larger) type of the second operand (uint80) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:417-425): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:566-573): Unused local variable.
// Warning 2072: (su0.sol:575-590): Unused local variable.
// Warning 5667: (su0.sol:1277-1294): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1295-1304): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1415-1430): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1529-1549): Unused local variable.
// Warning 6133: (su0.sol:1830-1889): Statement has no effect.
// Warning 5667: (su1.sol:392-402): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:568-577): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:598-608): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:618-636): Unused local variable.
// Warning 2018: (su1.sol:380-525): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:556-704): Function state mutability can be restricted to pure
