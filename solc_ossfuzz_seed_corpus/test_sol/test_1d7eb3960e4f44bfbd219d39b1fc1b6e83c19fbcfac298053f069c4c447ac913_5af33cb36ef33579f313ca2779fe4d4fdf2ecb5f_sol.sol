
==== Source: su0.sol ====
struct St0 {
  int248 el0;
}
struct St1 {
  address el0;
  int56[][] el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  fallback() external virtual  payable
  {
    {
      bytes6 l0 = bytes6(0x000000000000);
      {
        string storage l1;
        uint56 l2 = (((uint56(((~((uint56(0) & uint56(62581214779567644)))) / uint56(0))) ** uint80(uint80(0))) - uint56(0)) - uint56(6474435740205914));
        (bool l3, bytes memory l4) = payable(this).call{value: 15365188073656131825}("");
      }
      (bool l5) = payable(this).send(0);
      (bool l6, bytes memory l7) = payable(this).call{value: 0}("");
    }
    (bool l8) = payable(this).send(8867283749524546816);
  }
  address payable   s0 = payable(address(this));
  address  public s1 = address(this);
  int24   s2;
  bool  public s3;
  constructor(int24 i0,bool i1)   {
    s2 += int24((((((true ? address(this) : address(this)) != address(this)) ? int24(8388607) : int24(8388607)) + int24(-2964004)) / int24(8388607)));
    s3 = true;
    { }
  }
  error er0(address ep0);
}
pragma solidity >= 0.0.0;
library L0 {
  function f1(address payable i0,address payable i1) private    returns(bytes6 o0)
  {
    {
      bytes14 l0 = bytes14(0xffffffffffffffffffffffffffff);
      assembly
      {
        o0 := mload(add(0x80, mod(i0, 2048)))
      }
      function () internal   l1;
      address payable l2 = (false ? payable(address(0x0000000000000000000000000000000000000003)) : payable(address(0x0000000000000000000000000000000000000008)));
      bytes15 l3 = bytes15(0x000000000000000000000000000000);
      bytes11 l4 = bytes11(0xffffffffffffffffffffff);
    }
  }
  error er1(address payable ep0);
}
using L0 for address payable;
using L0 for address payable;
// ====
// ----
