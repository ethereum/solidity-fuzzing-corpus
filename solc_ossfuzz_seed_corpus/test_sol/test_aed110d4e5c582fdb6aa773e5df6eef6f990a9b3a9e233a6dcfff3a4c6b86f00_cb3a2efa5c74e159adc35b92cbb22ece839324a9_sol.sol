
==== Source: su0.sol ====
struct St0 {
  address el0;
  uint168 el1;
}
address payable constant cons0 = payable(0x0000000000000000000000000000000000000000);
contract C0 {
  error er0(int80 ep0);
  error er1();
  type T0 is bytes21;
  event ev0(int8  ep0);
  fallback() external   
  {
    emit ev0((int8(123) * int8(0)));
  }
  receive() external virtual  payable
  {
  }
  St0[]   s0 = [St0(address(0x0000000000000000000000000000000000000007), uint168(374144419156711147060143317175368453031918731001855))];
  address   s1;
  constructor(address i0)   {
    s1 = address(this);
    unchecked {
      (bool l0) = payable(this).send(4692987426456425126);
    }
  }
  event ev1(St0  ep0);
  function f2(bytes calldata i0,C0.T0 i1) public virtual  
  {
    {
      revert("ffffffffffffffffffffffffffffffffffffffffff957810bbb258e346ca351cd8c727c63120fe6616a6df0d6b");
    }
  }
}
pragma solidity >= 0.0.0;
function f3()     returns(C0.T0 o0,function (bool[] memory, int256, bool) external   returns (C0.T0, function (C0.T0) external  , bytes5) o1)
{
  return (C0.T0.wrap(bytes21(0xffffffffffffffffffffffffffffffffffffffffff)), o1);
}
library L0 {
  bool public constant cons1 = ((bytes32(0xe56c9df1992473d9d9a25bad17eb7b02ea132c5f60ab9999a40450499bf176e2) & ((bytes32(bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) & bytes32(0x06e1d52b20dd850b253798ab3a7a70ddda7834c6abd10fd2914cead0892ac9b8)) & bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))) == bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
  modifier m0(int248 i0,address payable i1) 
  {
    if (true)
    {
      _;
    }
    bytes27 l0 = bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  }
  type T1 is uint88;
  function f4(function (function (L0.T1, function (string memory, int248) external   returns (St0 memory, int48, int160), bool[1] memory) external   returns (bool, address payable[1] memory, bool), bool) external   i0) external    returns(uint112 o0,uint136 o1,C0.T0 o2)
  {
  }
  event ev2();
  modifier m1() 
  {
    _;
    if ((int16(32767) >= ((((int16(0) ^ int16(32767)) * int16(32767)) & int16(0)) | int16(0))))
    {
      _;
      require((!(true)));
    }
    else if (false)
    {
    }
    emit ev2();
  }
  event ev3(bytes19  ep0, address  ep1);
  error er2();
}
type T2 is int56;
// ====
// ----
