
==== Source: su0.sol ====
library L0 {
  function f0(string memory i0,address payable i1,bool i2) external    returns(bool o0,address o1)
  {
    (o1) = (address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
    assert(o1 == address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
  }
  function f1(uint88[7][8][9][][][] memory i0,uint192 i1,uint16 i2) external    returns(bytes23 o0)
  {
    assembly
    {
      o0 := 0
      switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
      case 0
      {
        let al0 := extcodesize(37167587385366182740861344954563656361191406591789361765007092831522576623434)
        o0 := create2(31197506895249667779799606586490048071814772140586646065911076713884143765311, 57661907919163069595410463074982122727014763769412940072313569156346276025625, 64529061628710921000898990236160855080123322720027428073286779978997608710286, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
      case 72875950768843422090005061624564231099660089993299075218803849672906354699785
      {
        o0 := mload(add(0x80, mod(i1, 2048)))
      }
      o0 := i2
      o0 := 0
      calldatacopy(add(0x80, mod(mload(add(0x80, mod(28347858356617203137623476389256868333244766184992641576219534600884504052843, 2048))), 1024)), mload(add(0x80, mod(mload(add(0x80, mod(0, 2048))), 2048))), mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024))
    }
    i0[uint256(74367879030757407537867393764364963984154088799237141749472781445776731886367)] = new uint88[7][8][9][][](9);
  }
}
using L0 for string;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
