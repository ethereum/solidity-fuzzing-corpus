
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
type T0 is bool;
library L0 {
  event ev0();
  modifier m0(bool[1] memory i0) 
  {
    i0[0] = false;
    if (false)
    {
      _;
    }
    if (true)
    {
      while (i0[uint256(0)])
      {
        if (false)
        {
          bool l0 = (i0[0] ? false : true);
        }
        else if (true)
        {
          break;
        }
        else if (false)
        {
          break;
        }
      }
    }
    else if (true)
    {
    }
    else
    {
      (i0[0], i0, i0[0]) = (true, [true], (false && true));
    }
    if ((false && false))
    {
    }
  }
  function f0(address i0) external  m0([true]) m0([true])  returns(bool o0)
  {
    do
    {
      if (false)
      {
      }
      else
      {
        if (false)
        {
          break;
        }
        else if ((!((bytes9(0x000000000000000000) > bytes9(0xffffffffffffffffff)))))
        {
          if ((false && true))
          {
            continue;
          }
          else
          {
          }
        }
        else
        {
          break;
        }
        break;
      }
    }
    while ((int104(10141204801825835211973625643007) > int104(0)));
  }
  T0 public constant cons0 = T0.wrap(true);
  type T1 is address;
  modifier m1(uint48 i0) 
  {
    _;
    unchecked {
      L0.T1 l0 = L0.T1.wrap(address(0x0000000000000000000000000000000000000001));
    }
  }
  using L0 for *;
  function f1() external    returns(address payable o0)
  {
    while ((false ? false : false))
    {
      if (true)
      {
        break;
        break;
      }
      else
      {
        if ((true && false))
        {
          continue;
        }
        break;
      }
    }
  }
}
function f2()     returns(T0 o0,address payable o1)
{
  return (T0.wrap(true), payable(address(0x0000000000000000000000000000000000000006)));
  if (((bytes5(0xffffffffff) <= bytes5(0x2592de92f4)) && true))
  {
  }
  else
  {
  }
}
error er0();
struct St0 {
  int24 el0;
}
// ====
// ----
