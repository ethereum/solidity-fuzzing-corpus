
==== Source: su0.sol ====
library L0 {
  function f0() public   
  {
    {
      uint176 l0 = uint176(3271721516584270381416332068663928832030266466936118);
      address l1 = (true ? address(0x0000000000000000000000000000000000000001) : address(0x0000000000000000000000000000000000000005));
      int256 l2 = ((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) ^ int256(-9134938071453216085628428088196670222103062525302422666043322567355777433871)) ^ ((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) ** uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ^ int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)));
      bytes24 l3 = bytes24(0x533281fd9b75f4781144142f7d028112978debf2f6f2a346);
    }
  }
  function f1(int120 i0,bytes memory i1,bytes2 i2) internal    returns(bool o0,address o1,bool o2)
  {
    (o1) = (address(0x0000000000000000000000000000000000000003));
    assert(o1 == address(0x0000000000000000000000000000000000000003));
    function (uint24, address payable, address) external   returns (bool, address, address payable[][9][] memory) l0;
    unchecked {
      address l1 = address(0x0000000000000000000000000000000000000004);
      bool l2 = (((uint88(0) % uint88(26650947817511111495135245)) & uint160(0)) > uint160(295874801666816397660677138149280882558511882476));
      address payable l3 = payable(address(0x0000000000000000000000000000000000000008));
      uint24 l4 = uint24(16777215);
    }
  }
}
struct St0 {
  uint96 el0;
  int224[][] el1;
}
pragma solidity >= 0.0.0;
contract C0 {
  bytes14  public s0 = bytes14(0xffffffffffffffffffffffffffff);
  using L0 for *;
  using L0 for *;
}
using L0 for int120;

==== Source: su1.sol ====
contract C1 {
  bool  public s1;
  bool   s2 = false;
  uint200  public s3;
  bool immutable  s4 = false;
  constructor(bool i0,uint200 i1)   {
    s1 = false;
    s3 /= uint200(0);
    unchecked {
      uint200  l0 = s3;
      uint200  l1 = l0;
      assert(l1 == s3);
      bool  l2 = s4;
      bool  l3 = l2;
      assert(l3 == s4);
      uint200  l4 = s3;
      uint200  l5 = l4;
      assert(l5 == s3);
    }
  }
  function f2(bool i0) external   
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
    (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    (bool l4, bytes memory l5) = address(this).call(bytes("632a0e16fadea9654d4dc862999cebd407c50efde8"));
  }
  function f3() external virtual  payable returns(uint256 o0)
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
  }
}
library L1 {
}
pragma solidity >= 0.0.0;
// ====
// ----
