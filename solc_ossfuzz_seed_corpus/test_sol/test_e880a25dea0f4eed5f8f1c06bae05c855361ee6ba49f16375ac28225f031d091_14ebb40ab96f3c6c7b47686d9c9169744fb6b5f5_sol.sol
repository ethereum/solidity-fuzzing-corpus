
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(int240 i0) internal   
  {
  }
  modifier m0() 
  {
    address payable[9][][][] memory l0 = new address payable[9][][][](7);
    bool l1 = (true ? true : true);
    _;
  }
  function f1(address i0,bool i1) external  m0()  returns(bytes18[8][][4][1][8] memory o0)
  {
    o0[(o0.length - uint256(0))] = [[new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8)]];
    o0[(((o0.length ^ ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) << uint192(uint192(6277101735386680763835789423207666416102355444464034512895))) + uint256(46376543736021600678459496467862521502571630570352734529941083297414415540481))) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] = (true ? [[new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8)]] : [[new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8), new bytes18[8][](8)]]);
    function (address payable, bytes15, function (int208) external   returns (bytes5[5][] memory, function () external   returns (bool))) external   returns (uint96) l0;
  }
}
using L0 for int240;

==== Source: su1.sol ====
contract C0 {
  fallback() external   payable
  {
    bool l0 = (true ? false : true);
    assembly
    {
      let al0 := 105886852420813489427905265040708659597046350194517666320255946172119976889451
      {
      }
      switch al0
      default
      {
        al0 := 25134532385504864003651477633646226432881850041290156187416818527421504374713
      }
    }
  }
  uint208   s0;
  constructor(uint208 i0)   {
    s0 -= (uint208(40835276232244917842382442983408465416120494615685176500023443) & (uint208(411376139330301510538742295639337626245683966408394965837152255) & ((~(uint208(109652733521186217203840880888992448606009689040008273255753740))) ^ uint208(0))));
    unchecked {
      uint208  l0 = s0;
      uint208  l1 = l0;
      assert(l1 == s0);
      uint208  l2 = s0;
      uint208  l3 = l2;
      assert(l3 == s0);
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
