
==== Source: su0.sol ====
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
library L0 {
  modifier m0() 
  {
    _;
  }
  function f0(function (T0, bool[5][] memory, bool[] memory) external   returns (bool[9][][] memory, T0) i0,bool[][] memory i1) public    returns(function () external   returns (uint112, int96[] memory) o0,bool o1)
  {
  }
}
library L1 {
  function f1(function () external   i0) internal   
  {
  }
  function f2(bytes31 i0,function (uint136) external   returns (address, address payable[6] memory) i1) public    returns(T0 o0,uint192 o1)
  {
    function (int224) internal   returns (address payable) l0;
    bool l1 = ((bytes22(0x00000000000000000000000000000000000000000000) != (~(((bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff) > bytes23(0x0000000000000000000000000000000000000000000000)) ? bytes22(0xffffffffffffffffffffffffffffffffffffffffffff) : bytes22(0xffffffffffffffffffffffffffffffffffffffffffff))))) ? false : false);
    address payable l2 = (false ? payable(address(0x0000000000000000000000000000000000000003)) : payable(address(0x0000000000000000000000000000000000000005)));
  }
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
