
==== Source: su0.sol ====
contract C0 {
  event ev0(uint144  ep0, address payable  ep1, string  ep2);
  int112   s0 = int112(0);
  int40   s1;
  uint200   s2 = uint200(1606938044258990275541962092341162602522202993782792835301375);
  bool   s3 = false;
  constructor(int40 i0)   {
    s1 -= int40(0);
    unchecked {
    }
  }
  function f0(int40 i0,int112 i1) public virtual  payable   {
    if (i1 >= int112(((int112(0) % int24(8388607)) / (true ? int112(2596148429267413814265248164610047) : int112(2596148429267413814265248164610047)))))
    {
      emit ev0((true ? (~(((uint144(22300745198530623141535718272648361505980415) << uint96(uint96(79228162514264337593543950335))) ** uint192(uint192(0))))) : uint144(0)), payable(address(this)), string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    else
    {
      if (i1 != (((false ? int112((int152(0) ^ int152(0))) : int112(-531080250202927472881593943561985)) | int112(-126625997981203290428839378849600)) ** uint176(uint176(0))))
      {
        emit ev0((uint144(496259045063623882837757290678466310094125) - uint144(0)), payable(address(this)), string("This is a really long string that must ideally be random but is currently hard coded"));
      }
      if (i1 > ((((~(int16(21343))) ** uint160(uint160(901772626389272773881668422093955846672814154494))) | int112(2596148429267413814265248164610047)) | int112(2596148429267413814265248164610047)))
      {
        emit ev0((((uint144(22300745198530623141535718272648361505980415) ^ (uint144(0) - uint144(0))) | uint144(22300745198530623141535718272648361505980415)) - uint144(0)), payable(address(this)), string("This is a really long string that must ideally be random but is currently hard coded"));
        emit ev0(uint144(0), payable(this.f0.address), string("This is a really long string that must ideally be random but is currently hard coded"));
        if (i0 >= int40(549755813887))
        {
        }
      }
    }
  }
  struct St0 {
    int144 el0;
  }
  struct St1 {
    C0.St0 el0;
    C0.St0 el1;
    bytes4 el2;
    uint96[4] el3;
  }
}
struct St2 {
  bool el0;
  uint208 el1;
  bytes15 el2;
  function (bytes5) external   returns (int176, address payable, address payable) el3;
}
pragma solidity >= 0.0.0;
error er0();

==== Source: su1.sol ====
struct St3 {
  uint112 el0;
  function (uint48, uint40[] memory) external   el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
