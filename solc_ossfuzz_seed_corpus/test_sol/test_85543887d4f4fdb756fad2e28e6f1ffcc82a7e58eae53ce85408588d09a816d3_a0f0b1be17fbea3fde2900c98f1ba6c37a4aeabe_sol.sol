
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(function (function (uint104, address) external   returns (bytes memory)) external   returns (bytes3, address payable[] memory) i0,function (bytes3, bytes21, address payable) external   returns (uint24, uint112) i1,bool i2) public   
  {
    function (uint232) internal   returns (uint80, address, bool) l0;
    uint208 l1 = ((uint208(0) % uint208(164265102775777540105763177454710934153215898893972528428790421)) & ((uint208(411376139330301510538742295639337626245683966408394965837152255) | uint208(0)) << uint208(uint208(16680066965804181120570014111965282039465322798771942542022353))));
    address l2 = address(0x0000000000000000000000000000000000000006);
    bytes21 l3 = (bytes21(0xf3315acc2702908dabc6811177b218af86a9c9efbd) ^ (bytes21(0xffffffffffffffffffffffffffffffffffffffffff) | bytes21(0x331883788b660c5a87bac1295ba8f62b8ef7976ce8)));
  }
}
contract C0 {
  fallback() external virtual  
  {
  }

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(string calldata i0,bytes26 i1,bytes27 i2) external   payable
  {
    bytes12 l0 = bytes12(0x000000000000000000000000);
    string memory l1 = i0;
    assert(compareMemoryAndCalldata(l1, i0));
    int80 l3 = (int80(0) % int80(352276896616449512460585));
    string memory l4 = i0;
    assert(compareMemoryAndCalldata(l4, i0));
  }
  int256  public s0 = int256(0);
}
// ====
// ----
