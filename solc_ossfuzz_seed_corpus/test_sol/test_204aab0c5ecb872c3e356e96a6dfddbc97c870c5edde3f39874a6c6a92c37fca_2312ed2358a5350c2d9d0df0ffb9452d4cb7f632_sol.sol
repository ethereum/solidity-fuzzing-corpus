
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0();
function f0(address i0)     {
  return;
}
contract C0 {
  event ev0(bytes21[10]  ep0);
  type T0 is bytes25;
  uint248   s0 = uint248(452312848583266388373324160190187140051835877600158453279131187530910662655);
  bool   s1 = false;
  bool  public s2;
  C0.T0   s3;
  constructor(bool i0,C0.T0 i1)   {
    s2 = true;
    s3 = 2361183241434822606847 f1 /*suffix expr*/;
    unchecked {
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
    }
  }
  event ev1();
}
struct St0 {
  bool el0;
  int224[2] el1;
  uint32 el2;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10
}
function f1(int72 i0) pure suffix  returns(C0.T0 o0)
{
  if (i0 >= (int72(2361183241434822606847) - (((int56(0) ^ int72(757409444206294961517)) * int72(0)) ^ int72(1452659223817396988761))))
  {
  }
  else
  {
    if (i0 <= int72(0))
    {
    }
    bytes memory l0 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  address el0;
}
struct St2 {
  address payable el0;
  bool[] el1;
  mapping(bytes30 => St1) el2;
}
// ====
// ----
