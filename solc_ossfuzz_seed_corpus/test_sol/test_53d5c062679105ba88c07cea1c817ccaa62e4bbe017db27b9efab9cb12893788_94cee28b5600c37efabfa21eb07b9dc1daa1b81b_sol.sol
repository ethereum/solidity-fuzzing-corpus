==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  bytes20 el0;
}
bytes11 constant cons0 = ((bytes11(bytes25(((bytes11(0xffffffffffffffffffffff) | bytes11(0xffffffffffffffffffffff)) & bytes11(0xffffffffffffffffffffff)))) ^ bytes11(0xffffffffffffffffffffff)) ^ bytes11(0xffffffffffffffffffffff));
type T0 is int64;
function f0(address i0)     returns(bool o0)
{
  (bool l0) = f0({i0: address(0x0000000000000000000000000000000000000003)});
  unchecked {
    return (true);
    revert("f5f9b1c0669c8215a6a2094d29f6cc4a6cd7a0000000000000");
  }
}
contract C0 {
  modifier m0(bool i0) 
  {
    _;
    if (((((int256(0) % (int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) | int256(0))) & int256(56380528277521031000676971937859794634434923264596844617165825870422777592067)) * int256(0)) > int256(51488671511493083963070367063504466562665307236720530360008002438548015187701)))
    {
    }
    else if ((false ? f0(address(this)) : false))
    {
    }
  }
  error er0(uint56 ep0, uint144 ep1);
  int224 public constant cons1 = (~((((((int224(7701427260737760370677721029786906872092506549629905440959166340734) & int224(-9907965286658644901785385133105985187702248033685944736696958356699)) | int224(3294584133075890139805935570205221312001289796871176220362279944314)) * int224(13479973333575319897333507543509815336818572211270286240551805124607)) - int224(13479973333575319897333507543509815336818572211270286240551805124607)) + int224(0))));
  error er1(int216 ep0);
  fallback() external   payable
  {
    assembly
    {
      switch shl(115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      case 0
      {
        switch extcodesize(cons1)
        default
        {
          let al0 := balance(115792089237316195423570985008687907853269984665640564039457584007913129639935)
          al0 := 59955466848199230025520898324350435499583269293540664452678778574815893022020
        }
      }
      switch cons1
      case 0
      {
        for 
        {
          {
          }
        }
        slt(cons0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        {
          let al1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
          let al2 := cons0
        }
        {
        }
      }
      case 5113196456234815877776701520436125658408932201936146759562956829439577152183
      {
        mstore(mod(cons0, 2048), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
      case 45141766372798864984418440943628529842261390394622916709712572836496778637511
      {
      }
      default
      {
      }
    }
    if (false)
    {
      while (true)
      {
        for(        bool l0 = (int120(-417895440597543248256711034024321296) < int120(664613997892457936451903530140172287));
((true && true) || (!(false)));
)
        {
          bytes[1] memory l1 = ["88646687364b4c8a183b657613ab6b701b84b44e9cefad651d452f5aff6f89bf872a14f6fb91b5ab169e01431827ced9d997a299f6"];
          bytes15 l2 = bytes15(0xf81a9d87aca37d8499dd73cc551456);
          unchecked {
            delete l1[0];
          }
        }
      }
    }
    else if (((uint72(0) <= ((uint72(1009885614908126883007) ^ uint72(22302069714023717562)) & uint72(2388580381953466925247))) && false))
    {
    }
  }
  event ev0();
  int48  public s0 = int48(0);
  bytes12  public s1;
  constructor(bytes12 i0) payable  {
    s1 ^= bytes12(0x64f3de27129e8f281243a5aa);
    { }
  }
  type T1 is uint256;
  modifier m1() virtual
  {
    _;
    if (f0({i0: address(this)}))
    {
      for(      uint96 l0 = (~(uint96(78334355003143874245043300688)));
;
)
      {
        payable(this).transfer(666652735610469399);
      }
    }
    else
    {
    }
    emit ev0();
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:507-3848): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 9592: (su0.sol:1727-1992): "switch" statement with only a default case.
// TypeError 7615: (su0.sol:1746-1751): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 7615: (su0.sol:2014-2019): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 7615: (su0.sol:2110-2115): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 7615: (su0.sol:2328-2333): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 7615: (su0.sol:2487-2492): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 9574: (su0.sol:2958-3089): Type string memory[1] memory is not implicitly convertible to expected type bytes memory[1] memory.
