
==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
  }
  mapping(int216 => bool)  public s0;
  constructor()   {
    s0[int216(52656145834278593348959013841835216159447547700274555627155488767)] = (true ? false : ((bytes20(address(0xDdD3f91d65B7F5Ae550a54291B3FAb8DdEB9bbC0)) == bytes20(address(0x0000000000000000000000000000000000000000))) ? true : true));
    unchecked {
      {
      }
    }
  }
}
int24 constant cons0 = 0;
library L0 {
  function f1(bool[2][][10][3][][] memory i0) external    returns(uint8 o0,uint208 o1,uint80 o2)
  {
    bytes6 l0 = bytes6(((~(bytes18(0x000000000000000000000000000000000000))) & (bytes18(0x000000000000000000000000000000000000) ^ bytes18(0xffffffffffffffffffffffffffffffffffff))));
    (i0[i0.length]) = (new bool[2][][10][3][](4));
  }
  function f2() external    returns(bytes21 o0)
  {
    for(    uint80 l0 = uint80(0);
;
)
    {
      o0 ^= bytes21(0x000000000000000000000000000000000000000000);
    }
    unchecked {
    }
  }
  function f3(address payable i0) internal    returns(uint208 o0)
  {
    int8 l0 = ((int8(((int8(127) & (int8(127) * int8(127))) / int8(127))) + int8(0)) % int8(-82));
    bytes6 l1 = bytes6(0xec820d9e6661);
  }
}
pragma solidity >= 0.0.0;
using L0 for bool[2][][10][3][][];
// ====
// ----
