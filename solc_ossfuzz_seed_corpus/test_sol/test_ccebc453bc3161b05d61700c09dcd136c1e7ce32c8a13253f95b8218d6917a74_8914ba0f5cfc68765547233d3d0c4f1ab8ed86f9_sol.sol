
==== Source: su0.sol ====
struct St0 {
  bytes12 el0;
  uint8 el1;
  bytes el2;
}
pragma solidity >= 0.0.0;
struct St1 {
  bool el0;
  function () external   el1;
  bytes el2;
  mapping(bool => St0) el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St2 {
  bool el0;
  mapping(address => bool) el1;
  bytes20 el2;
}
contract C0 {
  error er0();
  uint16   s0;
  bytes  public s1 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1590efb9aa4527575d1d");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint96   s2;
  int208   s3;
  constructor(uint16 i0,uint96 i1,int208 i2)   {
    s0 /= (uint16(0) - (uint16(57759) * (uint8(255) % uint8(255))));
    s2 /= uint96(int96(((uint96(0) * uint96(0)) + uint96(79228162514264337593543950335))));
    s3 &= int208(197082267057368174983419641746319989341176202688410895607533036);
    unchecked {
    }
  }
  receive() external   payable
  {
    s1.push("\xb8");
  }
  function f1() public virtual     {
    do
    {
      s1.push("\x24");
      if (false)
      {
        continue;
      }
      else if (false)
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
        break;
      }
    }
    while (false);
    s1.push();
  }
}
// ====
// ----
