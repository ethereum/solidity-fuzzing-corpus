
==== Source: su0.sol ====
struct St0 {
  int200 el0;
  bool el1;
  address payable el2;
}
contract C0 {
  uint232 public constant cons0 = 1778522852649290139090589069570508968355497431114852526826874296913015;
  error er0(uint184 ep0, uint120 ep1);
  struct St1 {
    uint72 el0;
    string el1;
    bytes1 el2;
    address[] el3;
  }
  mapping(bytes29 => address)   s0;
  bytes23  public s1 = bytes23(0xbd578c96fc2b6bf74418659bf5b4c0eff638033f57dde4);
  int256 immutable  s2 = int256(0);
  constructor() payable  {
    s0[bytes29(bytes6(0x000000000000))] = s0[bytes29(0xc9e45ba7c68c62f1069b3316fd007054303c9e81f1eb2dc2be64e82451)];
    {
    }
  }
  function f0(uint112 i0,int256 i1) private      {
    return;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f1(bytes7 i0,uint96 i1)      returns(function () external   returns (bytes18) o0){
  if (i1 >= i1)
  {
  }
}
struct St2 {
  bytes12[] el0;
  string el1;
  address el2;
  function () external   el3;
}
function f2()     {
  function (bytes12, address payable, bytes17) internal   returns (string memory)[] memory l0 = new function (bytes12, address payable, bytes17) internal   returns (string memory)[](1);
}
// ====
// ----
