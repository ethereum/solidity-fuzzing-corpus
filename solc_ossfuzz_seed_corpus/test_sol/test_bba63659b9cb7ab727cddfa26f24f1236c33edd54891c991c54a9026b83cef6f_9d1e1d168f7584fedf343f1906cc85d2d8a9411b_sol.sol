==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  error er0(function (bool, function (uint136) external   returns (bool)) external   returns (bytes3, function (int72, bytes22, uint24[][1] memory) external   returns (uint96), int104) ep0, bytes31 ep1);
  function f0() external   
  {
    if (true)
    {
      bool l0 = true;
    }
    else if (false)
    {
      while (false)
      {
      }
    }
    else
    {
      assembly
      {
        let al0 := 34527333396123446772779476948810924287269926931525176412327813344764378964921
      }
    }
  }
  function f1(bool i0) external    returns(int168 o0,uint88 o1)
  {
  }
  type T0 is address payable;
  modifier m0(function (L0.T0, function (int112, function (bytes26, address payable) external   returns (int184, int64), bytes30) external   returns (bool, bool, bool), bool) external   returns (uint240) i0) 
  {
    bytes10 l0 = bytes10(0xffffffffffffffffffff);
    _;
  }
  bytes1 public constant cons0 = (bytes1((bytes10(0x00000000000000000000) | ((bytes10(0xffffffffffffffffffff) | bytes10(0x00000000000000000000)) | bytes10(0x397fb0a4dbcb5e5068ec)))) ^ bytes1(0xff));
  address public constant cons1 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
}
contract C0 {
  struct St0 {
    string el0;
    bool el1;
    uint80 el2;
  }
  event ev0(function (bytes memory) external   returns (C0.St0 memory)  ep0);
  L0.T0 public constant cons2 = L0.T0.wrap(payable(address(0x0000000000000000000000000000000000000005)));
  event ev1();
  fallback() external virtual  
  {
    do
    {
    }
    while (false);
  }
  bytes18   s0;
  bool  public s1 = true;
  mapping(address => bytes14)   s2;
  constructor(bytes18 i0)   {
    s0 ^= bytes18(0xffffffffffffffffffffffffffffffffffff);
    s2[address(this)] &= bytes14(0x2980797604006cb1e3322d0b7455);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffffffffff");
      address payable l2 = payable(address(this));
    }
  }
  modifier m1() virtual
  {
    do
    {
      _;
    }
    while (true);
    s0 ^= bytes18(0x000000000000000000000000000000000000);
    if (true)
    {
    }
    else if (false)
    {
      do
      {
        _;
        continue;
      }
      while (false);
    }
    else if (true)
    {
      _;
      for(      bool l0 = false;
;
)
      {
        break;
        emit ev1();
      }
      _;
      (bool l1, bytes memory l2) = address(this).call(bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    }
    unchecked {
      revert("f6001e19ec162d6303393663ae475e83b81cefcdbe001406c4f93012f779fc98f807a8a3cee09b54a6");
      L0.T0 l3 = L0.T0.wrap(payable(address(0x0000000000000000000000000000000000000001)));
    }
  }
}
type T1 is int120;
function f3(uint168 i0)     returns(address o0,bool o1)
{
}
// ----
// Warning 2072: (su0.sol:301-308): Unused local variable.
// Warning 5667: (su0.sol:1647-1657): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1811-1818): Unused local variable.
// Warning 2072: (su0.sol:1820-1835): Unused local variable.
// Warning 2072: (su0.sol:1919-1937): Unused local variable.
// Warning 2018: (su0.sol:245-543): Function state mutability can be restricted to pure
