
==== Source: su0.sol ====
struct St0 {
  bool el0;
  function (uint88, string memory, uint184) external   returns (bytes30, uint232, bytes memory) el1;
  mapping(address => address) el2;
}
error er0();
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27
}

==== Source: su1.sol ====
error er1();
type T0 is bytes22;
contract C0 {
  T0 public constant cons0 = T0.wrap(bytes22(0x00000000000000000000000000000000000000000000));
  receive() external virtual  payable
  {
    do
    {
    }
    while (false);
  }
  type T1 is address payable;
  error er2();
  function f1(bool i0,bytes26 i1) external virtual  payable
  {
    unchecked {
      if ((((int240(((int240(883423532389192164791648750371459257913741948437809479060803100646309887) * int240(0)) / int240(0))) % int240(0)) & int240(-545647214491075039642732478529431287516566092325146226024622394389069379)) >= int240(883423532389192164791648750371459257913741948437809479060803100646309887)))
      {
      }
      else
      {
        revert er2();
      }
      return;
      uint152 l0 = (uint152(5708990770823839524233143877797980545530986495) % uint152(2425448942401419571137649890904532874079223858));
    }
    if ((false && (int88(-96918357651910151776391710) == int88(0))))
    {
    }
    else
    {
      return;
    }
  }
  C0.T1   s0 = C0.T1.wrap(payable(address(0x0000000000000000000000000000000000000007)));
  int72  public s1;
  constructor(int72 i0)   {
    s1 ^= (int72(8362105727793089383) + ((int72(2361183241434822606847) % (int72(859082406668460167753) | int72(780547089828418502424))) + int72(-1498626042862219802583)));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
