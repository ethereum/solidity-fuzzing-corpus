
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    function () external   returns (bool) el0;
  }
  fallback() external   
  {
    do
    {
      continue;
    }
    while (false);
    while (true)
    {
      payable(this).transfer(5538898853496323882);
      for(;
false;
payable(address(this)))
      {
      }
    }
  }
  uint208   s0 = uint208(403884181769677891031704234690006159071294441043055298766608142);
  bool[]   s1;

	function compareMemoryAndStorage(bool[] memory v1, bool[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bytes5   s2 = bytes5(0xdd9eac7848);
  int112   s3 = int112(2596148429267413814265248164610047);
  constructor(bool[] memory i0)   {
    s1 = i0;
    unchecked {
    }
  }
  struct St1 {
    bytes1 el0;
    address payable el1;
    uint8 el2;
    int192 el3;
  }
  receive() external   payable
  {
    s1.push((false ? true : (false ? (uint160(0) <= uint160(1210833275320644235612639954010928117153472572753)) : false)));
    s1.push(s1[((uint256(58351954739203916034379370090956442428447567001453173124502925901038414361262) | ((uint256(70282357144924672502340574052290901128867639901591306169481606418538459385294) * uint256(0)) & uint256(0))) % uint256(2850329059692972076524912284967209900857103616011580995847640575913717333244))]);
  }
  type T0 is int112;
  error er0();
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St2 {
  int48 el0;
  bytes el1;
  int136 el2;
}
struct St3 {
  St2 el0;
  bytes el1;
  bytes el2;
  mapping(address => mapping(address => int32[])[]) el3;
}
// ====
// ----
