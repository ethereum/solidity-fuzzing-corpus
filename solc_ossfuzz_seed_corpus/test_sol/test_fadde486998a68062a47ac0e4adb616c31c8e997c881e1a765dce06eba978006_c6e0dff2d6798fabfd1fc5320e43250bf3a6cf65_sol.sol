
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()      returns(bytes7 o0){
  return (bytes7(0x7141572e2fd25c));
}

==== Source: su1.sol ====
contract C0 {
  fallback() external virtual  
  {
  }
  event ev0(int32  ep0, int240  ep1);
  uint16   s0 = uint16(54721);
  event ev1(uint56 indexed ep0, bool indexed ep1);
}
pragma solidity >= 0.0.0;
struct St0 {
  bytes1 el0;
  bytes11 el1;
  bytes5 el2;
  bool el3;
}
struct St1 {
  uint112 el0;
  mapping(bytes16 => bool) el1;
  int120 el2;
}
contract C1 {
  error er0(function (int16, address) external   ep0);
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
  St1[]   s1;
  address payable  public s2;
  uint96   s3;
  bool  public s4 = true;
  constructor(address payable i0,uint96 i1) payable  {
    s2 = payable(address(this));
    s3 += uint96(0);
    unchecked {
    }
  }
  receive() external virtual  payable
  {
    if (true)
    {
      payable(this).transfer(11484033173886895696);
      return;
    }
  }
  function f3(address payable i0) public virtual  payable  returns(bytes memory o0)  {
    if (i0 < payable(address(this)))
    {
      bytes4(0x00000000);
    }
    return ((false ? bytes("4bac7dfb7165b3b2eeba29411bfc714470ffffffffffffffffffffffffffffff") : bytes("ffffffffffffffffffffffffffffffffffffffffff")));
  }
  function f4(int8 i0,bool i1) public     returns(bool o0,function (St0 memory) external   returns (function (St0 memory, int56) external   returns (int136, function () external   returns (address, bytes21)), bool, int184[] memory) o1)  {
    s1.pop();
    return (true, o1);
  }
  function f5() public      {
    assert(true);
    s1.pop();
    if (false)
    {
      return;
    }
  }
}
// ====
// ----
