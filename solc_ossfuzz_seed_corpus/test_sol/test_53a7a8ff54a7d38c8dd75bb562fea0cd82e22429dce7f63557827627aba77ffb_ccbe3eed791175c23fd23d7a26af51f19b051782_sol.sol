
==== Source: su0.sol ====
function f0()     {
  do
  {
    break;
  }
  while ((uint8((((true ? uint8(126) : uint8(159)) * uint8(0)) / uint8(255))) < uint8(255)));
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
address payable constant cons0 = payable(0x5Be9D62eF4603237c459520b8F7fC429be9a6437);
function f1(uint224 i0)      returns(int216 o0,bytes14 o1){
  o1 |= bytes14(0x7148e0f06ac6337ab514fef3f1c1);
  o1 |= bytes14(bytes25(0x00000000000000000000000000000000000000000000000000));
}
contract C0 {
  bool   s0 = false;
  bytes20   s1;
  mapping(uint56 => bytes16)  public s2;
  address payable   s3 = payable(address(this));
  constructor(bytes20 i0)   {
    s1 |= (bytes20(address(this)) ^ bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    s2[uint56(72057594037927935)] ^= bytes16(0x99a74a827d48350789b21d9f9ea111b4);
    unchecked {
      if (i0 == (bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) & ripemd160(bytes("ffffffffffffffff0000000000000000000000"))))
      {
        if (i0 >= (i0 |= ripemd160(bytes("ffffffffffffffffffffffffff"))))
        {
          revert(string("This is a really long string that must ideally be random but is currently hard coded"));
        }
        if (i0 == ripemd160(bytes("00000000000000000000000000000000")))
        {
        }
        else
        {
          (s3) = (payable(address(this)));
          assert(s3 == payable(address(this)));
        }
      }
      else
      {
      }
    }
  }
  type T0 is bool;
  event ev0(function (uint16) external   returns (address, address)  ep0);
  event ev1(int56  ep0, bytes6  ep1);
  struct St0 {
    int224 el0;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
