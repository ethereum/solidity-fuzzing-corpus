==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
int32 constant cons0 = (((((~((int32(0) + int32(2147483647)))) ^ int32(0)) * int32(0)) ^ int32(-2134154618)) - int32(250881450));
function f0(int64 i0)     returns(bytes11 o0,bytes11 o1,bytes29[] memory o2)
{
}
contract C0 {
  event ev0();
  bool  public s0 = false;
  bool   s1 = true;
  struct St0 {
    address el0;
    bytes11 el1;
    int96 el2;
    bool el3;
  }
  function f1(bytes3 i0,function (bytes memory, bytes memory) external   returns (bool, bytes31) i1) private   
  {
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103

  }
  fallback() external   
  {
    (bool l0, bytes memory l1) = address(this).call("0000000000000000000000000000000000000000000000000000000000000000000000");
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19
  }
}
type T0 is bytes20;
contract C1 {
  type T1 is int120;
  mapping(bytes5 => T0)  public s2;
  int64   s3 = int64(9223372036854775807);
  bytes10  public s4;
  constructor(bytes10 i0) payable  {
    s4 |= (i0 |= bytes10(0x00000000000000000000));
    s2[bytes5(0x5ecef71c4d)] = T0.wrap(bytes20(address(0x3DbD4cD50DEa8EBbf1507984a27EB2598f9C065e)));
    unchecked {
      (bytes11 l0, bytes11 l1, bytes29[] memory l2) = f0(int64(((((((int64(0) * int64(0)) + int64(3708076465626605043)) ** uint56(uint56(72057594037927935))) % int64(0)) * int64(0)) / int64(4323253715356544625))));
      {
        for(        0;
;
)
        {
          (bool l3, bytes memory l4) = address(this).call("ffffffffffffffffffffffff00000000000000000000000000000000");
          break;
          if (false)
          {
            (l1, l2[1]) = (bytes11(0x0000000000000000000000), bytes29(0xbf2d9181bf07692dd944c1de0c0741665051fecb02c1ae8e579a0ba0d2));
          }
        }
      }
    }
  }
  struct St1 {
    bool el0;
    uint160 el1;
  }
  error er0();
  function f3(uint192 i0,function () external   returns (address, address payable) i1) public virtual   returns(bool o0,uint64 o1,int96 o2)
  {
    if (((((((uint72(4722366482869645213695) + uint72(4722366482869645213695)) << uint80(uint80(4136686376473219631316))) << uint128(uint128(0))) << uint216(uint216(68901745260789912697684260883617624414618282541694648086750439054))) << uint136(uint136(87112285931760246646623899502532662132735))) != uint72(4722366482869645213695)))
    {
      try i1() returns (address l0, address payable l1)
      {
      }
      catch
      {
        (address l2, address payable l3) = i1();
        (bool l4, bytes memory l5) = address(this).call("7dbe0e713455e0419943dac2c647d5fa2c0205be00000000000000000000000000000000000000000000000000000000");
      }
    }
  }
  event ev1(function () external    ep0);
  enum EN2 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
function f4(string memory i0,uint88 i1,uint176 i2)     returns(function (address payable, bool) external   returns (address payable[] memory, bytes27) o0,bool o1,int216[2] memory o2)
{
  require(true, "ecdcd2e7cadb78cdb4603e23d2eea59348f93f92094b00000000000000000000000000000000");
}
// ----
// Warning 3149: (su0.sol:2565-2672): The result type of the shift operation is equal to the type of the first operand (uint72) ignoring the (larger) type of the second operand (uint80) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:2564-2696): The result type of the shift operation is equal to the type of the first operand (uint72) ignoring the (larger) type of the second operand (uint128) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:2563-2784): The result type of the shift operation is equal to the type of the first operand (uint72) ignoring the (larger) type of the second operand (uint216) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:2562-2848): The result type of the shift operation is equal to the type of the first operand (uint72) ignoring the (larger) type of the second operand (uint136) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:2146-2314): Unreachable code.
// Warning 2072: (su0.sol:1132-1139): Unused local variable.
// Warning 2072: (su0.sol:1141-1156): Unused local variable.
// Warning 6133: (su0.sol:1983-1984): Statement has no effect.
// Warning 2072: (su0.sol:1747-1757): Unused local variable.
// Warning 2072: (su0.sol:2011-2018): Unused local variable.
// Warning 2072: (su0.sol:2020-2035): Unused local variable.
// Warning 5667: (su0.sol:2422-2432): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2520-2527): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2528-2537): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2538-2546): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2916-2926): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2928-2946): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2993-3003): Unused local variable.
// Warning 2072: (su0.sol:3005-3023): Unused local variable.
// Warning 2072: (su0.sol:3042-3049): Unused local variable.
// Warning 2072: (su0.sol:3051-3066): Unused local variable.
// Warning 5667: (su1.sol:56-72): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:73-82): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:83-93): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:107-197): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:198-205): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:206-225): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:44-327): Function state mutability can be restricted to pure
