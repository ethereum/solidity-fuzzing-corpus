
==== Source: su0.sol ====
function f0()    
{
}
address payable constant cons0 = payable(address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
type T0 is bool;
library L0 {
  event ev0() anonymous;
  bool public constant cons1 = false;
  modifier m0(int208 i0) 
  {
    _;
    emit L0.ev0();
    if (cons1)
    {
    }
    else if (false)
    {
    }
    else
    {
    }
  }
  int32 public constant cons2 = int32((((((int32((int32(0) / int32(2147483647))) ** uint256(uint256(3287932885197342661261131545200103265548820951827196598052644630121787405134))) ^ int32(0)) ** uint152(uint152(5611515133490030882914403760808104692568805671))) ^ int32(2147483647)) / int32(0)));
  error er0();
  modifier m1(T0 i0) 
  {
    _;
    string memory l0 = string("ffffffffffffffffffffffffff5739e5d1ede7ebe857ee65d3c79e72acad830b56ea");
  }
  event ev1() anonymous;
  type T1 is int72;
  using L0 for *;
  function f1(address payable i0,uint48[2][] memory i1,L0.T1 i2) public    returns(int40 o0)
  {
  }
  modifier m2() 
  {
    _;
    _;
  }
}
using L0 for uint;
pragma solidity >= 0.0.0;
contract C0 {
  error er1();
  using L0 for *;
  modifier m3() virtual
  {
    _;
  }
  event ev2(bool  ep0, address  ep1);
  type T2 is bytes15;
  L0.T1[][2]   s0 = [[L0.T1.wrap(int72(0)), L0.T1.wrap(int72(2361183241434822606847))], [L0.T1.wrap(int72(2361183241434822606847))]];
  bytes32  public s1 = bytes32(0x9004d6de5233b83d19d518ecbda4874a89d8c4243a59c6b8dad9e5002784d597);
  bytes3   s2;
  constructor(bytes3 i0)   {
    s2 ^= bytes3(0xcca480);
    unchecked {
      if (false)
      {
        emit L0.ev1();
      }
      else if (false)
      {
      }
      emit ev2(false, address(this));
      s0[0] = [L0.T1.wrap(int72(-2048689534856587861092))];
      emit ev2(true, address(this));
    }
  }
  modifier m4(bytes memory i0,int248 i1) virtual
  {
    _;
  }
  fallback() external virtual m3() 
  {
    for(;
;
[int88(145983178687293309140834420), int88(0)])
    {
      revert L0.er0();
      revert L0.er0();
    }
  }
  modifier m5() virtual
  {
    function () external   l0;
    _;
  }
}

==== Source: su1.sol ====
struct St0 {
  int232 el0;
  mapping(address => mapping(uint160 => int8)) el1;
}
library L1 {
  modifier m6() 
  {
    _;
    assembly
    {
    }
  }
  modifier m7() 
  {
    if (((int8(0) ^ (((int8(127) * int8(-30)) * int8(0)) % int8(127))) != int8(127)))
    {
      _;
    }
    else
    {
    }
  }
  modifier m8() 
  {
    _;
    function () external   l0;
    l0();
  }
  uint96 public constant cons3 = ((uint96(0) & (((~(uint96(79228162514264337593543950335))) + uint96(39984830147060657121407729610)) - uint96(0))) & uint96(0));
  function f3() external    returns(uint152 o0,uint64 o1)
  {
  }
  function f4(bytes19 i0,function (address, address payable, uint32) external   returns (bytes29, bytes11) i1,function (address) external   returns (int176[] memory, address payable[2] memory) i2) public  m6()  returns(bytes22 o0,int96 o1)
  {
  }
  address payable public constant cons4 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
}
using L1 for uint;
bool constant cons5 = false;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16
}
pragma solidity >= 0.0.0;
// ====
// ----
