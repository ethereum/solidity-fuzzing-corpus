==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  uint200 public constant cons0 = (~(((~((~(((uint200(1606938044258990275541962092341162602522202993782792835301375) ** uint96(79228162514264337593543950335)) ** uint48(281474976710655)))))) ** uint16(509))));
  event ev0(bytes9 indexed ep0, bytes21  ep1, function (int16) external   returns (address, bytes31, address)  ep2);
  int56 public constant cons1 = ((~(((((int56(0) ** uint248(0)) ** uint112(5192296858534827628530496329220095)) ** uint8(86)) ** uint96(79228162514264337593543950335)))) ** uint224(4374478642704347435280026302661891087397979061162201335726424809266));
  type T0 is address;
  using L0 for *;
  modifier m0(uint232 i0) 
  {
    _;
  }
}
contract C0 {
  event ev1(address  ep0);
  bytes  s0;
  bool  s1;
  constructor(bytes memory i0,bool i1) payable  {
    s0 = bytes("8266556f178a43f404973835d4aeb13ba41075a43aa94555d8f942b524c3bb1fb146715f79b6d60294");
    s1 = i1;
    unchecked {
    }
  }
  struct St0 {
    address el0;
    string el1;
    uint184[2][2] el2;
  }
  address public constant cons2 = 0x78b444875aF9242e25550ad7Df6FcD0F7EbC8B93;
}
function f0()     returns(C0.St0 memory o0,C0.St0 memory o1)
{
  if ((bytes9(0x000000000000000000) <= bytes9(0xffffffffffffffffff)))
  {
    assembly
    {
      pop(o1)
      for 
      {
      }
      sload(115792089237316195423570985008687907853269984665640564039457584007913129639935)
      {
        o0 := o0
      }
      {
        switch o1
        case 101102396354533362413551050157336031433252106461396248741148914122205965196678
        {
          let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
        }
        default
        {
          function af0(ai0, ai1) -> ao0, ao1
          {
            let al1 := ao1
            for 
            {
              let al2 := delegatecall(115792089237316195423570985008687907853269984665640564039457584007913129639935, 0, 5925003462806022687567149282186052424208587706017490036185634078388993224482, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
              stop()
            }
            ai0
            {
              let al3, al4 := af0(22633627527391814955013144786922177888941928995919683174918541970318567085306, mload(mod(0, 2048)))
              leave
            }
            {
              let al5 := 0
            }
            ai1 := ao1
          }
          break
          break
        }
        o0 := o1
        stop()
        o0 := 0
      }
    }
  }
  else if (false)
  {
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94, M95,
  M96, M97
}

==== Source: su1.sol ====
uint8 constant cons3 = uint8((((~((~((~(uint152(5708990770823839524233143877797980545530986495))))))) ** uint176(0)) ** uint40(1099511627775)));
error er0(uint192 ep0, address ep1);
type T1 is bytes23;
pragma solidity >= 0.0.0;
import "su0.sol";
struct St1 {
  bool el0;
  C0.St0 el1;
  C0.St0 el2;
  C0.St0 el3;
}
// ----
// Warning 3149: (su0.sol:406-428): The result type of the exponentiation operation is equal to the type of the first operand (int56) ignoring the (larger) type of the second operand (uint248) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:405-476): The result type of the exponentiation operation is equal to the type of the first operand (int56) ignoring the (larger) type of the second operand (uint112) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:403-532): The result type of the exponentiation operation is equal to the type of the first operand (int56) ignoring the (larger) type of the second operand (uint96) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:399-615): The result type of the exponentiation operation is equal to the type of the first operand (int56) ignoring the (larger) type of the second operand (uint224) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su1.sol:31-115): The result type of the exponentiation operation is equal to the type of the first operand (uint152) ignoring the (larger) type of the second operand (uint176) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:1419-1427): Unreachable code.
// Warning 5740: (su0.sol:2526-2531): Unreachable code.
// Warning 5740: (su0.sol:2582-2589): Unreachable code.
// Warning 5667: (su0.sol:782-797): Unused function parameter. Remove or comment out the variable name to silence this warning.
