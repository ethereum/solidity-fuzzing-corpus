
==== Source: su0.sol ====
library L0 {
  error er0(bool ep0, bytes1 ep1);
  function f0() internal   
  {
    bytes8 l0 = (bytes8(0x0000000000000000) | bytes8(0x0000000000000000));
  }
}
pragma solidity >= 0.0.0;
library L1 {
  function f1() external   
  {
    unchecked {
      {
      }
      bool l0 = false;
      assembly
      {
        let al0 := l0
        returndatacopy(add(0x80, mod(0, 1024)), sload(0), mod(al0, 1024))
      }
      int224 l1 = (((int96(39614081257132168796771975167) + (int96(0) * int96(-2143485627792342847385330736))) + int96(25351357218882482699597338587)) ^ int96(-29458648761034727111903241710));
    }
  }
  function f2(bytes2 i0,function (bool) external   returns (bytes memory) i1) internal    returns(bytes7 o0)
  {
    assert((true ? true : false));
    bool l0 = (false ? (int136(43556142965880123323311949751266331066367) >= (int136(36537779880751701261224875519638288214084) + int136(43556142965880123323311949751266331066367))) : true);
  }
  event ev0(bytes9  ep0, bool  ep1, function () external   returns (int96, uint96)  ep2, address indexed ep3);
}

==== Source: su1.sol ====
function f3()    
{
  bytes memory l0 = (true ? bytes("ffffffffffff000000000000000000000000") : msg.data);
}
struct St0 {
  int56 el0;
  address payable el1;
  int8[][] el2;
  int8 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
