
==== Source: su0.sol ====
function f0()     {
}
function f1(bytes3 i0)      returns(function () external   o0){
  delete o0;
}
pragma solidity >= 0.0.0;
struct St0 {
  address payable el0;
  address el1;
}
contract C0 {
  event ev0(bytes indexed ep0);
  int56  public s0 = int56(0);
  int256   s1;
  constructor(int256 i0) payable  {
    s1 += (((false ? ((int256(0) * int256(-12581235526397753524030128786362324785937945135635685140810674926053325504292)) * int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) : int256(-14296807836923916026016459879945534813698224064260164367266740030319160521349)) % int256(0)) ** uint32(uint32(1488733815)));
    unchecked {
    }
  }
  fallback() external virtual  
  {
    int256  l0 = s1;
    int256  l1 = l0;
    assert(l1 == s1);
    emit ev0(bytes("ffffff0000000000"));
  }
}

==== Source: su1.sol ====
struct St1 {
  bool el0;
}
pragma solidity >= 0.0.0;
contract C1 {
  event ev1(St1 indexed ep0, bool[4]  ep1);
  function f3(function () external   returns (St1 memory, uint184, int200[7][2] memory) i0) external   payable  returns(address o0)  {
  }
  function f4(bytes9 i0,int16 i1) public virtual     {
    for(uint solinit0 = 0; solinit0 < ((uint256(14775482402269442646854712321280830093973561604191149797810506332311934336226) << uint128((uint128(((uint16(65535) % uint128(340282366920938463463374607431768211455)) / uint128(340282366920938463463374607431768211455))) % uint128(307022461570906864302306029289734401394)))) % 11); solinit0++)
    {
      break;
    }
  }
  St1  public s2;

	function compareMemoryAndStorage(St1 memory v1, St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  St1   s3 = St1(false);
  int72  public s4 = int72(26533360335590647603);
  function f5() public virtual     {
    (bool l0, bytes memory l1) = address(this).call(bytes("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    return;
  }
}
// ====
// ----
