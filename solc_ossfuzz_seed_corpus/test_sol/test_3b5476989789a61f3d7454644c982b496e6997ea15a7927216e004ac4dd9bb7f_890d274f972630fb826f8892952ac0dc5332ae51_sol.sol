
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address el0;
}
contract C0 {
  fallback() external   payable
  {
    payable(this).transfer(0);
    int248 l0 = (((-(int248(0))) & ((int248(0) | int248(0)) ** uint224(uint224(26959946667150639794667015087019630673637144422540572481103610249215)))) + int248(0));
    address l1 = address(this);
    l0 /= (int248(226156424291633194186662080095093570025917938800079226639565593765455331327) & (int248(226156424291633194186662080095093570025917938800079226639565593765455331327) ^ int248(226156424291633194186662080095093570025917938800079226639565593765455331327)));
  }
  receive() external   payable
  {
    payable(this).transfer(0);
    bytes9 l0 = bytes9(0xffffffffffffffffff);
  }
  uint256  public s0;
  mapping(address => uint208)   s1;
  bytes28 immutable  s2;
  constructor(uint256 i0,bytes28 i1)   {
    s0 >>= (~((((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(0)) * uint256(0)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) << uint136(uint136(0))) >> uint120(uint120(0)))));
    s2 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
    s1[address(bytes20(address(0x0000000000000000000000000000000000000000)))] = uint208(0);
    unchecked {
      uint256  l0 = s0;
      uint256  l1 = l0;
      assert(l1 == s0);
      bytes28  l2 = s2;
      bytes28  l3 = l2;
      assert(l3 == s2);
      payable(this).transfer(2395338279923255141);
      bytes28  l4 = s2;
      bytes28  l5 = l4;
      assert(l5 == s2);
    }
  }
}
// ====
// ----
