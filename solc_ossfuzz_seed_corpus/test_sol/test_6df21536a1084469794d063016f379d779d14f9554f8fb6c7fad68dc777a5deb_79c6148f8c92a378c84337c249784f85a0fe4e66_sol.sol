
==== Source: su0.sol ====
struct St0 {
  int216 el0;
  address el1;
  bytes el2;
}
contract C0 {
  function f0() internal virtual     {
  }
  bool   s0 = true;
  function f1() public   payable  returns(address payable o0)  {
    for(    function () internal   returns (uint152, function () external   returns (address, int16), int216) l0;
;
)
    {
      (bool l1, bytes memory l2) = address(this).call(bytes("00000000000000000000000000000000000000000000000000000000000000"));
    }
    bool  l3 = s0;
    bool  l4 = l3;
    assert(l4 == s0);
  }
  struct St1 {
    address el0;
    uint160 el1;
    St0 el2;
  }
  function f2(bool i0) private     returns(address o0,address payable o1,bool[] memory o2)  {
    delete o1;
    return (msg.sender, payable(address(this)), new bool[](8));
  }
}
function f3(address payable i0,int104 i1,bool i2)      returns(uint112 o0,int216 o1,uint168 o2){
  (bytes19(0x00000000000000000000000000000000000000) | (true ? ((bytes19(0x00000000000000000000000000000000000000) & bytes19(0xffffffffffffffffffffffffffffffffffffff)) & bytes19(0x00000000000000000000000000000000000000)) : bytes19(0x00000000000000000000000000000000000000)));
  return ((uint112(0) * uint112(2416630820789113800661740940128749)), int216((int216(34219283130091822164079788640725609436971469059065996661971260277) / (int216(0) % int216(52656145834278593348959013841835216159447547700274555627155488767)))), uint168(110091444593773015690066034763590470593815181586877));
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  function f4() public   payable  returns(bool o0,bytes25 o1)  {
    if (false)
    {
      if (true)
      {
      }
      if (((uint40(0) + uint40(297061050152)) != (uint40((uint40(0) / uint40(1099511627775))) - uint40(0))))
      {
        int104 l0 = int104(10141204801825835211973625643007);
      }
      else
      {
        (bool l1, bytes memory l2) = payable(this).call{value: 0}("");
        do
        {
          (o1) = (bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
          assert(o1 == bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
        }
        while (false);
        payable(this).transfer(5691108594036771883);
      }
    }
    else
    {
      (bool l3, bytes memory l4) = payable(this).call{value: 1645639613211926735}("");
    }
  }
  error er0(bool ep0);
  uint128   s1 = uint128(0);
  int48  public s2 = int48(140737488355327);
  int64  public s3 = int64(9223372036854775807);
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSignature("f4()"));
  }
  receive() external   payable
  {
    return;
  }
  type T0 is bytes18;
}
bool constant cons0 = false;
struct St2 {
  uint112 el0;
  bytes15 el1;
  address payable el2;
}
struct St3 {
  address payable el0;
  address payable el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
