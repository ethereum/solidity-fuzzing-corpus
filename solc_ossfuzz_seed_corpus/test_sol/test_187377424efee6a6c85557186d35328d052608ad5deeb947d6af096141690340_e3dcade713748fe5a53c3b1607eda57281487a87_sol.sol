
==== Source: su0.sol ====
function f0(function () external   i0,address payable i1)      returns(bool o0,int200 o1,uint48 o2){
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T0 is address;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }





function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) | bytes20(T0.unwrap(y)))); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) & bytes20(T0.unwrap(y)))); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(address(bytes20(T0.unwrap(x)) ^ bytes20(T0.unwrap(y)))); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(address(~bytes20(T0.unwrap(x)))); }






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C0 {
  int136   s0;
  constructor(int136 i0)   {
    s0 |= (int40(549755813887) - (int136(43556142965880123323311949751266331066367) & (int136(43556142965880123323311949751266331066367) % int136(0))));
    unchecked {
      do
      {
        if (i0 == (int136((int136(((-(int136(-34683810950101819192508577271354221826135))) / int136(43556142965880123323311949751266331066367))) / int136(43556142965880123323311949751266331066367))) + int136(9181269636848721815824321870986203464052)))
        {
          (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
        }
        if (i0 > (i0 % (~(int136(43556142965880123323311949751266331066367)))))
        {
          (bool l2, bytes memory l3) = address(this).call(bytes("0000000000000000000000000000000000000000"));
          (bool l4, bytes memory l5) = address(this).call(bytes("ffffffffffffffffffffffff00000000"));
        }
        else
        {
          break;
        }
        (bool l6, bytes memory l7) = address(this).call(bytes("1b06b500000000000000000000000000000000000000000000000000000000000000"));
      }
      while (false);
    }
  }
  function f1() external virtual  payable  returns(int152 o0,bool o1)  {
    return (int152((int152((int152(2587723496854656576342992983703615209208150429) / int152(74603822257986613062113600802435769141007363))) / int152(2854495385411919762116571938898990272765493247))), false);
  }
  error er0();
  error er1(address payable ep0, function () external   returns (bytes22) ep1);
}
struct St0 {
  bool el0;
  bytes13 el1;
  bytes8 el2;
  int32 el3;
}
// ====
// ----
