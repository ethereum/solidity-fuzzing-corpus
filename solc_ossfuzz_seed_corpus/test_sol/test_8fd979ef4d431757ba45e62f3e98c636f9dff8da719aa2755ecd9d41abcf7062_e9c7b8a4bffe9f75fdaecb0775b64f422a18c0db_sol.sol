
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  mapping(bool => bytes1) el0;
  int80 el1;
  uint72 el2;
}
struct St1 {
  bytes28 el0;
  bytes3 el1;
  string el2;
  address el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    if ((((int112(-1606814389768492475197622380221463) + (int112(2596148429267413814265248164610047) + int112(-2199365516643365098490249915540781))) ^ int112(0)) != int160(730750818665451459101842416358141509827966271487)))
    {
    }
    else
    {
      if (((((true ? (uint88(0) * uint88(0)) : uint88(0)) * uint88(309485009821345068724781055)) >> uint240(uint240(0))) > uint88(309485009821345068724781055)))
      {
        return;
      }
      do
      {
        break;
      }
      while (true);
    }
  }
  int80[]   s0 = [int80(0), int80(0), int80(0), int80(604462909807314587353087), int80(0), int80(320185254399775819518232), int80(0), int80(0), int80(604462909807314587353087), int80(122800954755089536590076)];

	function compareMemoryAndStorage(int80[] memory v1, int80[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  type T0 is uint56;
}
// ====
// ----
