==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(function () internal   returns (bool, uint80, function () internal  )[] memory i0) private    returns(uint40 o0)
  {
  }
  event ev0(address payable[] indexed ep0, function () external   returns (int176, address, bool)  ep1, int32  ep2) anonymous;
  function f1(uint152 i0) private    returns(address o0)
  {
  }
  using L0 for *;
  function f2(function (bool, bool) external   i0) private    returns(function () external   returns (int160, int224, bool) o0,bytes27 o1)
  {
    bool l0 = true;
    if ((false && true))
    {
    }
  }
  error er0();
  function f3() external   
  {
    for(    0;
(bytes1(0xff) < bytes1(0x2b));
int104(-8693811789727798005063697935751))
    {
    }
    (uint40 l0) = f0({i0: new function () internal   returns (bool, uint80, function () internal  )[](2)});
  }
}
int64 constant cons0 = ((((((int64(1489341836334076513) ^ int64(0)) + int64(-4873832526490506798)) - int64(9223372036854775807)) + int64(0)) & int64(3244031686696548899)) ** uint16(uint16(65535)));
using L0 for uint;

==== Source: su1.sol ====
contract C0 {
  bytes  public s0 = bytes("63306bd14cb520d1086d29c14558135b3916694df20ccba1de62e3a6ee2c77f006ee4b");
  mapping(bytes8 => address)  public s1;
  int160   s2;
  constructor(int160 i0) payable  {
    s2 ^= int160((int160((int160(730750818665451459101842416358141509827966271487) / int160(((uint160(1461501637330902918203684832716283019655932542975) * uint160(0)) ^ uint160(0))))) / int160(0)));
    s1[bytes8((bytes11(0x0000000000000000000000) & bytes11(0x0000000000000000000000)))] = address(this);
    unchecked {
    }
  }
  function f4(address i0) internal   
  {
  }
}
pragma solidity >= 0.0.0;
contract C1 {
  fallback() external virtual  payable
  {
    return;
  }
  bool   s3 = true;
  bytes23  public s4;
  bool[]   s5 = [false];
  constructor(bytes23 i0)   {
    s4 ^= bytes23(0x0000000000000000000000000000000000000000000000);
    unchecked {
      (bool l0, bytes memory l1) = payable(this).call{value: 12440578682143272992}("");
      payable(this).transfer(6904365814416902869);
      (bool l2, bytes memory l3) = payable(this).call{value: 17728198960710317841}("");
    }
  }
}
// ----
// Warning 3628: (su1.sol:612-1105): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su0.sol:398-433): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:454-510): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:511-521): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:531-538): Unused local variable.
// Warning 6133: (su0.sol:647-648): Statement has no effect.
// Warning 6133: (su0.sol:681-721): Statement has no effect.
// Warning 2072: (su0.sol:740-749): Unused local variable.
// Warning 5667: (su1.sol:186-195): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:766-776): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:874-881): Unused local variable.
// Warning 2072: (su1.sol:883-898): Unused local variable.
// Warning 2072: (su1.sol:1013-1020): Unused local variable.
// Warning 2072: (su1.sol:1022-1037): Unused local variable.
// Warning 2018: (su0.sol:386-587): Function state mutability can be restricted to pure
