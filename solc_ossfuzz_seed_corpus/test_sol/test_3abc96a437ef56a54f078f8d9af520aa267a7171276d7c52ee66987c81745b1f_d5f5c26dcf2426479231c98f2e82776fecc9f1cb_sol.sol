
==== Source: su0.sol ====
contract C0 {
  int200  public s0 = int200(803469022129495137770981046170581301261101496891396417650687);
  receive() external virtual  payable
  {
    (s0, s0) = (((((~(((int200(803469022129495137770981046170581301261101496891396417650687) ^ int200(803469022129495137770981046170581301261101496891396417650687)) + int200(494381107839975825423906163389741483477195181082594484517481)))) + int200(803469022129495137770981046170581301261101496891396417650687)) % int200(0)) | int200(0)), (((int200(-146936808393218336057030743860609369950871106737886284898696) % ((int200(-436154948141677289259361694809596310235300100085337893774412) * int200(703372304517579889747996795372875782091612337997129165637447)) | int200(803469022129495137770981046170581301261101496891396417650687))) - int200(803469022129495137770981046170581301261101496891396417650687)) + int200(0)));
    assert(s0 == ((((~(((int200(803469022129495137770981046170581301261101496891396417650687) ^ int200(803469022129495137770981046170581301261101496891396417650687)) + int200(494381107839975825423906163389741483477195181082594484517481)))) + int200(803469022129495137770981046170581301261101496891396417650687)) % int200(0)) | int200(0)));
    assert(s0 == (((int200(-146936808393218336057030743860609369950871106737886284898696) % ((int200(-436154948141677289259361694809596310235300100085337893774412) * int200(703372304517579889747996795372875782091612337997129165637447)) | int200(803469022129495137770981046170581301261101496891396417650687))) - int200(803469022129495137770981046170581301261101496891396417650687)) + int200(0)));
  }
  error er0(uint48 ep0, uint144 ep1);
  function f1(int200 i0,int200 i1) public virtual     {
    return;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



error er1(bytes26 ep0, T0 ep1);
contract C1 {
  struct St0 {
    address payable el0;
    int144 el1;
    mapping(bytes12 => bytes5) el2;
    string el3;
  }
  struct St1 {
    uint56 el0;
    bool el1;
  }
  bool  public s1;
  bool   s2 = true;
  address   s3 = address(this);
  constructor(bool i0) payable  {
    s1 = (uint208(0) > uint208(0));
    {
    }
  }
  receive() external   payable
  {
    return;
  }
}
// ====
// ----
