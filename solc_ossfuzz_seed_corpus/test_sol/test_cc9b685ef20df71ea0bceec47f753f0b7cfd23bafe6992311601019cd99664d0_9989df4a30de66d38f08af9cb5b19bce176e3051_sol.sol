
==== Source: su0.sol ====
library L0 {
  function f0(int80[][1][][9] memory i0,int240 i1) external   
  {
    int256 l0 = ((int256(int48(-20802976043182)) & ((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) % int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) % int256(-26544147607061758626601398534394946369262568379646733568164560084206926581462))) % int256(0));
    bool[] memory l1 = new bool[](3);
    function (string memory, bytes memory) external   l2;
    int232 l3 = (int232(1497019542481661277652338767942788053460165807110003602126532759069616) + int232(3450873173395281893717377931138512726225554486085193277581262111899647));
    (i0[((((((~(uint256(0))) | uint256(48499359259883257945529298625278739354675637584511340388720216161902994785494)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(66099892208894777115883211247912350204732662928161164383677040114403845574327)) | uint256(0)) + uint256(0))], l1[uint256(0)], l1[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]) = (new int80[][1][](9), ((int120(0) == (~(int120(664613997892457936451903530140172287)))) ? (l1[uint256(0)] = (true ? (l1[uint256(48526138963482663535673258331250109363541440752725572319499091422913832953588)] = false) : (false ? (false ? false : false) : true))) : false), false);
    assert(l1[uint256(0)] == ((int120(0) == (~(int120(664613997892457936451903530140172287)))) ? (l1[uint256(0)] = (true ? (l1[uint256(48526138963482663535673258331250109363541440752725572319499091422913832953588)] = false) : (false ? (false ? false : false) : true))) : false));
    assert(l1[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] == false);
  }
}
pragma solidity >= 0.0.0;
using L0 for int80[][1][][9];
type T0 is address payable;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }





function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) | bytes20(address(T0.unwrap(y)))))); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) & bytes20(address(T0.unwrap(y)))))); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(payable(address(bytes20(address(T0.unwrap(x))) ^ bytes20(address(T0.unwrap(y)))))); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(payable(address(~bytes20(address(T0.unwrap(x)))))); }






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }




==== Source: su1.sol ====
struct St0 {
  uint24 el0;
  int8[][5][][8][][7] el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
