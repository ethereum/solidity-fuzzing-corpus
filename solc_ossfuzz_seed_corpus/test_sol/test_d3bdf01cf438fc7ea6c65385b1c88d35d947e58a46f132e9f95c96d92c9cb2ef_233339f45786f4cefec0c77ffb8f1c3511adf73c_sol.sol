
==== Source: su0.sol ====
library L0 {
  bytes19 public constant cons0 = bytes19(0xdf6e02d321bdb8a4dfba890c4eac086fb58646);
  address public constant cons1 = 0xfCA88de82F337Da846Ac9002262437BF3C3D3Cc1;
}
contract C0 {
  bool   s0;
  bytes30   s1 = bytes30(0x000000000000000000000000000000000000000000000000000000000000);
  constructor(bool i0) payable  {
    s0 = (bytes16(0x00000000000000000000000000000000) < bytes16(0x00000000000000000000000000000000));
    {
      bytes30  l0 = s1;
      bytes30  l1 = l0;
      assert(l1 == s1);
      (s0) = (false);
      assert(s0 == false);
    }
  }
  using L0 for *;
  receive() external virtual  payable
  {
    bytes30  l0 = s1;
    bytes30  l1 = l0;
    assert(l1 == s1);
    for(uint solinit0 = 0; solinit0 < (((uint256(0) * uint256(67331655438257091897313181431208990315710061908270456512507258093483417762803)) & address(bytes20(address(0x0000000000000000000000000000000000000000))).balance) % 11); solinit0++)
    {
      bytes3 l2 = (bytes3(0xffffff) & bytes3(0x000000));
      address payable l3 = payable(address(this));
    }
    bytes30  l4 = s1;
    bytes30  l5 = l4;
    assert(l5 == s1);
  }
}
pragma solidity >= 0.0.0;
library L1 {
  function f1() private    returns(address o0)
  {
    for(    bool l0 = (((~((((uint192(6277101735386680763835789423207666416102355444464034512895) & uint192(6277101735386680763835789423207666416102355444464034512895)) - uint192(6277101735386680763835789423207666416102355444464034512895)) & uint192(6277101735386680763835789423207666416102355444464034512895)))) ** uint176(uint176(0))) <= uint192(1499929681407190768635101854617516150663582935368137609926));
false;
)
    {
      bytes2 l1 = bytes2(0x0000);
    }
    bytes memory l2 = bytes("a4e44300000000000000000000000000000000");
  }
  type T0 is address payable;
  function f2(bytes26 i0) external   
  {
    i0 &= bytes26(0xf83c9478d4281158e80f5e563c67b02b7f2f0a7c8e65ac1e2f9e);
  }
}
// ====
// ----
