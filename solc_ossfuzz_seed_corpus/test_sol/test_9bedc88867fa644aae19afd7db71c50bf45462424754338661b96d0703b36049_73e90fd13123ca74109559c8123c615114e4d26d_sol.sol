
==== Source: su0.sol ====
contract C0 {
  function f0() external virtual   returns(uint176 o0)
  {
    bool l0 = true;
    function (address payable) internal   returns (bool, bytes2) l1;
    unchecked {
      address payable l2 = payable(address(this));
      [[new int128[2][1][](8)]];
    }
  }
  fallback() external virtual  
  {
    int112 l0 = int112(0);
    assembly
    {
      returndatacopy(add(0x80, mod(l0, 1024)), mul(l0, 75144385554763831358447249021168713859799940699266455999868827488966281795306), mod(101961302332795233655250985426575353059307740769204081313944794105706684593508, 1024))
      l0 := l0
      pop(l0)
      for 
      { let yulinit0 := 0 } lt(yulinit0, mod(l0, 11)) { yulinit0 := add(yulinit0, 1) }
      {
        switch l0
        case 38127303075498202914972565359963431375323616863119426991396715200690414578981
        {
          switch 0
          case 115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
          }
          case 13174817220635156434232315817496867396345528521444263152063291356180924693481
          {
          }
          {
            {
              switch l0
              case 108137080587560191515134798922716376305672842764190759728942820710998203665428
              {
                returndatacopy(add(0x80, mod(l0, 1024)), sload(l0), mod(0, 1024))
              }
              default
              {
              }
            }
          }
          switch 0
          case 0
          {
            return(add(0x80, mod(l0, 1024)), l0)
          }
          case 112038496120743847387197188415088977438409025026222484494225083774754607829293
          {
            continue
          }
        }
        case 37277609625562825605633492994536304214668225620857953162966628299928933807283
        {
          for 
          {
            l0 := l0
          }
          l0
          {
            switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
            case 0
            {
              extcodecopy(0, add(0x80, mod(l0, 1024)), l0, mod(0, 1024))
            }
            for 
            { let yulinit1 := 0 } lt(yulinit1, mod(l0, 11)) { yulinit1 := add(yulinit1, 1) }
            {
              l0 := l0
            }
          }
          {
            l0 := l0
            continue
          }
          pop(l0)
        }
        case 21061125841374104577494964402483853939959543940746658605485146828965823419164
        {
          break
        }
      }
    }
    (l0) = ((~((((((int112(0) ^ int112(2596148429267413814265248164610047)) % int112(0)) | int112(1866146609950095771208330321839470)) - int112(2319826846071149335098875050348172)) % int112(2383881158396343166061094245037655)))));
    assert(l0 == (~((((((int112(0) ^ int112(2596148429267413814265248164610047)) % int112(0)) | int112(1866146609950095771208330321839470)) - int112(2319826846071149335098875050348172)) % int112(2383881158396343166061094245037655)))));
  }
  int232   s0 = int232(0);
  function f2() private   
  {
    (bool l0, bytes memory l1) = address(this).call(msg.data);
    int232  l2 = s0;
    int232  l3 = l2;
    assert(l3 == s0);
    (s0) = (((((~(((int232(0) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)) ^ int232(3450873173395281893717377931138512726225554486085193277581262111899647)))) ^ int232(0)) * int232(3450873173395281893717377931138512726225554486085193277581262111899647)) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)));
    assert(s0 == ((((~(((int232(0) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)) ^ int232(3450873173395281893717377931138512726225554486085193277581262111899647)))) ^ int232(0)) * int232(3450873173395281893717377931138512726225554486085193277581262111899647)) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)));
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
