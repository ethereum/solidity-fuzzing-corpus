==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()     returns(int120 o0)
{
}

==== Source: su1.sol ====
library L0 {
  function f1() private   
  {
    address payable l0 = payable(address(bytes20(address(0x0000000000000000000000000000000000000000))));
    string memory l1 = string.concat(string("000000000000000000000000000000ffffffffffffffffffffffffffffffff"), ((true ? false : false) ? string("000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") : string("00000000000000000000614e7a3d3ce884946bb19eaf8c6d177966a8446f5c")), string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), string("ffff000000000000000000000000000000000000000000000000000000000000"));
  }
  bytes31 public constant cons0 = bytes31(0x18e43396166453328f24d0f4b69641ab22cf713f17409a8509670e74e34aa1);
}
library L1 {
  event ev0(int64  ep0);
  function f2(uint56 i0,address payable i1,address i2) public    returns(address payable o0,address o1,string memory o2)
  {
    (o2) = (string("ffff000000000000"));
    assert(keccak256(bytes(o2)) == keccak256(bytes(string("ffff000000000000"))));
    int40 l0 = (int40(0) - int40(int152(2854495385411919762116571938898990272765493247)));
    bytes memory l1 = (true ? (((int24(-5140652) ^ int24(5299455)) == int24(8388607)) ? bytes("ffffff00000000000000000000000000000000000000000000") : bytes("d7f853f7886964a5e56c8a5e400f3132fffb2a2e6ae252ef9767d57c861250079e5045e4d82cafeda18e370d93")) : bytes("000000000000000000000000"));
  }
  modifier m0() 
  {
    _;
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  using L0 for *;
  bytes16   s0;
  uint40 immutable  s1 = uint40(152461819166);
  constructor(bytes16 i0)   {
    s0 ^= bytes16(0x00000000000000000000000000000000);
    unchecked {
      bytes16  l0 = s0;
      bytes16  l1 = l0;
      assert(l1 == s0);
      uint40  l2 = s1;
      uint40  l3 = l2;
      assert(l3 == s1);
      bytes16  l4 = s0;
      bytes16  l5 = l4;
      assert(l5 == s0);
      uint40  l6 = s1;
      uint40  l7 = l6;
      assert(l7 == s1);
      bytes16  l8 = s0;
      bytes16  l9 = l8;
      assert(l9 == s0);
      uint40  l10 = s1;
      uint40  l11 = l10;
      assert(l11 == s1);
    }
  }
  using L0 for *;
  receive() external   payable
  {
    uint40  l0 = s1;
    uint40  l1 = l0;
    assert(l1 == s1);
    bytes16  l2 = s0;
    bytes16  l3 = l2;
    assert(l3 == s0);
  }
}
// ----
// Warning 2072: (su1.sol:48-66): Unused local variable.
// Warning 2072: (su1.sol:153-169): Unused local variable.
// Warning 5667: (su1.sol:776-785): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:786-804): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:805-815): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:835-853): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:854-864): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1014-1022): Unused local variable.
// Warning 2072: (su1.sol:1105-1120): Unused local variable.
// Warning 5667: (su1.sol:1563-1573): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:15-612): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:764-1393): Function state mutability can be restricted to pure
