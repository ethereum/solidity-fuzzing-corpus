
==== Source: su0.sol ====
contract C0 {
  fallback() external   
  {
    int56 l0 = int56((((((int56((int56(36028797018963967) / int56(36028797018963967))) % int56(36028797018963967)) + int56(0)) ** uint80(uint80(0))) * int56(36028797018963967)) / int56(36028797018963967)));
    int232 l1 = (((int232((((int232(3450873173395281893717377931138512726225554486085193277581262111899647) & int232(3450873173395281893717377931138512726225554486085193277581262111899647)) * int232(3450873173395281893717377931138512726225554486085193277581262111899647)) / int232(-1644821706277696351637209200604885861570361503877475407341736055046175))) - int232(812483179896361163843013244801867326116620872085072744537700978147318)) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)) & int232(-1719114209224918855257486417335689548775363233563513732432512806606858));
    for(    function () external   returns (bytes28, function (bool) external  , string memory) l2;
(bytes19(0xffffffffffffffffffffffffffffffffffffff) != bytes19(0xffffffffffffffffffffffffffffffffffffff));
)
    {
      continue;
    }
  }
  address payable   s0;
  mapping(int104 => bool)   s1;
  constructor(address payable i0)   {
    s0 = (false ? payable(address(this)) : payable(address(this)));
    s1[int104(0)] = false;
    unchecked {
      address payable  l0 = s0;
      address payable  l1 = l0;
      assert(l1 == s0);
      (bool l2, bytes memory l3) = payable(this).call{value: 8996774196092463012}("");
      address payable  l4 = s0;
      address payable  l5 = l4;
      assert(l5 == s0);
    }
  }
  struct St0 {
    uint64 el0;
  }
  error er0(bytes20 ep0);
  receive() external virtual  payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
