
==== Source: su0.sol ====
contract C0 {
  address payable   s0;
  uint224  public s1;
  uint240   s2;
  mapping(uint8 => bool[2])   s3;
  constructor(address payable i0,uint224 i1,uint240 i2) payable  {
    s0 = (((address(this) <= address(this)) ? false : true) ? payable(address(this)) : payable(address(this)));
    s1 += (uint224(14051061425324779000810280543810248223183830546940971131182998484258) * ((uint224(26959946667150639794667015087019630673637144422540572481103610249215) | uint224(0)) | uint224(0)));
    s2 *= uint240(0);
    {
      address payable  l0 = s0;
      address payable  l1 = l0;
      assert(l1 == s0);
      unchecked {
        address payable  l2 = s0;
        address payable  l3 = l2;
        assert(l3 == s0);
        (bool l4, bytes memory l5) = address(this).call(bytes("7185f32e0c45eaae7a97ae91f2c1da808b6a6b402000aadf8d2697"));
      }
      {
        assert(false);
        uint240  l6 = s2;
        uint240  l7 = l6;
        assert(l7 == s2);
        address payable  l8 = s0;
        address payable  l9 = l8;
        assert(l9 == s0);
      }
      address payable  l10 = s0;
      address payable  l11 = l10;
      assert(l11 == s0);
    }
  }
  fallback() external virtual  
  {
    uint224  l0 = s1;
    uint224  l1 = l0;
    assert(l1 == s1);
    uint224  l2 = s1;
    uint224  l3 = l2;
    assert(l3 == s1);
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  bytes el0;
  address el1;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
