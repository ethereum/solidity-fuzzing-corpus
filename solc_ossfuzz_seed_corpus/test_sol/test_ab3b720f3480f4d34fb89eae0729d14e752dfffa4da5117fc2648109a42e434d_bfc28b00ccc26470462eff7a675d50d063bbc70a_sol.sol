
==== Source: su0.sol ====
struct St0 {
  int104 el0;
  bytes21 el1;
  address payable el2;
  int256 el3;
}
bool constant cons0 = false;
pragma solidity >= 0.0.0;
error er0();

==== Source: su1.sol ====
contract C0 {
  bool  public s0 = false;
  mapping(bool => int160)[][]   s1;
  uint72   s2 = uint72(4722366482869645213695);
  receive() external virtual  payable
  {
  }
  error er1(uint168 ep0);
  function f1() external      {
    payable(this).transfer(0);
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    try this.f1()
    {
      revert er1(((((uint168(39779308712152169450088501160900452481521964679702) % uint168(284211632155807448942466071823625803090174562356888)) - uint168(137674295032930804795386919288907776218762260646466)) - uint168(0)) << uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))));
    }
    catch
    {
      revert er1((uint168(0) + ((uint168(374144419156711147060143317175368453031918731001855) % uint8(221)) * uint168(0))));
    }
  }
}
struct St1 {
  mapping(bytes10 => uint112)[] el0;
}
pragma solidity >= 0.0.0;
bool constant cons1 = false;
// ====
// ----
