==== Source:  ====

==== Source: su0.sol ====
function f0()      returns(bytes8 o0,function (int168, string memory, uint184) external   returns (bytes15, bytes26) o1,bytes16[5] memory o2){
  return (hex"04ef34b345" f1 /*suffix expr*/, o1, [bytes16(0x00000000000000000000000000000000), bytes16(0x00000000000000000000000000000000), bytes16(0xffffffffffffffffffffffffffffffff), bytes16(0x00000000000000000000000000000000), bytes16(0xffffffffffffffffffffffffffffffff)]);
}
struct St0 {
  uint224 el0;
  string el1;
  function (function (address payable[3] memory, address, uint168[] memory) external   returns (bool, int216, uint80), bool, bytes1) external  [] el2;
}
pragma solidity >= 0.0.0;
function f1(bytes5 i0) pure suffix  returns(bytes8 o0)
{
  (o0) = (bytes3(0x000000));
  assert(o0 == bytes3(0x000000));
  if (i0 <= 105312291668557186697918027683670432318895095400549111254310977535 f2 /*suffix expr*/)
  {
    o0 ^= bytes8(0x2bd4b1090672ca17);
    if (i0 <= (bytes5(0x1c1fa6a2e4) ^ (bytes5(0xffffffffff) | bytes5(0x0e6f06ef0c))))
    {
      if (i0 > bytes5(0x1afe1222a0))
      {
      }
    }
    else if (i0 <= (~(bytes5(0xffffffffff))))
    {
      if (i0 > bytes5(0x0000000000))
      {
        (o0) = (bytes8(0xffffffffffffffff));
        assert(o0 == bytes8(0xffffffffffffffff));
      }
      do
      {
        continue;
      }
      while (true);
    }
    function (int24) internal   l0;
    (o0) = ((bytes8(0xffffffffffffffff) | bytes8(0xffffffffffffffff)));
    assert(o0 == (bytes8(0xffffffffffffffff) | bytes8(0xffffffffffffffff)));
  }
  else if (i0 <= bytes5(0xffffffffff))
  {
  }
}
function f2(uint216 i0) pure suffix  returns(bytes5 o0)
{
}

==== Source: su1.sol ====
type T0 is int256;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=,
unsub0 as -
} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function unsub0(T0 x) pure returns (T0) { return T0.wrap(-T0.unwrap(x)); }


address constant cons0 = 0x0000000000000000000000000000000000000000;
T0 constant cons1 = T0.wrap(57896044618658097711785492504343953926634992332820282019728792003956564819967);
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:1329-1359): Unused local variable.
// Warning 2018: (su0.sol:0-422): Function state mutability can be restricted to pure
