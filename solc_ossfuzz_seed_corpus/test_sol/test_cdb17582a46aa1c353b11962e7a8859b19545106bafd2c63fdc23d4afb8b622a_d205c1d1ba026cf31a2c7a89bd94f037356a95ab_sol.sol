
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(bytes17 i0,uint216 i1) external    returns(bool o0)
  {
    assert(false);
  }
  event ev0();
}
struct St0 {
  address payable el0;
  int128 el1;
  function (bytes26, address) external   returns (uint128[9] memory) el2;
  string el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  address payable   s0 = payable(address(this));
  uint16   s1;
  uint216 immutable public s2 = uint216(0);
  bool   s3 = false;
  constructor(uint16 i0)   {
    s1 >>= uint16(31377);
    unchecked {
      {
        if (false)
        {
          assert(false);
        }
        else if ((ecrecover(((keccak256(bytes("6e1af4420000000000000000000000000000000000000000000000000000000000")) != bytes32(0x37ba841746a281df688059907b9f30259e32755ea500b250de59ca73784d7a16)) ? bytes32(0x0000000000000000000000000000000000000000000000000000000000000000) : bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)), uint8(122), bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)) > address(this)))
        {
          (bool l0) = payable(this).send(10269441125948719467);
        }
        uint16  l1 = s1;
        uint16  l2 = l1;
        assert(l2 == s1);
        {
          (bool l3, bytes memory l4) = payable(this).call{value: 0}("");
          for(;
false;
bytes22(0xf1fa96d21f000a085e0a10edd52121393267f8d82521))
          {
            bool l5 = false;
          }
          uint216  l6 = s2;
          uint216  l7 = l6;
          assert(l7 == s2);
        }
        for(        bool l8 = false;
;
bytes19(0x52781da5ba81f8450bc355ec6aa3b58e11baf4))
        {
          int232 l9 = ((int232(-287952352101083834531555394807375606114772482022498965046299858767184) ^ (-(int232(3450873173395281893717377931138512726225554486085193277581262111899647)))) + int232(993926089890420631029114271097971719911031576043649897749489139439871));
        }
      }
      address payable  l10 = s0;
      address payable  l11 = l10;
      assert(l11 == s0);
    }
  }
  receive() external   payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    bool  l2 = s3;
    bool  l3 = l2;
    assert(l3 == s3);
  }
}
struct St1 {
  bytes16 el0;
}
// ====
// ----
