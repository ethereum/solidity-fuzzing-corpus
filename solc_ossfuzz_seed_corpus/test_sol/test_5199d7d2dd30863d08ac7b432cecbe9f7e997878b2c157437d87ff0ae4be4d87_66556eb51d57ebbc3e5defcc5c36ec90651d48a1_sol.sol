
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(address payable i0) external virtual   returns(function (uint56, string memory, function (uint232, int24) external  ) external   returns (int112[][2][7][][9] memory, uint248) o0)
  {
    for(    bytes16(0xaa6830d88e873d05be6b11112ec7ae36);
;
(((address(this).balance ^ uint256(0)) * uint256(0)) - uint256(37301218435162896781420479854122126324567815844882401102789071260213249195116)))
    {
    }
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  uint200   s0;
  string  public s1;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bytes4 immutable  s2;
  bytes27   s3 = bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  constructor(uint200 i0,string memory i1,bytes4 i2)   {
    s0 &= uint200(0);
    s1 = string("cf6c824208c40bd1798d0f44da5a2e4eb0023cab12");
    s2 = bytes4(0xffffffff);
    {
      uint200  l0 = s0;
      uint200  l1 = l0;
      assert(l1 == s0);
      string memory l2 = s1;
      string memory l3 = l2;
      assert(compareMemoryAndStorage(l3, s1));
      bytes27  l4 = s3;
      bytes27  l5 = l4;
      assert(l5 == s3);
      uint200  l6 = s0;
      uint200  l7 = l6;
      assert(l7 == s0);
      uint200  l8 = s0;
      uint200  l9 = l8;
      assert(l9 == s0);
    }
  }
}
struct St0 {
  function (address, bool, function (int224) external   returns (uint224, uint256)) external   returns (address, bool, uint40) el0;
  address[][][] el1;
  uint64 el2;
  uint144 el3;
}
// ====
// ----
