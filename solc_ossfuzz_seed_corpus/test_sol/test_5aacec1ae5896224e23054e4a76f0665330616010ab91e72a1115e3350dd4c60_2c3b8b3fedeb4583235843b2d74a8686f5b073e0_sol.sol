
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    unchecked {
    }
    address l0 = (false ? (false ? address(this) : address(this)) : address(this));
    bool l1 = true;
    address l2 = (l0 = address(this));
    delete l1;
  }
  receive() external   payable
  {
    for(    uint96 l0 = (~(uint96(0)));
;
)
    {
      function (int80, bytes memory) external   returns (function () external   returns (int200, address payable), uint24) l1;
      l0 <<= uint96(79228162514264337593543950335);
    assert(l0 == address(this));
    }
    uint32 l2 = (((uint32(0) | (true ? uint32(4294967295) : uint32(4294967295))) % uint32(0)) + uint32(3010074190));
  }
  int176  public s0;
  address payable  public s1 = payable(address(this));
  constructor(int176 i0)   {
    s0 |= int176(47890485652059026823698344598447161988085597568237567);
    { }
  }
  struct St0 {
    int160 el0;
  }
}

==== Source: su1.sol ====
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
// ====
// ----
