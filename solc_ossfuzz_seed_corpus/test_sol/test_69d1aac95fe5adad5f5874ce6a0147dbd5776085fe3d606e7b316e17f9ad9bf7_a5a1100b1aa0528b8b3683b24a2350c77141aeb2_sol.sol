
==== Source: su0.sol ====
contract C0 {
  type T0 is address;
  function f0() external virtual   returns(bytes16 o0)
  {
    try this.f0() returns (bytes16 l0)
    {
    }
    catch
    {
      if ((false ? ((!(false)) && true) : true))
      {
      }
    }
    catch Panic(uint256 l1)
    {
      if (((!(true)) ? (true || (int120(336090626374548426323866044845025903) < int120(-587088289882211559772221626529839725))) : false))
      {
        return (bytes16(0x8cca12247b0745c37e9db7ba9f40e042));
      }
      else if ((!(((true || false) ? false : false))))
      {
        return (bytes16(0xffffffffffffffffffffffffffffffff));
      }
      else if (false)
      {
        (bool l2, bytes memory l3) = address(this).call("0000000000000000000000000000000000000000ffff");
      }
    }
  }
  error er0(string ep0, address payable ep1);
  event ev0(int224 indexed ep0);
  bool   s0 = true;
  mapping(C0.T0 => int176)   s1;
  bytes16   s2;
  bytes   s3 = "0f6355c34b20304a840b9cffffffffffffffffffffffffffff";
  constructor(bytes16 i0) payable  {
    s2 ^= bytes16(0x00000000000000000000000000000000);
    s1[C0.T0.wrap(address(0x0000000000000000000000000000000000000004))] -= (s1[C0.T0.wrap(address(0x0000000000000000000000000000000000000008))] % int176(-3981116096434177236274084710152336907522335384774221));
    unchecked {
    }
  }
  struct St0 {
    mapping(int56 => bool) el0;
    int72[2] el1;
    address el2;
  }
}
error er1(int56 ep0);
struct St1 {
  uint144 el0;
  address payable el1;
  bytes el2;
  C0.T0 el3;
}
address constant cons0 = 0x0000000000000000000000000000000000000000;
pragma solidity >= 0.0.0;
library L0 {
  modifier m0(C0.T0 i0) 
  {
    _;
    (i0) = (C0.T0.wrap(address(0x0000000000000000000000000000000000000007)));
    bytes22 l0 = bytes22(0xb63371ca4a13e13a6e0766122661b4a9332c69498743);
  }
  error er2();
  bytes23 public constant cons1 = (((true ? (bytes23(0x035d1f772680207136654c66b642065f404dd96d267b1e) & bytes23(0x0000000000000000000000000000000000000000000000)) : bytes23(0x0000000000000000000000000000000000000000000000)) & bytes23(0x0000000000000000000000000000000000000000000000)) ^ bytes23(0xb6331aee080c41cf1504ee76bfcfb233d2a0bfbe943241));
  modifier m1(bool i0,bytes24 i1) 
  {
    _;
  }
  function f1(function (bool, bool) external   returns (bool, bool, bool) i0,bool[2] memory i1,bytes7 i2) internal    returns(int56 o0,bool o1,bytes6 o2)
  {
  }
  function f2() external  m0(C0.T0.wrap(address(0x0000000000000000000000000000000000000005))) m1((uint176(5400223750644645050944693813593566567838930752454350) == (uint176(0) << uint152((uint152(458397415207704017774007419336180507725012178) & uint152(5708990770823839524233143877797980545530986495))))),bytes24(0x33b39edc6db2b9fbf78179b92a64d754e72a0bb40ffb6009))  returns(C0.T0 o0)
  {
    revert("000000000000000000000000000000000000000000000000000000007927f1910d2a5eff1d394980cccf47169ae1");
  }
  error er3();
}
// ====
// ----
