
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  uint144  public s0 = uint144(0);
  receive() external virtual  payable
  {
  }
}
error er0(bytes5 ep0);

==== Source: su1.sol ====
struct St0 {
  bytes10 el0;
  mapping(bool => uint248) el1;
  address el2;
  bytes28 el3;
}
library L0 {
  modifier m0(bytes memory i0,function (bool) external   returns (uint184, bool, address payable) i1) 
  {
    int112 l0 = (int112(0) % int112((int112(0) / (int112(2596148429267413814265248164610047) - int112(2596148429267413814265248164610047)))));
    assembly
    {
      calldatacopy(add(0x80, mod(sgt(65933197464889180037684585025588093766988595854879983012388893082328838320404, 81746170276237807276282392388511847651796601032877730659389797695648854264457), 1024)), 0, mod(sgt(i0, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 1024))
      for 
      {
      }
      eq(i0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      {
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(i0, 11)) { yulinit0 := add(yulinit0, 1) }
        {
          l0 := mload(add(0x80, mod(i0, 2048)))
        }
        for 
        { let yulinit1 := 0 } lt(yulinit1, mod(address(), 11)) { yulinit1 := add(yulinit1, 1) }
        {
          l0 := i0
        }
      }
      {
      }
      let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
    }
    (l0) = ((int104(0) % int104(-2986253684593570854967782625875)));
    assert(l0 == (int104(0) % int104(-2986253684593570854967782625875)));
    _;
  }
  function f1(bool i0,bool i1) private   
  {
    address l0 = address(0x0000000000000000000000000000000000000002);
    int184 l1 = ((true ? (int96(-15402856834658914281446206758) ^ int96(39614081257132168796771975167)) : int96(11879240091207320972544801189)) * int184(0));
    (l1) = (int184((int104(0) / ((false ? int184(12259964326927110866866776217202473468949912977468817407) : int184(-6577172076319491366814865346202809548745417889561402132)) + int184(-2634704740358061487204919012726755426969875387278166651)))));
    assert(l1 == int184((int104(0) / ((false ? int184(12259964326927110866866776217202473468949912977468817407) : int184(-6577172076319491366814865346202809548745417889561402132)) + int184(-2634704740358061487204919012726755426969875387278166651)))));
  }
  function f2() internal    returns(bool o0,address payable o1)
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000004));
    int168 l1 = int168(0);
    unchecked {
      address payable l2 = payable(address(0x0000000000000000000000000000000000000005));
      (o1) = (payable(address(0x0000000000000000000000000000000000000001)));
      assert(o1 == payable(address(0x0000000000000000000000000000000000000001)));
    }
  }
}
using L0 for bool;
pragma solidity >= 0.0.0;
// ====
// ----
