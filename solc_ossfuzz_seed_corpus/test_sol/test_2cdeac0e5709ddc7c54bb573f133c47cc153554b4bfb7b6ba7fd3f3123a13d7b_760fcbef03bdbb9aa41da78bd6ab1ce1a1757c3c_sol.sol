
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  string el0;
  bytes el1;
  bytes26 el2;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  
  {
  }
  function f1(bytes32 i0,function () external   returns (bool, bytes3) i1,int168 i2) external    returns(uint216 o0,bytes16 o1)
  {
    unchecked {
      (o1) = (bytes16(0x2290f5e38d13bfe2241ba76614ef3b99));
      assert(o1 == bytes16(0x2290f5e38d13bfe2241ba76614ef3b99));
      function () external   returns (bool, string memory) l0;
      bytes21 l1 = (bytes21(bytes16(0xffffffffffffffffffffffffffffffff)) | bytes21(0xedfe6fd5e68b320f793ff67160b76b6e463cc0dde1));
      address l2 = ((false ? true : (false ? true : true)) ? address(this) : address(this));
      bytes storage l3;
      (bool l4, bytes memory l5) = address(this).call(bytes("000000000000000000000000000000000000000000fb9ef4f8855a2feb33d314c31838167eee03abee06b88047db846780fe7537"));
    }
  }
  int128 immutable  s0 = int128(-6319811740539627500448333587193221490);
  int96   s1 = int96(39614081257132168796771975167);
  int120[5][4][][10][][]   s2;

	function compareMemoryAndStorage(int120[5][4][][10][][] memory v1, int120[5][4][][10][][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int120[5][4][][10][] memory v1, int120[5][4][][10][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int120[5][4][][10] memory v1, int120[5][4][][10] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int120[5][4][] memory v1, int120[5][4][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int120[5][4] memory v1, int120[5][4] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int120[5] memory v1, int120[5] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(int120[5][4][][10][][] memory i0) payable  {
    s2 = i0;
    unchecked {
      s2.push();
      s2.push();
      int128  l0 = s0;
      int128  l1 = l0;
      assert(l1 == s0);
      int128  l2 = s0;
      int128  l3 = l2;
      assert(l3 == s0);
      revert(string.concat(string("000000000000000000ffffffffffffffffffffffff"), string.concat((true ? string("ffffffffffffffffffffffffffffffff") : string("3df5b0007cc47e12a5363de65303277a3dab1d250dc8ffffffffffffffffffffffffffff")), string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffb97693c445dec17b919434228f4eda66177b")), string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), string("00000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffff")));
    }
  }
}
// ====
// ----
