
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    function () external   returns (bytes memory, uint208) el0;
    string el1;
  }
  error er0();
  modifier m0(int72 i0,function (bool, bytes memory) internal   returns (address payable, bytes2, int168) i1) virtual
  {
    _;
  }
  bool   s0;
  mapping(int104 => int112)  public s1;
  constructor(bool i0)   {
    s0 = false;
    s1[int104(-574328069522856483948128749684)] ^= int112(1765994119865853571862379831295191);
    unchecked {
      if (false)
      {
        {
        }
      }
      else if (i0)
      {
        bytes8 l0 = bytes8(0x19080608f6340326);
      }
      else
      {
      }
      (s0) = (true);
    }
  }
}
function f0()     returns(bytes2 o0,bool o1)
{
  address l0 = address(0x0000000000000000000000000000000000000005);
}
address constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
pragma solidity >= 0.0.0;
type T0 is bool;
contract C1 {
  modifier m1() virtual
  {
    _;
    T0 l0 = T0.wrap(false);
  }
  struct St1 {
    C0.St0 el0;
    T0 el1;
  }
  bytes8[]   s2;
  string   s3 = "00000000000000000000000000000000000000000000000000000000000000000000000000000000";
  C0.St0   s4;
  constructor(bytes8[] memory i0)   {
    s2 = i0;
    unchecked {
      (bytes2 l0, bool l1) = f0();
      if (((!(false)) && false))
      {
        if (false)
        {
        }
        else if ((!(true)))
        {
        }
      }
      (s2[0], s2, s4.el1) = (i0[1], [bytes8(0xffffffffffffffff)], string.concat(s4.el1));
      (bool l2, bytes memory l3) = address(this).call("1741c5188a4bed023dc4fd0a451cfbffb652cd411fc92b49efc08d185367873241e8126d04f84092d84506a2ea");
      {
        s4.el1 = string("ffffffffffffffffffffffffffffffffff33f157bb9015f61b46b797afb3348d");
      }
      for(;
(!(false));
)
      {
      }
    }
  }
  modifier m2() virtual
  {
    revert C0.er0();
    (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000"));
    uint80 l2 = uint80(0);
    _;
    unchecked {
      assembly
      {
      }
      if (true)
      {
        (bytes2 l3, bool l4) = f0();
        if ((!(false)))
        {
          while (false)
          {
            continue;
            while (false)
            {
              break;
              continue;
            }
          }
          if (false)
          {
          }
          else if ((bytes15(0xafc8cff242fc940447f2a4b5a63621) >= bytes15(0x000000000000000000000000000000)))
          {
          }
        }
      }
      else
      {
        do
        {
        }
        while ((false ? true : true));
      }
    }
  }
  event ev0();
  modifier m3(function (function (T0, bool, C1.St1 memory) internal  , address) internal   returns (int240, C0) i0,function (int184, bytes20) internal   returns (function (address, bytes8, bytes8) internal  ) i1) virtual
  {
    _;
  }
  event ev1(bytes  ep0, bool  ep1);
}
error er1(bytes ep0);
// ====
// ----
