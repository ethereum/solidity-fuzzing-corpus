
==== Source: su0.sol ====
contract C0 {
  bool   s0;
  address  public s1 = address(this);
  uint224   s2;
  constructor(bool i0,uint224 i1)   {
    s0 = (payable(address(this)) == payable(address(this)));
    s2 %= uint224(22724969165988167651023985597377531585576699087920414762654877284099);
    unchecked {
    }
  }
  receive() external virtual  payable
  {
    return;
  }
  struct St0 {
    mapping(address => uint144) el0;
  }
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 6832427542465020247}("");
  }
  function f2() external   payable   {
    try this.f2()
    {
      (s0, s0) = (false, false);
      assert(s0 == false);
      assert(s0 == false);
      while (true)
      {
        continue;
      }
      if (true)
      {
        return;
      }
    }
    catch
    {
      if (false)
      {
        payable(this).transfer(9756506193939140801);
      }
      try this.f2()
      {
      }
      catch
      {
        uint224  l0 = s2;
        uint224  l1 = l0;
        assert(l1 == s2);
      }
      if (true)
      {
        if (true)
        {
        }
      }
      else
      {
        s0 = false;
        assert(s0 == false);
      }
      assert(true);
    }
    catch Panic(uint256 l2)
    {
    }
  }
  function f3(uint224 i0) public virtual  payable  returns(bool o0,uint184 o1)  {
    o1 ^= (uint184((uint184(19083147344962335571962989125564079751681197524617776151) / (((uint184(0) - uint184(610857655261987717509101571288226117482570426539452245)) - uint184(16542890764613949118052600254717657430734010567691152029)) ** uint48(uint48(0))))) | uint184(0));
    if (i0 >= uint224(0))
    {
      do
      {
        (s2, o0) = (((((((uint224(0) + uint224(26959946667150639794667015087019630673637144422540572481103610249215)) - uint224(0)) >> uint64(uint64(14946922547050385103))) - uint224(26959946667150639794667015087019630673637144422540572481103610249215)) << uint256(uint256(14250229231614496897636083330629628603034250825648070544603467505459452850997))) << uint40(uint40(45227278199))), true);
        assert(s2 == ((((((uint224(0) + uint224(26959946667150639794667015087019630673637144422540572481103610249215)) - uint224(0)) >> uint64(uint64(14946922547050385103))) - uint224(26959946667150639794667015087019630673637144422540572481103610249215)) << uint256(uint256(14250229231614496897636083330629628603034250825648070544603467505459452850997))) << uint40(uint40(45227278199))));
        assert(o0 == true);
        return ((false ? true : false), ((bytes22(0x4d1ace0a007e254d4ff768451dcdf62e2d0ee870fe24) <= bytes22(0xffffffffffffffffffffffffffffffffffffffffffff)) ? uint184(10918173394210550057209449205395083582925543829833530272) : uint184(0)));
      }
      while (true);
    }
    require(false, string.concat(string("This is a really long string that must ideally be random but is currently hard coded")));
    (bool l0) = payable(this).send(14348408816779364022);
  }
}
error er0(uint200 ep0);
struct St1 {
  address el0;
}
struct St2 {
  bool el0;
  address payable el1;
  St1[3] el2;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
// ====
// ----
