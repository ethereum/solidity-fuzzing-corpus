
==== Source: su0.sol ====
struct St0 {
  bytes5 el0;
  mapping(int256 => int48[7]) el1;
  int16[] el2;
}
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C0 {
  int192   s0;
  mapping(T0 => mapping(bytes7 => bytes23))   s1;
  T0   s2 = T0.wrap(false);
  T0   s3 = T0.wrap(true);
  constructor(int192 i0)   {
    s0 -= int192(((int192((int192(((int48(0) - int48(0)) / int192(0))) / int192(3138550867693340381917894711603833208051177722232017256447))) & int192(-878523335115048798250795084177665381927937693546905513353)) / int192(0)));
    unchecked {
    }
  }
  function f0(int192 i0,T0 i1,address i2) public      {
    if (i0 != int192((((int208(205688069665150755269371147819668813122841983204197482918576127) - int208((int208(205688069665150755269371147819668813122841983204197482918576127) / int208(0)))) & int208(0)) & int208(205688069665150755269371147819668813122841983204197482918576127))))
    {
    }
    else if ((bytes18(0x51f520fe2e1c45d65155043a452ada0bd964) < bytes18(0x000000000000000000000000000000000000)))
    {
      if (i2 == address(this))
      {
        (s2) = (T0.wrap(true));
        assert(s2 == T0.wrap(true));
      }
    }
    (s2) = (T0.wrap(true));
    assert(s2 == T0.wrap(true));
    int192  l0 = s0;
    int192  l1 = l0;
    assert(l1 == s0);
  }
}

==== Source: su1.sol ====
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
function f1(bool i0,bytes12 i1)     {
}
pragma solidity >= 0.0.0;
// ====
// ----
