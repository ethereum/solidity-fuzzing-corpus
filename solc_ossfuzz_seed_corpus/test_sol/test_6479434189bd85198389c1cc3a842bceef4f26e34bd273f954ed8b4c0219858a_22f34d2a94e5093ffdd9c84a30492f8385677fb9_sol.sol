
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
  bool el1;
  bool el2;
}
contract C0 {
  function f0() public      {
    while (true)
    {
      continue;
    }
    uint176 l0 = uint176(0);
  }
  event ev0(bool indexed ep0, function (string memory) external   returns (function (bool, uint8, uint256) external   returns (St0 memory), bool)  ep1);
  bytes11 immutable public s0;
  string  public s1 = string("This is a really long string that must ideally be random but is currently hard coded");

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  mapping(int256 => uint64)   s2;
  int160   s3 = int160(0);
  constructor(bytes11 i0) payable  {
    s0 = ((bytes11(bytes28(0x00000000000000000000000000000000000000000000000000000000)) & (true ? bytes11(0xffffffffffffffffffffff) : bytes11(0x59fd146535dcbc12c24e50))) | bytes11(0x0000000000000000000000));
    s2[(((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) | ((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) & int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) * int256(0))) ** uint120(uint120(104685099022624114734301893302682581))) ^ int256(-49616059823670993079810837296134211717448291331430158951208263977101892226173))] += ((((s2[(int256(0) ** uint40(uint40(0)))] ^ uint64((uint64(0) / uint64(18446744073709551615)))) | uint64(18446744073709551615)) + uint64(18446744073709551615)) | uint64(0));
    unchecked {
    }
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
