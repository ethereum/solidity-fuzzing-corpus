
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
  }
  int232   s0;
  int152   s1;
  mapping(int64 => int160)   s2;
  uint192   s3;
  constructor(int232 i0,int152 i1,uint192 i2)   {
    s0 &= int232(0);
    s1 /= (int8(0) ^ int152((int200((int200(803469022129495137770981046170581301261101496891396417650687) / int200(0))) * int200(0))));
    s3 >>= uint192(0);
    s2[int64(9223372036854775807)] /= ((int160(730750818665451459101842416358141509827966271487) % (((int160(730750818665451459101842416358141509827966271487) ** uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) * int160(682776315291930857598749056020153616509214563756)) % int160(0))) - int160(-166058405250911178832374771808205087037977894642));
    unchecked {
    }
  }
  struct St0 {
    bytes20 el0;
    int136 el1;
    bytes13 el2;
    string el3;
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
library L0 {
  error er0(int176 ep0, bytes16 ep1);
  type T0 is address payable;
  function f1() private   
  {
    C0.St0 memory l0 = C0.St0(bytes20(address(0x0000000000000000000000000000000000000000)), int136(43556142965880123323311949751266331066367), bytes13(0x11ab6e0bc8c4212ee80e71b715), string("ffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000"));
    C0.St0 memory l1 = C0.St0(bytes20(address(0x483f7fbB4B3A7f28EC1673c87616f3732B297fe0)), int136(43556142965880123323311949751266331066367), bytes13(0xffffffffffffffffffffffffff), string("ce9c1793d2516aa8fa9f4381a4b93c4e1dbc0000000000000000000000000000000000"));
  }
}
// ====
// ----
