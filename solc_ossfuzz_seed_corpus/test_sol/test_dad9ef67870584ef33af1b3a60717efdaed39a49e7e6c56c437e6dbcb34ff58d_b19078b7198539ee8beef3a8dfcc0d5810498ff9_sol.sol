
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(address payable i0,string memory i1,bytes25 i2)    
{
  unchecked {
    uint168 l0 = (((((uint168(339535498812027964416311279948925042115443139766243) % uint168(0)) & uint168(0)) | uint168(219634043319809649118067671003549624357931210614744)) & uint168(44566354873251553681711355573650914465737214567200)) >> uint48(uint48(281474976710655)));
    {
    }
    {
      int112 l1 = ((((((int112(2596148429267413814265248164610047) % int112(0)) + int112(2596148429267413814265248164610047)) * int112(2596148429267413814265248164610047)) & int112(0)) ** uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))) % int112(0));
      int48[] memory l2 = new int48[](7);
    }
    (l0, i1, i2) = (uint168(0), (true ? string("0000000000000000000000000000000000000000000000000091359d50e1624f2d6bc402ef") : string("00000000000000000000000000")), bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
    assert(l0 == uint168(0));
    assert(keccak256(bytes(i1)) == keccak256(bytes((true ? string("0000000000000000000000000000000000000000000000000091359d50e1624f2d6bc402ef") : string("00000000000000000000000000")))));
    assert(i2 == bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
    (l0) = (uint168(0));
    assert(l0 == uint168(0));
  }
  address payable l3 = payable(address(0x0000000000000000000000000000000000000005));
  (l3) = (payable(address(0x0000000000000000000000000000000000000006)));
  assert(l3 == payable(address(0x0000000000000000000000000000000000000006)));
}
library L0 {
  function f1(function (int136) external   returns (bool) i0,uint16 i1,function (int224, bool, bytes memory) external   returns (function (bytes31, bool, address payable) external   returns (bytes21, function (uint208, function (function (bytes11, uint232, bytes10) external   returns (uint96, address), address, int168) external   returns (address, address), int216) external   returns (address, string memory)), bool) i2) internal    returns(uint160 o0,address payable o1)
  {
    bool l0 = true;
    function (bytes1, uint176) internal   returns (uint256) l1;
    assembly
    {
      o0 := 0
    }
  }
  function f2() external   
  {
    assembly
    {
      calldatacopy(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), 0, mod(0, 1024))
      switch 91015029270476463926658269593141943814075943496753944803114559714431371735944
      case 0
      {
        switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
        default
        {
          selfdestruct(sload(40939636968694193115687854552811997761496121335804800305999120710721860128536))
        }
        return(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), 21588242242369504460570164019761393858029640288515521887777583245836111630647)
      }
      for 
      { let yulinit0 := 0 } lt(yulinit0, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 11)) { yulinit0 := add(yulinit0, 1) }
      {
      }
    }
    assembly
    {
    }
  }
}
using L0 for function (int136) external   returns (bool);
using L0 for function (int136) external   returns (bool);
// ====
// ----
