
==== Source: su0.sol ====
struct St0 {
  bool el0;
  int40 el1;
  mapping(bytes24 => bool) el2;
}
error er0();
int40 constant cons0 = ((~(((int40(-294579261185) & (int40(0) % int40(549755813887))) * int40(0)))) | int40(0));
contract C0 {
  modifier m0(function (uint112, uint184, bool) internal   returns (int88, address, int256) i0) 
  {
    if (false)
    {
      _;
    }
    do
    {
      break;
      require(false, "0000000000000000000000008b5f659055e4803e");
    }
    while (false);
  }
  function f0(bool i0,bytes17 i1) public    returns(uint184 o0,bool o1)
  {
    new bool[](1);
  }
  bytes18 public constant cons1 = ((bytes9(0xffffffffffffffffff) <= bytes9(0xffffffffffffffffff)) ? (bytes18(0x000000000000000000000000000000000000) | bytes18(0xffffffffffffffffffffffffffffffffffff)) : bytes18(0x9a278f3b4915e9bbded349779fa2380fc391));
  modifier m1() 
  {
    _;
    (bool l0, bytes memory l1) = address(this).call("18ae00dc0000000000000000000000000000000000000000000000000000");
  }
  function f1() external   payable returns(address[] memory o0)
  {
    unchecked {
      return (this.f1());
      (bool l0, bytes memory l1) = address(this).delegatecall(abi.encodeWithSignature("f0(bool,bytes17)", (bytes12(0xffffffffffffffffffffffff) < bytes12(0x000000000000000000000000)),bytes17(0x0000000000000000000000000000000000)));
      uint80 l2 = uint80(((((((uint80(1163465078209234276816937) + uint80(594598523074635892480830)) >> uint168(uint168(374144419156711147060143317175368453031918731001855))) - uint80(765980223632690439175250)) >> uint32(uint32(0))) * uint80(233486672504280361944542)) / uint80(1208925819614629174706175)));
    }
    bool l3 = (!(true));
  }
  error er1();
  type T0 is address payable;
  event ev0();
  bool[1]  public s0;
  uint72   s1 = uint72(0);
  St0   s2;
  constructor(bool[1] memory i0) payable  {
    s0 = i0;
    {
      for(      ((((~(((uint56(16181244426104889) ** uint24(uint24(0))) - uint56(72057594037927935)))) << uint56(uint56(0))) + uint56(72057594037927935)) + uint56(0));
;
)
      {
        break;
        break;
        continue;
      }
      for(      address l0 = address(this);
s0[0];
)
      {
      }
      if (true)
      {
      }
      else if (false)
      {
        string memory l1 = string("ffffffffffffffffffffffc51251d811526049136e382be20e54663ce9ae6ec47c");
      }
      else
      {
        delete s2.el1;
        do
        {
          if ((false || false))
          {
            function (address payable[] memory) internal   returns (uint256, address payable, bool) l2;
            (s0[0], s2.el0, s0[0]) = (s0[0], (s0[0] = s0[0]), (!((false && ((s0[0] || false) && true)))));
          }
          continue;
        }
        while (((uint144(14989414726503277354983441310297289499978377) ** uint224(uint224(0))) == ((uint144(0) ^ uint144(0)) << uint120(uint120(0)))));
        address l3 = address(this);
      }
      while (((((int56(-5838791534750021) & (int56(-7008174637305807) * int56(36028797018963967))) >= int56(-22246630701930321)) || false) || false))
      {
        while (true)
        {
          if ((bytes29(0x0000000000000000000000000000000000000000000000000000000000) >= bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)))
          {
            address payable l4 = payable(address(this));
            (i0[0]) = ((false && false));
          }
          else
          {
          }
        }
      }
      bool l5 = (false ? (s2.el0 && (bytes19(0x00000000000000000000000000000000000000) == bytes19(0xffffffffffffffffffffffffffffffffffffff))) : false);
      (bool l6, bytes memory l7) = address(this).call("04ffffffffffffffffffffffffffffffffffffff");
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
