
==== Source: su0.sol ====
contract C0 {
  bool immutable public s0;
  mapping(int224 => uint240[8][6][6][9][8])   s1;
  int120   s2 = int120(-546262139545982497989505775863976840);
  bytes26  public s3 = bytes26(0xcf54bce130c2515fd5ba61d750879623aa6da8ca8511e33860e8);
  constructor(bool i0)   {
    s0 = false;
    unchecked {
      bytes26  l0 = s3;
      bytes26  l1 = l0;
      assert(l1 == s3);
      bool  l2 = s0;
      bool  l3 = l2;
      assert(l3 == s0);
      (s2, s3) = ((int120(473034601404395636825685577689177778) % (false ? int120(273475600664311320819390789890282996) : (int120(-370056834928786532257903240737966756) % int120(0)))), (~(bytes22(0xffffffffffffffffffffffffffffffffffffffffffff))));
      assert(s2 == (int120(473034601404395636825685577689177778) % (false ? int120(273475600664311320819390789890282996) : (int120(-370056834928786532257903240737966756) % int120(0)))));
      assert(s3 == (~(bytes22(0xffffffffffffffffffffffffffffffffffffffffffff))));
    }
  }
  fallback() external   
  {
    int120  l0 = s2;
    int120  l1 = l0;
    assert(l1 == s2);
    bytes26  l2 = s3;
    bytes26  l3 = l2;
    assert(l3 == s3);
  }
}
function f1(int168 i0)     returns(bool o0)
{
  unchecked {
    string memory l0 = string("ffffffffffffffffffff6c1eecf7219a190a441670dcf35931477fe3a92f1e959babf2");
    revert(string("faeee295024ba2a95a53f5b694dfd24ae5eb2d1453e2f1cefccea40fb33794b84888eaa449ea1fb650919ae060e054196a"));
  }
  o0 = false;
  assert(o0 == false);
}
pragma solidity >= 0.0.0;
library L0 {
  modifier m0() 
  {
    bytes4 l0 = (msg.sig | bytes4(0xffffffff));
    _;
  }
  type T0 is uint48;
}
contract C1 {
  L0.T0   s4 = L0.T0.wrap(uint48(0));
  uint32   s5;
  int120  public s6 = int120(0);
  address  public s7 = address(this);
  constructor(uint32 i0) payable  {
    s5 |= (((address(this) >= address((bytes20(address(0x0000000000000000000000000000000000000000)) | bytes20(address(0x0000000000000000000000000000000000000000))))) ? uint32(4294967295) : uint32(4294967295)) ^ uint32(0));
    unchecked {
      L0.T0  l0 = s4;
      L0.T0  l1 = l0;
      assert(l1 == s4);
      L0.T0  l2 = s4;
      L0.T0  l3 = l2;
      assert(l3 == s4);
      assert(false);
      address  l4 = s7;
      address  l5 = l4;
      assert(l5 == s7);
      (bool l6, bytes memory l7) = address(this).call((false ? (false ? (false ? bytes("00000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffff") : bytes("ffffffffffffffffffffffffffff00000000000000000000000000000000000000000000")) : bytes("000000000000000000000000000000000000000000000000000004")) : bytes("b552a8ffffffffffffffffffffffffffffffffffffffffffff")));
      uint32  l8 = s5;
      uint32  l9 = l8;
      assert(l9 == s5);
      L0.T0  l10 = s4;
      L0.T0  l11 = l10;
      assert(l11 == s4);
      (s6) = ((~(int120((int120((int120(-526790825280292602323679070433525182) / int120(382548185399899164064520381067261069))) / int120((int120(0) / int120(0))))))));
      assert(s6 == (~(int120((int120((int120(-526790825280292602323679070433525182) / int120(382548185399899164064520381067261069))) / int120((int120(0) / int120(0))))))));
    }
  }
  struct St0 {
    L0.T0 el0;
    bool el1;
    L0.T0 el2;
  }
  using L0 for *;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f2(function (bytes memory, uint224, bool[][][][1][] memory) external   returns (int128, uint200, bytes18) i0,uint120 i1,function (bytes6) external   returns (bool, int232) i2)     returns(bytes18 o0)
{
  bytes17 l0 = bytes17(0x5cc465f46af267841fe7909546a29bf423);
  (int128 l1, uint200 l2, bytes18 l3) = i0(bytes("000000000000000000000000000000000000a92bee1a5b2f5043b5790fdd17f6d3e3f37037c95a0f"),uint224(8071792683566520963688472363887328066182201905791032318564329130154),new bool[][][][1][](9));
}
// ====
// ----
