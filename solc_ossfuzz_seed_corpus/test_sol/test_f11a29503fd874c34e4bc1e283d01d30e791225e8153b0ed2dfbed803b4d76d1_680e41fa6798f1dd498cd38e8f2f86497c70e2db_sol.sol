==== Source:  ====

==== Source: su0.sol ====
function f0(bytes memory i0)      returns(int216[5] memory o0){
}
pragma solidity >= 0.0.0;
struct St0 {
  uint48 el0;
  int48 el1;
}
function f1(bytes12 i0)     {
  for(  bool l0 = false;
;
uint192((uint192(0) / ((uint192(6277101735386680763835789423207666416102355444464034512895) * (uint192(5976314883821931374364860575056050291887010199305245022865) % uint192(6277101735386680763835789423207666416102355444464034512895))) ^ uint192(0)))))
  {
    function (address) internal   l1;
    (i0) = ((true ? (true ? 0 f2 /*suffix expr*/ : bytes12(0x49af8b884315e297648ac75a)) : bytes12(0xf1cfdfcce974b987f73aa3b4)));
    assert(i0 == (true ? (true ? 0 f2 /*suffix expr*/ : bytes12(0x49af8b884315e297648ac75a)) : bytes12(0xf1cfdfcce974b987f73aa3b4)));
    break;
  }
}
function f3(bytes29 i0)      returns(address payable o0,bool o1,bytes23 o2){
  if (i0 == i0)
  {
    for(    0x0000000000000000000000000000000000000007 f4 /*suffix expr*/;
;
)
    {
      delete o1;
    }
  }
}
function f2(int200 i0) pure suffix  returns(bytes12 o0)
{
  (address payable l0, bool l1, bytes23 l2) = f3({i0: (~(bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)))});
  if (i0 >= ((int200(((~(int200((-(int160(72046490227909808424744519458994283429601602809)))))) / int200(803469022129495137770981046170581301261101496891396417650687))) & int200(-469878647165603118801307239371667668681575890562048790378282)) + int200(803469022129495137770981046170581301261101496891396417650687)))
  {
  }
}
function f4(address i0) pure suffix  returns(function (bool, uint88) external   returns (address) o0)
{
}

==== Source: su1.sol ====
function f5(int80 i0)    pure suffix returns(uint200[] memory o0){
  o0 = ((address(0x0000000000000000000000000000000000000003) > address(0x0000000000000000000000000000000000000004)) ? hex"0000000000000000000000000000000000000000" f6 /*suffix expr*/ : new uint200[](7));
}
struct St1 {
  int104 el0;
  bytes8 el1;
}
pragma solidity >= 0.0.0;
function f6(bytes20 i0) pure suffix  returns(uint200[] memory o0)
{
  uint32 l0 = 0 f7 /*suffix expr*/;
}
function f7(uint144 i0) pure suffix  returns(uint16 o0)
{
  for(  bytes15 l0 = (bytes15(0x39398036ac1471455dad3c7cce166b) | (~((true ? bytes3(0xffffff) : bytes3(0xffffff)))));
(bytes18(0xffffffffffffffffffffffffffffffffffff) >= bytes18(0xffffffffffffffffffffffffffffffffffff));
)
  {
    o0 >>= (uint16(36175) | (uint16(0) - ((uint16(65535) % uint16(0)) * uint16(0))));
  }
  revert(string(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbb7df8d0682bdee04d")));
}
// ----
// Warning 5740: (su0.sol:191-441): Unreachable code.
// Warning 6133: (su0.sol:191-441): Statement has no effect.
// Warning 2072: (su0.sol:172-179): Unused local variable.
// Warning 2072: (su0.sol:451-483): Unused local variable.
// Warning 5667: (su0.sol:802-820): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:829-839): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1020-1030): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1037-1055): Unused local variable.
// Warning 2072: (su0.sol:1057-1064): Unused local variable.
// Warning 2072: (su0.sol:1066-1076): Unused local variable.
// Warning 5667: (su1.sol:12-20): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:354-364): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:387-406): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:412-421): Unused local variable.
// Warning 5667: (su1.sol:460-470): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:514-524): Unused local variable.
// Warning 2018: (su0.sol:134-764): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:765-975): Function state mutability can be restricted to pure
// TypeError 8961: (su0.sol:1080-1164): Function cannot be declared as pure because this expression (potentially) modifies the state.
