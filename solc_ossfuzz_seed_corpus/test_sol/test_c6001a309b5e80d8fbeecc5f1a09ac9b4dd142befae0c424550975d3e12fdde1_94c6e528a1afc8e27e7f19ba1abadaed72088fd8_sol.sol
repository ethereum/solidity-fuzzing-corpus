
==== Source: su0.sol ====
function f0()     returns(bytes8 o0)
{
}
library L0 {
  bytes19 public constant cons0 = (((bytes19(0x9ec60b84fd590fd33fa1cabd2de86e8be6ff8d) | bytes19(0xffffffffffffffffffffffffffffffffffffff)) ^ (true ? bytes19(0x00000000000000000000000000000000000000) : bytes19(0x00000000000000000000000000000000000000))) ^ bytes19(0xffffffffffffffffffffffffffffffffffffff));
  modifier m0() 
  {
    (bytes8 l0) = f0();
    int184 l1 = (int184(8666079547705873821257279657446470162255652106214184331) * (int184(12259964326927110866866776217202473468949912977468817407) ^ int184(12259964326927110866866776217202473468949912977468817407)));
    _;
  }
  function f1(bytes29 i0,bool i1,bool i2) public   
  {
  }
  using L0 for *;
  error er0(function () external   ep0);
  modifier m1(bool i0,bool i1) 
  {
    _;
  }
  error er1();
}
error er2(bytes23 ep0);
using L0 for uint;
struct St0 {
  bool el0;
  int96 el1;
  int184 el2;
  string el3;
}
using L0 for uint;
pragma solidity >= 0.0.0;
struct St1 {
  address payable el0;
  int8 el1;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
