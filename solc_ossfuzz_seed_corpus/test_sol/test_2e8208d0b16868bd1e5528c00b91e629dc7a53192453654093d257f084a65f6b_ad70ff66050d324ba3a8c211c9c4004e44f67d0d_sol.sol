==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  bytes4 el0;
}
bytes31 constant cons0 = bytes31(bytes30(bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)));
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  modifier m0(int120 i0) virtual
  {
    _;
  }
  event ev0();
  function f0(bytes calldata i0,function (bytes memory, bool) external   returns (address, bytes15) i1) external virtual m0((int120(664613997892457936451903530140172287) ** (~((uint40(845825568900) ** (uint160(971106074370546792770419778938056023589397292571) ** uint120(0))))))) payable returns(address o0,bool o1)
  {
    o0 = address(this);
    o0 = address(this);
  }
  receive() external virtual  payable
  {
  }
  bytes27  s0 = bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  address public constant cons1 = address(((bytes20(bytes5(bytes19(bytes7(0x00000000000000)))) ^ bytes20(address(0x0000000000000000000000000000000000000000))) ^ bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
  struct St1 {
    int40[1] el0;
  }
  function f2(C0.St1 memory i0) public   
  {
    revert(string("858e2c2042afe9103ec5947a682e57e6fc73ffffffffffffffffffffffffffffff"));
    if (true)
    {
      emit ev0();
      delete i0.el0;
    }
    else if (true)
    {
      emit ev0();
    }
    else
    {
      revert(string("01232a1421fcefffffffffffffffffffffffff"));
    }
    i0.el0 = i0.el0;
  }
  function f3() external    returns(string memory o0)
  {
  }
}
function f4()    
{
}
error er0(C0.St1 ep0);
type T0 is uint168;
contract C1 {
  event ev1(T0 indexed ep0, C0.St1  ep1, C0.St1  ep2);
  modifier m1() virtual
  {
    _;
    (bool l0, bytes memory l1) = address(this).call(type(C0).creationCode);
    require(false, string("1a06aff6d5874feb6f5da12000119bb8f09e98199165cbecb034569a1ebc68bb7bb838790d7afb753a03bb28e19d"));
  }
  int224[2]  s1;
  uint88  s2 = uint88(53874460402745993281395957);
  constructor(int224[2] memory i0)   {
    s1 = i0;
    unchecked {
      require(false, string("ffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000"));
      i0[0] += int224(13479973333575319897333507543509815336818572211270286240551805124607);
    }
  }
  modifier m2() virtual
  {
    _;
  }
  event ev2(T0  ep0);
  type T1 is bytes6;
  function f5() external  m2() payable
  {
    s1[0] |= ((s1[0] ** ((uint176(27928071149778363197057244167204205625657656808078795) ** uint72(3317772991003828261743)) ** uint56(72057594037927935))) ** uint64(0));
    require(true, string("000000000000000000000000000000"));
    C0.St1 memory l0 = C0.St1([int40(0)]);
  }
  C0 public constant cons2 = C0(payable(address(0x0000000000000000000000000000000000000002)));
  function f6(uint240 i0,bytes calldata i1,function (int200, string memory, bytes4) external   i2) public virtual  
  {
  }
}
import "su0.sol";
pragma solidity >= 0.0.0;
library L0 {
  error er1(C0 ep0, address ep1);
  using L0 for *;
  modifier m3() 
  {
    _;
    assert(false);
    _;
    require(true, string("9dfec950cc32d2d98cfdbcb946be1e3dbaf8ef890affffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  function f7() private  m3()  returns(C0 o0)
  {
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112, M113, M114, M115, M116, M117, M118, M119,
    M120, M121, M122, M123, M124, M125, M126, M127,
    M128, M129, M130, M131, M132
  }
}
// ----
// Warning 3149: (su1.sol:254-351): The result type of the exponentiation operation is equal to the type of the first operand (uint40) ignoring the (larger) type of the second operand (uint160) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su1.sol:980-1174): Unreachable code.
// Warning 5740: (su1.sol:1179-1194): Unreachable code.
// Warning 5667: (su1.sol:91-108): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:109-179): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:384-391): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:2372-2388): Unused local variable.
