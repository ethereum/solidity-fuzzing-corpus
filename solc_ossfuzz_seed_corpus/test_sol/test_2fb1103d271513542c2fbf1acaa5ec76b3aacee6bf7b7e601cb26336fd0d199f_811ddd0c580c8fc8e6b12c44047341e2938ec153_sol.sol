
==== Source: su0.sol ====
contract C0 {
  function f0() external virtual  payable returns(int24 o0,string memory o1)
  {
    (bool l0, bytes memory l1) = address(this).call((false ? abi.encodePacked(bytes10(bytes10((true ? bytes11(0xffffffffffffffffffffff) : bytes11(0x0000000000000000000000))))) : bytes("0000000000ffffffffffffffffffffffffffffffffff")));
    bytes6 l2 = bytes6(0x79d3b53cb7e9);
  }
  bytes14   s0 = bytes14(0xffffffffffffffffffffffffffff);
  bytes22   s1;
  bytes7   s2;
  address   s3;
  constructor(bytes22 i0,bytes7 i1,address i2) payable  {
    s1 |= (bytes22(0x380b5dcd8bba28ef73995e03421c3f2416ebe49dc902) | (~(bytes22(0x00000000000000000000000000000000000000000000))));
    s2 |= ((payable(address(this)) <= payable(address(this))) ? (bytes7(0x4499ddff199d4e) ^ bytes7(0x00000000000000)) : bytes7(0xffffffffffffff));
    s3 = address(this);
    unchecked {
      bytes22  l0 = s1;
      bytes22  l1 = l0;
      assert(l1 == s1);
      for(uint solinit0 = 0; solinit0 < ((true ? (true ? this.f0.address : address(this)) : address(this)).balance % 11); solinit0++)
      {
      }
      bytes7  l2 = s2;
      bytes7  l3 = l2;
      assert(l3 == s2);
    }
  }
  fallback() external   
  {
    bytes22  l0 = s1;
    bytes22  l1 = l0;
    assert(l1 == s1);
    bytes22  l2 = s1;
    bytes22  l3 = l2;
    assert(l3 == s1);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
