
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(int192 i0) private   
  {
    string memory l0 = string.concat(string("0000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffff"), (((uint80(1103705466408857186550334) + uint80(1208925819614629174706175)) >= uint80(1208925819614629174706175)) ? string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") : string("c8d91319fdc1dbd4cc925391cbacba958993ec91c39f29f60072cb90c652cc814d")));
    function (function (uint80) external   returns (bytes12, bytes23)) internal   l1;
    bool l2 = true;
  }
}
library L1 {
  error er0();
  function f1(bool i0,bytes20 i1) public   
  {
    assembly
    {
    }
    unchecked {
      uint64 l0 = uint64(0);
    }
    i0 = (address(0x0000000000000000000000000000000000000006) > address(0x0000000000000000000000000000000000000007));
    assert(i0 == (address(0x0000000000000000000000000000000000000006) > address(0x0000000000000000000000000000000000000007)));
  }
  event ev0(bool  ep0, bool  ep1, int8  ep2, bool  ep3);
}
using L0 for int192;
contract C0 {
  using L1 for *;
  using L1 for *;
  receive() external virtual  payable
  {
    int120 l0 = int120((int120(0) / int120(0)));
  }
  uint136  public s0 = uint136(0);
  fallback() external virtual  
  {
    do
    {
    }
    while (true);
    uint136  l0 = s0;
    uint136  l1 = l0;
    assert(l1 == s0);
    assert((((address(this) > address(bytes20(bytes4(0x70793cec)))) ? payable(address(this)) : payable(address(this))) != payable(address(this))));
  }
}
using L0 for int192;
// ====
// ----
