==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0() public   
  {
    assembly
    {
      {
        switch 110741902875409890752447385278889367794949742558128162838597781806406725303474
        case 7287452193751818227079068825974993250687184021213776897001803306507359655409
        {
        }
        case 0
        {
        }
      }
      function af0(ai0, ai1, ai2, ai3, ai4, ai5, ai6, ai7, ai8, ai9, ai10, ai11, ai12, ai13, ai14) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7
      {
        for 
        { let yulinit0 := 0 } lt(yulinit0, mod(ai4, 11)) { yulinit0 := add(yulinit0, 1) }
        {
          return(115438908200784412533909467898077936209952353164102954946258316396315601594728, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        }
      }
    }
  }
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
struct St0 {
  function () external   returns (bool) el0;
  bool el1;
  address payable el2;
}
// ----
// Warning 2018: (su0.sol:41-809): Function state mutability can be restricted to pure
