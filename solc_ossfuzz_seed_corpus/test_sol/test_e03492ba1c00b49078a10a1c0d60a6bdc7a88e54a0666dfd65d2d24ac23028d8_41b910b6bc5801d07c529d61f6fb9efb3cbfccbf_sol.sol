
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address[][3] el0;
  bytes5 el1;
  bool el2;
  uint256 el3;
}

==== Source: su1.sol ====
contract C0 {
  fallback() external   
  {
    uint144 l0 = ((uint144(22300745198530623141535718272648361505980415) | (uint144(0) + (uint144(0) % uint144(22300745198530623141535718272648361505980415)))) & uint144(22300745198530623141535718272648361505980415));
    uint216 l1 = uint216(55233525391578150812597220197048280877193586697107016949384935829);
    bool l2 = false;
    bytes10 l3 = bytes10(0xffffffffffffffffffff);
  }
  struct St1 {
    function (int24, address) external   returns (address payable, address[][3][][4][10][] memory) el0;
    bytes21 el1;
    bool el2;
  }
  bool   s0;
  bytes2   s1;
  mapping(int152 => uint256)  public s2;
  bytes6  public s3 = bytes6(0x46f10fa3c4f8);
  constructor(bool i0,bytes2 i1)   {
    s0 = false;
    s1 = bytes2(0xffff);
    s2[int152(2854495385411919762116571938898990272765493247)] /= ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) | uint256(0)) - ((~(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ** uint152(uint152(0))));
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
      bytes2  l2 = s1;
      bytes2  l3 = l2;
      assert(l3 == s1);
      delete s1;
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
