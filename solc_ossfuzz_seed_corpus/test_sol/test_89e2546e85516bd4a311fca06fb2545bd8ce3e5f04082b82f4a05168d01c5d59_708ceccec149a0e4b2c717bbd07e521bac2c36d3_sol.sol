
==== Source: su0.sol ====
contract C0 {
  int128   s0 = int128(170141183460469231731687303715884105727);
  uint128   s1 = uint128(340282366920938463463374607431768211455);
  bool   s2 = true;
  bytes9  public s3 = bytes9(0xdc9cb820cb3fd29dc2);
  receive() external virtual  payable
  {
    bytes9  l0 = s3;
    bytes9  l1 = l0;
    assert(l1 == s3);
    assembly
    {
      switch s2.slot
      case 0
      {
        switch l1
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          returndatacopy(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), l1, mod(l1, 1024))
          switch l1
          case 115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
          }
          pop(l0)
        }
        case 0
        {
          switch s1.offset
          case 115792089237316195423570985008687907853269984665640564039457584007913129639935
          {
          }
          case 0
          {
            pop(s0.offset)
          }
          return(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), mod(l0, 84420453669073969103000001961516263128612391105627104236370157527385640594954))
        }
        calldatacopy(add(0x80, mod(51190503931269354326198547513438494691656199557952081709685206825327647835784, 1024)), smod(l1, 0), mod(l1, 1024))
      }
    }
  }
  fallback() external   
  {
    int128  l0 = s0;
    int128  l1 = l0;
    assert(l1 == s0);
    bool  l2 = s2;
    bool  l3 = l2;
    assert(l3 == s2);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
