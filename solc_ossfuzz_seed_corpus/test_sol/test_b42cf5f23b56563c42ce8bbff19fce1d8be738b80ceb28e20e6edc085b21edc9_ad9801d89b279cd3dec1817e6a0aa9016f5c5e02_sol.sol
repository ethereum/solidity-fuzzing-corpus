==== Source:  ====

==== Source: su0.sol ====
library L0 {
  modifier m0() 
  {
    _;
  }
}
contract C0 {
  receive() external   payable
  {
    function (uint104, function (string memory, bytes memory, bool) external  ) external   returns (bytes15, bytes4, address payable) l0;
    assembly
    {
      {
      }
    }
    payable(this).transfer(16072095872431782208);
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  int104 immutable  s0 = int104(-4252586042710875735128945289591);
  int144   s1;
  constructor(int144 i0)   {
    s1 %= int144(11150372599265311570767859136324180752990207);
    unchecked {
      payable(this).transfer(0);
      int104  l0 = s0;
      int104  l1 = l0;
      assert(l1 == s0);
    }
  }
}
contract C1 {
  using L0 for *;
  receive() external   payable
  {
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  int120  public s2;
  bytes16  public s3 = bytes16(0x00000000000000000000000000000000);
  bytes9[7][]   s4 = [[bytes9(0xffffffffffffffffff), bytes9(0x0c477fe664f4f7cf5d), bytes9(0xffffffffffffffffff), bytes9(0xffffffffffffffffff), bytes9(0xaeaa20773ebe06c910), bytes9(0x2624a04d169e81ca63), bytes9(0xffffffffffffffffff)]];

	function compareMemoryAndStorage(bytes9[7][] memory v1, bytes9[7][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(bytes9[7] memory v1, bytes9[7] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(int120 i0) payable  {
    s2 &= ((int120(((((int120(0) % int120(-5245672398587604131645128846029364)) * int120(0)) - int120(-78724540326733242505897116077697229)) / int120(0))) & int120(-17467279353556441278276395518944631)) | int120(664613997892457936451903530140172287));
    unchecked {
      int120  l0 = s2;
      int120  l1 = l0;
      assert(l1 == s2);
      bytes9[7][] memory l2 = s4;
      bytes9[7][] memory l3 = l2;
      assert(compareMemoryAndStorage(l3, s4));
      int120  l4 = s2;
      int120  l5 = l4;
      assert(l5 == s2);
      int120  l6 = s2;
      int120  l7 = l6;
      assert(l7 == s2);
      bytes16  l8 = s3;
      bytes16  l9 = l8;
      assert(l9 == s3);
      (l2[(uint48(0) + uint48(44015458206553))]) = ((l3[((uint152(0) * ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] = [bytes9(0xffffffffffffffffff), bytes9(0x000000000000000000), bytes9(0xffffffffffffffffff), bytes9(0x000000000000000000), bytes9(0x1510ca14c39b4a61b6), bytes9(0x000000000000000000), bytes9(0xc1aa5f2946f16600a9)]));
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int248 el0;
  address payable[9] el1;
  uint40 el2;
  address el3;
}
struct St1 {
  function (function () external   returns (function (bool, int120) external   returns (bytes8, int248, uint96[8] memory)), uint144, bytes23) external   el0;
  function (bool, bool, bool) external   returns (uint32, uint240) el1;
  bytes17 el2;
}
// ----
// Warning 2072: (su0.sol:100-232): Unused local variable.
// Warning 5667: (su0.sol:479-488): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1682-1691): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1419-1667): Function state mutability can be restricted to view
