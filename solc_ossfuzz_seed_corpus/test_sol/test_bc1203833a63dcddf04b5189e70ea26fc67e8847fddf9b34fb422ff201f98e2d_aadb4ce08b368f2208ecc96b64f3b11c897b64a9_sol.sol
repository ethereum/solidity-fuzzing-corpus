==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    address payable l0 = payable(address(this));
    function (function (string memory, bool[1][][] memory, int112) external   returns (string memory)) external   returns (address[][] memory, int256) l1;
  }
  function f1() public virtual  payable returns(function (bool) external   o0,address payable[5][2] memory o1)
  {
    assembly
    {
      let al0 := o1
      function af0(ai0, ai1) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12
      {
        ao11 := 22346224742255143173334071974678775506229025720935922200351539629022151600341
        let al1, al2, al3, al4, al5, al6, al7, al8, al9, al10, al11, al12, al13 := af0(callcode(mload(add(0x80, mod(77697346256331615944264127280456201823557006990136278816533183677678688852271, 2048))), 0, 0, 0, 0, 0, 0), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
      switch 34206490920895507296634436701519061071512677434828534479922653281101805615106
      case 0
      {
        revert(113791049587928378973606113148608413689245303919078302269930287141953017107300, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
      case 4979944579070125120499902607975668645685647747007711519315298567756055528533
      {
      }
      let al14 := 21925535727669796867333339265864671372928155481209359238089479503746081736666
    }
    assert(false);
    function (address payable, bool) external   l0;
    address l1 = msg.sender;
  }
  bytes32 immutable public s0 = bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  address   s1;
  int168   s2;
  bytes24   s3 = bytes24(0x18fb1383b2770812c6011971f5ebcf4941c1887a6b96a59f);
  constructor(address i0,int168 i1)   {
    s1 = address(this);
    s2 -= (-((int168(-158074543672133784415372554463969705848098240653669) & (int168(0) - (int168(0) - int168(187072209578355573530071658587684226515959365500927))))));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  address payable   s4;
  address  public s5;
  uint104  public s6 = uint104(20282409603651670423947251286015);
  constructor(address payable i0,address i1) payable  {
    s4 = payable(address(this));
    s5 = address(this);
    {
      address  l0 = s5;
      address  l1 = l0;
      assert(l1 == s5);
      (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
    }
  }
  fallback() external   payable
  {
    address  l0 = s5;
    address  l1 = l0;
    assert(l1 == s5);
  }
}
// ----
// Warning 3628: (su1.sol:26-529): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 2072: (su0.sol:54-72): Unused local variable.
// Warning 2072: (su0.sol:103-252): Unused local variable.
// Warning 5667: (su0.sol:306-335): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1448-1494): Unused local variable.
// Warning 2072: (su0.sol:1500-1510): Unused local variable.
// Warning 5667: (su0.sol:1761-1771): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1772-1781): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:166-184): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:185-195): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:350-357): Unused local variable.
// Warning 2072: (su1.sol:359-374): Unused local variable.
