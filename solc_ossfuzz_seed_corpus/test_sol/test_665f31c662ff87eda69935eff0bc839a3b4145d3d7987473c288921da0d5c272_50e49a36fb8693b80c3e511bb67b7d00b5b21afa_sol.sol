
==== Source: su0.sol ====
contract C0 {
  uint184  public s0 = uint184(24519928653854221733733552434404946937899825954937634815);
  address   s1 = address(this);
  address payable   s2 = payable(address(this));
  bool  public s3 = true;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  receive() external   payable
  {
    function (uint88, function (uint8) internal   returns (address)) internal   returns (uint200, bool) l0;
    address l1 = msg.sender;
    bytes13 l2 = bytes13(0x00000000000000000000000000);
    assembly
    {
    }
  }
  function f1(uint208 i0,int176 i1) private    returns(int88 o0)
  {
    assert(true);
    bool l0 = false;
    bool l1 = true;
  }
  address payable   s4;
  bytes20   s5 = bytes20(address(0x0000000000000000000000000000000000000000));
  bytes13 immutable  s6;
  constructor(address payable i0,bytes13 i1) payable  {
    s4 = payable(address(this));
    s6 = bytes13(bytes4(0xffffffff));
    unchecked {
      address payable  l0 = s4;
      address payable  l1 = l0;
      assert(l1 == s4);
      address payable  l2 = s4;
      address payable  l3 = l2;
      assert(l3 == s4);
      address payable  l4 = s4;
      address payable  l5 = l4;
      assert(l5 == s4);
    }
  }
  fallback() external virtual  
  {
    for(    bytes14 l0 = bytes10(0xffffffffffffffffffff);
true;
uint64(0))
    {
    }
    bytes20  l1 = s5;
    bytes20  l2 = l1;
    assert(l2 == s5);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
