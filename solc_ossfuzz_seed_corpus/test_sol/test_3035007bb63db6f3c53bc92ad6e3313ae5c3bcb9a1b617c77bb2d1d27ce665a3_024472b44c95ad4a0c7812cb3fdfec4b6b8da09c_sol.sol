
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() internal      {
    if (false)
    {
      return;
    }
  }
  type T0 is bytes5;
  fallback() external   payable
  {
  }
  address payable   s0 = payable(address(this));
  uint240   s1 = uint240(292228962343647115264283448038360665425516430300629784241143652866416518);
  address   s2;
  constructor(address i0)   {
    s2 = address(this);
    unchecked {
    }
  }
}
contract C1 is C0 {
  int240   s3 = int240(0);
  mapping(bool => bool)   s4;
  constructor(address i0) payable C0(address(this))
  {
    s2 = address((bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) & bytes20(address(0x0000000000000000000000000000000000000000))));
    s4[false] = false;
    {
    }
  }
  function f2(address i0,int240 i1) public virtual  payable  returns(int24 o0,bytes10 o1)  {
  }
}
function f3(address i0)    pure suffix returns(address o0){
  if (i0 >= address(0x0000000000000000000000000000000000000003))
  {
    if (i0 != address(0x0000000000000000000000000000000000000005))
    {
      while (false)
      {
      }
    }
    if (i0 == address(0x0000000000000000000000000000000000000003))
    {
      delete o0;
    }
    else
    {
      return (address(0x0000000000000000000000000000000000000008));
    }
  }
  else if (i0 > address(0x0000000000000000000000000000000000000001))
  {
    if (i0 >= address(0x0000000000000000000000000000000000000004))
    {
      function (C0.T0) internal   returns (bytes11) l0;
      o0 = address(0x0000000000000000000000000000000000000008);
      assert(o0 == address(0x0000000000000000000000000000000000000008));
    }
    o0 = address(0x0000000000000000000000000000000000000003);
    assert(o0 == address(0x0000000000000000000000000000000000000003));
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C2 {

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f4(string calldata i0) external      {
    do
    {
      break;
    }
    while (true);
  }
  function f5(bytes19 i0,address i1) internal virtual    returns(address o0,function (int112, uint240, int40) external   returns (address payable) o1,int56 o2)  {
  }
  receive() external   payable
  {
  }
  type T1 is address payable;
  event ev0(int64  ep0, bytes  ep1) anonymous;
  address payable   s5 = payable(address(this));
  bytes2   s6 = bytes2(0x0000);
  bytes25   s7 = bytes25(0x00000000000000000000000000000000000000000000000000);
}
// ====
// ----
