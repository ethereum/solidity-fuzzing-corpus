
==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
  }
  error er0();
  struct St0 {
    mapping(bool => uint208)[10] el0;
    bytes el1;
  }
  bytes23   s0 = bytes23(0x5d06f0903869fa97206a8b237404c4867a4b304bb5c985);
  address payable   s1 = payable(address(this));
  bool  public s2;
  uint112  public s3 = uint112(1039426170284627875512276209165096);
  constructor(bool i0) payable  {
    s2 = true;
    unchecked {
    }
  }
  fallback() external virtual  
  {
    revert er0();
  }
  function f2(uint112 i0) external     returns(int232 o0,int104 o1)  {
    for(    int152 l0 = (int152(-635153759461534628475896955113692601761766859) - int152(1997374847209955787827182197910445092549864162));
false;
)
    {
      (bool l1) = payable(this).send(9651917039892280358);
      return (((~(int232(0))) - int232(3450873173395281893717377931138512726225554486085193277581262111899647)), (-((-(int104(-9785406175350722398451475303417))))));
    }
  }
}
struct St1 {
  bool el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T0 is bytes27;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C1 {
  struct St2 {
    int24 el0;
  }
  struct St3 {
    function (bool, function (bytes memory, function (int152, function (int248, T0, address) external   returns (bool, bool[1] memory, C1.St2 memory), address payable) external   returns (int72), C1.St2 memory) external  ) external   returns (int240, C1.St2 memory) el0;
    address payable el1;
  }
  struct St4 {
    C1.St3 el0;
    T0 el1;
  }
  uint56  public s4;
  int200 immutable public s5 = int200(-111729587062330967954722719554605986684728239148675177233944);
  bool   s6;
  constructor(uint56 i0,bool i1) payable  {
    s4 = uint56((((uint56(19640322311374749) & (uint56(0) & uint56(0))) * uint56(58134103731236990)) / uint56(72057594037927935)));
    s6 = false;
    unchecked {
      require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
    }
  }
}
// ====
// ----
