
==== Source: su0.sol ====
function f0()     returns(bool o0)
{
  (o0) = (false);
}
contract C0 {
  modifier m0(bytes32 i0) 
  {
    _;
    assembly
    {
    }
  }
  modifier m1() virtual
  {
    _;
    (bool l0) = f0();
    if (true)
    {
    }
    (bool l1, bytes memory l2) = address(this).call("fe3110823957b82123e9af7da9d912491b289f8744065bdc7fe627");
  }
  error er0();
  uint176 public constant cons0 = uint176(((~(((((uint176(0) * uint176(95780971304118053647396689196894323976171195136475135)) % uint176(0)) ^ uint176(0)) + uint176(0)))) / uint176(95780971304118053647396689196894323976171195136475135)));
  mapping(bool => bytes30)   s0;
  constructor() payable  {
    s0[((uint80(395846946492245203811397) >= (uint80(1208925819614629174706175) * (uint80(0) - uint80(0)))) || true)] ^= bytes30(0x58efb6426333b6e66fd75fa23c07e15223c792528a331c0ca716aff95811);
    unchecked {
      address l0 = address(this);
      (bool l1, bytes memory l2) = address(this).call("0000000000000000000000000000000000000000000000000000000000000000");
      int176 l3 = int176((((int176(0) & int176(((int176(0) ** uint128(uint128(340282366920938463463374607431768211455))) / int176(0)))) & int176(0)) / int176(-43427237026873807181946226307035609391645020923002226)));
    }
  }
  type T0 is address payable;
  function f1(address i0,function (bytes memory, address payable) external   i1) external virtual m1()  returns(int40 o0)
  {
  }
}
error er1();
type T1 is bool;
pragma solidity >= 0.0.0;
// ====
// ----
