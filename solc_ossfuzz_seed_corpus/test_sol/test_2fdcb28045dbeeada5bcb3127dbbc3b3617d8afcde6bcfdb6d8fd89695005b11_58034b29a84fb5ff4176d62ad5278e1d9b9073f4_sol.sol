
==== Source: su0.sol ====
address payable constant cons0 = payable(0x0000000000000000000000000000000000000000);
pragma solidity >= 0.0.0;
error er0();
struct St0 {
  bytes12 el0;
  uint168 el1;
  mapping(int160 => mapping(bool => address)) el2;
}
contract C0 {
  receive() external   payable
  {
  }
  struct St1 {
    bytes6 el0;
    address el1;
    bytes25 el2;
  }
  bytes30 public constant cons1 = ((bytes30(0x000000000000000000000000000000000000000000000000000000000000) ^ (((bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) & bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) | bytes30(0x000000000000000000000000000000000000000000000000000000000000))) | bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
  error er1();
  function f1() private   
  {
  }
  type T0 is address payable;
  function f2(C0.St1 memory i0,function (bytes17) external   returns (bytes memory) i1,bool i2) public virtual   returns(function () external   returns (uint136)[] memory o0,uint208 o1)
  {
    assembly
    {
      i2 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      i0 := cons0
      revert(0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    }
  }
  C0.St1   s0 = C0.St1(bytes6(0x000000000000), address(0x0000000000000000000000000000000000000008), bytes25(0x00000000000000000000000000000000000000000000000000));
  mapping(bool => int248)   s1;
  address  public s2;
  constructor(address i0) payable  {
    s2 = address(this);
    s1[true] |= (s1[false] * int248(0));
    unchecked {
      if (false)
      {
      }
      bytes storage l0;
      if (false)
      {
      }
      else
      {
      }
    }
  }
}
type T1 is int168;
// ====
// ----
