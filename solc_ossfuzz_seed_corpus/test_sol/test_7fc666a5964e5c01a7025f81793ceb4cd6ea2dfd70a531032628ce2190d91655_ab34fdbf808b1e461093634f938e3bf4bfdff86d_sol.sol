
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is bool;
  C0.T0 public constant cons0 = C0.T0.wrap(true);
  type T1 is int8;
  mapping(bool => C0.T0)   s0;
  bytes11   s1;
  bytes28   s2 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
  constructor(bytes11 i0)   {
    s1 ^= (bytes11(0xffffffffffffffffffffff) | bytes11(bytes12(0x000000000000000000000000)));
    s0[(false ? true : true)] = s0[(false ? false : true)];
    unchecked {
    }
  }
}
function f0(int24 i0,bool i1)      returns(uint72 o0,uint184 o1){
  return ((uint72(2726546341896965946005) | ((uint72(0) ** uint160(uint160(1461501637330902918203684832716283019655932542975))) ^ uint72(0))), uint184(5889482239680617065207309520083178777418578873306841403));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T2 is bytes25;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,

eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }




function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) | T2.unwrap(y)); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) & T2.unwrap(y)); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) ^ T2.unwrap(y)); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(~T2.unwrap(x)); }





function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



function f1()      returns(function (uint232[] memory, int88) external   returns (address payable, uint232, bytes30) o0,bytes1 o1,int128 o2){
  return (o0, bytes1(0xff), int128(170141183460469231731687303715884105727));
}
T2 constant cons1 = T2.wrap(bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
// ====
// ----
