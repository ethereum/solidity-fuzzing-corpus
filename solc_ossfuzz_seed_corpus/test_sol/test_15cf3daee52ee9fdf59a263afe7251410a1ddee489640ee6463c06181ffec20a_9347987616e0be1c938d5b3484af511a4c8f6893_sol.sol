
==== Source: su0.sol ====
contract C0 {
  event ev0();
  struct St0 {
    string el0;
    uint32 el1;
    address el2;
  }
  bytes18 immutable  s0;
  address payable   s1 = payable(address(this));
  bool  public s2 = false;
  bytes7  public s3 = bytes7(0xda05691e373de8);
  constructor(bytes18 i0)   {
    s0 = bytes17(0xffffffffffffffffffffffffffffffffff);
    {
    }
  }
  function f0(bytes7 i0) private    returns(int224 o0,address o1)
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
    bytes7  l2 = s3;
    bytes7  l3 = l2;
    assert(l3 == s3);
  }
}
library L0 {
  function f1() public   
  {
  }
  modifier m0() 
  {
    function (int240, address payable) internal   l0;
    int152 l1 = (((int152((int152(2744323134824799218335594037711195478010335152) / int152((int152(0) / int152(0))))) - int152(-1207730707923640631961677387930055494578838574)) * int152(2854495385411919762116571938898990272765493247)) + int152(2854495385411919762116571938898990272765493247));
    _;
  }
}
pragma solidity >= 0.0.0;
int16 constant cons0 = 32767;

==== Source: su1.sol ====
library L1 {
  error er0();
  function f2(bytes8 i0,address[][4] memory i1) public    returns(int16 o0)
  {
    assembly
    {
      sstore(115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    }
  }
}
contract C1 {
  using L1 for *;
  using L1 for *;
  int200   s4 = int200(0);
  bool   s5;
  bool  public s6;
  constructor(bool i0,bool i1)   {
    s5 = (true ? true : false);
    s6 = false;
    unchecked {
      s4 += ((((int128(uint128(0)) | int128(0)) ^ int128(170141183460469231731687303715884105727)) - int128(106423980897217542982038819121877624410)) + int128(170141183460469231731687303715884105727));
      (bool l0, bytes memory l1) = address(this).call(bytes((true ? string("000000000000000000000000000000000000ffffffffffffffffffffffffff") : string("000000000000"))));
      (s5, s4) = (false, int200(0));
      assert(s5 == false);
      assert(s4 == int200(0));
      0;
    }
  }
  using L1 for *;
}
using L1 for bytes8;
using L1 for bytes8;
pragma solidity >= 0.0.0;
// ====
// ----
