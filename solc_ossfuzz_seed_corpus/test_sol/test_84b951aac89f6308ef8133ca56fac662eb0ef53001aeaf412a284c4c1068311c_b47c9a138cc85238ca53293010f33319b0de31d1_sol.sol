
==== Source: su0.sol ====
struct St0 {
  uint128 el0;
  bytes24[] el1;
  address el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  uint88  public s0 = uint88(309485009821345068724781055);
  uint112   s1;
  bytes10  public s2;
  bool   s3;
  constructor(uint112 i0,bytes10 i1,bool i2)   {
    s1 >>= uint112(((((uint112((uint88(309485009821345068724781055) % uint88(173191839010103041936837321))) & uint112(0)) % uint112(799155941100936188322173685117234)) * uint112(2712773771994127309486359786630798)) / uint112(0)));
    s2 |= bytes10(0x00000000000000000000);
    s3 = false;
    {
    }
  }
  fallback() external   
  {
    return;
  }
  type T0 is bool;
  function f1(uint112 i0) private     returns(int184 o0,int112 o1)  {
    return ((int184(-11927031634141067062618108149596513534998402035032314440) * int184(-12058495152892259360162582762326142064177950524587080606)), int112(2596148429267413814265248164610047));
  }
  bytes28 public constant cons0 = bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  function f2(bool i0) external   payable   {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000"));
  }
  type T1 is int144;
}
type T2 is address;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,

eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }





function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) | bytes20(T2.unwrap(y)))); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) & bytes20(T2.unwrap(y)))); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) ^ bytes20(T2.unwrap(y)))); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(address(~bytes20(T2.unwrap(x)))); }






function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



error er0();

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T3 is bytes27;

using {
lt3 as <, gt3 as >, leq3 as <=, geq3 as >=,
bitor3 as |, bitand3 as &, bitxor3 as ^, bitnot3 as ~,

eq3 as ==, neq3 as !=

} for T3 global;



function lt3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) < T3.unwrap(y); }

function gt3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) > T3.unwrap(y); }

function leq3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) <= T3.unwrap(y); }

function geq3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) >= T3.unwrap(y); }




function bitor3(T3 x, T3 y) pure returns (T3) { return T3.wrap(T3.unwrap(x) | T3.unwrap(y)); }

function bitand3(T3 x, T3 y) pure returns (T3) { return T3.wrap(T3.unwrap(x) & T3.unwrap(y)); }

function bitxor3(T3 x, T3 y) pure returns (T3) { return T3.wrap(T3.unwrap(x) ^ T3.unwrap(y)); }

function bitnot3(T3 x) pure returns (T3) { return T3.wrap(~T3.unwrap(x)); }





function eq3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) == T3.unwrap(y); }

function neq3(T3 x, T3 y) pure returns (bool) { return T3.unwrap(x) != T3.unwrap(y); }



import "su0.sol";
// ====
// ----
