
==== Source: su0.sol ====
library L0 {
  function f0(bool i0) internal   
  {
  }
  function f1() public    returns(uint32 o0)
  {
    bytes22 l0 = (true ? (~(bytes7(0xffffffffffffff))) : bytes22(0x00000000000000000000000000000000000000000000));
  }
}
contract C0 {
  using L0 for *;
  using L0 for *;
  bytes4  public s0;
  constructor(bytes4 i0)   {
    s0 &= bytes4(0xffffffff);
    unchecked {
      (s0) = (bytes4(0xffffffff));
      assert(s0 == bytes4(0xffffffff));
      bytes4  l0 = s0;
      bytes4  l1 = l0;
      assert(l1 == s0);
    }
  }
  using L0 for *;
  using L0 for *;
  function f2() external virtual  
  {
    assembly
    {
      if prevrandao()
      {
        let al0 := 0
        switch s0.slot
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          al0 := s0.offset
        }
        default
        {
          return(gt(s0.slot, 115792089237316195423570985008687907853269984665640564039457584007913129639935), s0.offset)
        }
      }
    }
  }
}
library L1 {
  function f3(address i0) external    returns(int72 o0)
  {
  }
  function f4(address payable i0,int80 i1) private    returns(uint200 o0,bool o1)
  {
    uint48 l0 = uint48(281474976710655);
    revert(string("000000000000000000000000000000000000"));
  }
  function f5(string memory i0,uint240 i1,int32 i2) external    returns(function (bool) external   returns (int24, address) o0,bytes3 o1,address payable o2)
  {
  }
}
pragma solidity >= 0.0.0;
using L0 for bool;

==== Source: su1.sol ====
import "su0.sol";
library L2 {
  function f6(uint224 i0) public   
  {
    int48 l0 = ((int48(0) | (-(((int48(140737488355327) ** uint208(uint208(0))) % int48(140737488355327))))) % int48(0));
  }
}
using L2 for uint224;
pragma solidity >= 0.0.0;
// ====
// ----
