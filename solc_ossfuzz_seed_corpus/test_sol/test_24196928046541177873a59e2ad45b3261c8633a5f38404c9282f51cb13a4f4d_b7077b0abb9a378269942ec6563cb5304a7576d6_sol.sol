
==== Source: su0.sol ====
contract C0 {
  bytes18 immutable public s0 = bytes18(0xffffffffffffffffffffffffffffffffffff);
  uint96   s1 = uint96(72514144123803950681816564644);
  bool   s2 = false;
  address  public s3;
  constructor(address i0)   {
    s3 = address(this);
    {
      uint96  l0 = s1;
      uint96  l1 = l0;
      assert(l1 == s1);
      bytes18  l2 = s0;
      bytes18  l3 = l2;
      assert(l3 == s0);
      bool  l4 = s2;
      bool  l5 = l4;
      assert(l5 == s2);
      (s1) = ((uint96((((((uint96(79228162514264337593543950335) & uint96(42092708555389846525576313572)) % uint96(45950948727721596000340243487)) & uint96(79228162514264337593543950335)) & uint96(0)) / uint96(0))) - uint96(57066271402101989791081513958)));
      assert(s1 == (uint96((((((uint96(79228162514264337593543950335) & uint96(42092708555389846525576313572)) % uint96(45950948727721596000340243487)) & uint96(79228162514264337593543950335)) & uint96(0)) / uint96(0))) - uint96(57066271402101989791081513958)));
    }
  }
  function f0() external virtual  payable returns(bytes memory o0)
  {
  }
  function f1() external    returns(bytes23[7] memory o0)
  {
    s2 = true;
    assert(s2 == true);
    try this.f0() returns (bytes memory l0)
    {
      o0[uint256(0)] &= bytes23(0x0000000000000000000000000000000000000000000000);
      address  l1 = s3;
      address  l2 = l1;
      assert(l2 == s3);
    }
    catch
    {
      o0[(uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / (~(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(87497262260571142241408406028877654460724591034319857846637061335204346539435)))))) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] = o0[(false ? uint256(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) << uint80(uint80(0))) / uint256(101995597369976217035088440024848149121873246828795560688231048134234313525148))) : uint256(0))];
      assert(o0[(uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / (~(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(87497262260571142241408406028877654460724591034319857846637061335204346539435)))))) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] == o0[(false ? uint256(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) << uint80(uint80(0))) / uint256(101995597369976217035088440024848149121873246828795560688231048134234313525148))) : uint256(0))]);
      bytes18  l3 = s0;
      bytes18  l4 = l3;
      assert(l4 == s0);
    }
    uint96  l5 = s1;
    uint96  l6 = l5;
    assert(l6 == s1);
    assert(false);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
