
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address el0;
}

==== Source: su1.sol ====
contract C0 {
  event ev0(uint32  ep0, function (bool) external   returns (bool, bytes26[] memory, int152)  ep1);
  function f0(bool i0) public virtual     {
    return;
  }
  uint96   s0 = uint96(79228162514264337593543950335);
  int16   s1;
  constructor(int16 i0)   {
    s1 %= int16(-4302);
    unchecked {
    }
  }
  function f1(uint96 i0,uint96 i1) internal     returns(int64[] memory o0)  {
    int16  l0 = s1;
    int16  l1 = l0;
    assert(l1 == s1);
  }
}
function f2(int96[] memory i0)      returns(int128 o0,bytes30 o1){
  o0 ^= (-(int128(170141183460469231731687303715884105727)));
  return (((int128(-156052678554511694655476617195388755127) % ((int48(73338662647810) == int48(0)) ? int128(170141183460469231731687303715884105727) : int128(-19095151594885335067776179495827326916))) % int128(0)), bytes30(0x573ff44ba6a058b769c13fa0fb464a5077117ed78245726b451c9d20a20b));
}
function f3()      returns(bytes24 o0){
  o0 &= bytes24(0x99ec7cedd3825207ed31ba8986acd82ddd6b82f766d8fd56);
}
type T0 is bytes21;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
// ====
// ----
