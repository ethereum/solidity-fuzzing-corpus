==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  bool   s0;
  bytes28  public s1 = bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  constructor(bool i0)   {
    s0 = false;
    {
      bytes28  l0 = s1;
      bytes28  l1 = l0;
      assert(l1 == s1);
      require(false, string.concat(string("00000000000000000000000000000000000000000000000000"), string("ffffffffffffffffffffff00000000000000000000000000"), string("479f36c4a6c9d0c69389b714bb6e8d32d864b286feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), string("0000000000000000000000ffffffffffffffffffffffffffffffffffff")));
      for(      address payable l2 = payable(address(this));
;
)
      {
        for(        function (string memory, bytes7, int104) internal   l3;
;
(uint96(79228162514264337593543950335) - (~((((uint96(79228162514264337593543950335) - uint96(0)) ^ uint96(0)) * uint96(0))))))
        {
          bytes11 l4 = bytes11(0x0000000000000000000000);
          address l5 = ((int64(((((int64(9223372036854775807) | int64(-5872893597856613111)) & int64(7551044125108078461)) ** uint256(uint256(73899337404351015153511066080513319290199047162598498509400073048519813871395))) / int64(-1001677379401636209))) <= int64(0)) ? address(this) : address(this));
          bool[9] memory l6 = (false ? [false, false, false, false, true, true, false, true, false] : [true, true, true, true, false, false, false, true, false]);
          uint152 l7 = uint152(0);
        }
      }
    }
  }
  type T0 is uint96;
  receive() external   payable
  {
    bytes28  l0 = s1;
    bytes28  l1 = l0;
    assert(l1 == s1);
    bool  l2 = s0;
    bool  l3 = l2;
    assert(l3 == s0);
  }
}
library L0 {
  function f1() public    returns(bytes12[][][] memory o0,int248 o1)
  {
    function (uint48, uint192[][][] memory, int192[][][] memory) external   returns (bytes11) l0;
  }
  function f2(function (bytes14, C0.T0) external   returns (function (uint16) external  , address payable) i0,bool i1) external    returns(bool o0,uint176 o1)
  {
  }
}
pragma solidity >= 0.0.0;
library L1 {
  modifier m0(int24 i0,function (address payable) internal   i1) 
  {
    C0.T0 l0 = C0.T0.wrap(uint96(5409341867060996108323585155));
    _;
  }
}
// ----
// Warning 3149: (su0.sol:967-1155): The result type of the exponentiation operation is equal to the type of the first operand (int64) ignoring the (larger) type of the second operand (uint256) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 6133: (su0.sol:738-864): Statement has no effect.
// Warning 5667: (su0.sol:133-140): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:603-621): Unused local variable.
// Warning 2072: (su0.sol:680-734): Unused local variable.
// Warning 2072: (su0.sol:886-896): Unused local variable.
// Warning 2072: (su0.sol:944-954): Unused local variable.
// Warning 2072: (su0.sol:1246-1263): Unused local variable.
// Warning 2072: (su0.sol:1409-1419): Unused local variable.
// Warning 5667: (su0.sol:1697-1720): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1721-1730): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1740-1832): Unused local variable.
// Warning 2018: (su0.sol:1665-1837): Function state mutability can be restricted to pure
