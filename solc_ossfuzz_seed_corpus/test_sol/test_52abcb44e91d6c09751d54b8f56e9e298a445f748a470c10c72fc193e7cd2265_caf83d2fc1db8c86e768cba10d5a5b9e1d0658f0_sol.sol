
==== Source: su0.sol ====
bool constant cons0 = ((((((int120(0) - int120(-465626699050280876948071498128253002)) | int120(89923371948035226422895946288424083)) | int120(664613997892457936451903530140172287)) ** uint152(uint152(5708990770823839524233143877797980545530986495))) <= int120(664613997892457936451903530140172287)) && false);
type T0 is bool;
pragma solidity >= 0.0.0;
function f0(bytes32[] memory i0)    
{
  assembly
  {
    stop()
    switch i0
    case 78949820545735990058489179002570356017406454053151337000925775428233331056279
    {
      {
      }
      if cons0
      {
        let al0 := 0
        if 109483170873917477880856488934177355949488842310880243508672303598910831597381
        {
        }
        return(al0, sload(mload(mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 2048))))
      }
      i0 := 24862011055959055079737988401139715858032422755466918280522149596789515365786
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7

}
library L0 {
  modifier m0() 
  {
    _;
    if (false)
    {
      address(0x0000000000000000000000000000000000000004);
    }
    else if (false)
    {
      f0(new bytes32[](2));
      for(      function (address payable) internal   l0;
;
)
      {
        break;
        do
        {
          _;
          _;
          do
          {
            _;
            while (false)
            {
              _;
              continue;
              continue;
              _;
            }
          }
          while (true);
          f0({i0: new bytes32[](1)});
          if (((uint152(318552672900928588018771811211404226413913081) | ((uint152(1869572006641705386343296228898633473141239324) - uint152(2127968584986382724953487031400059272644037491)) * uint152(0))) == uint152(0)))
          {
            T0 l1 = T0.wrap(true);
            break;
          }
          else if (false)
          {
            continue;
            break;
          }
        }
        while ((uint80(1208925819614629174706175) == uint80(741339611703119945326224)));
      }
    }
    else if (true)
    {
      if (cons0)
      {
      }
      else if (true)
      {
        do
        {
          break;
          assert(true);
        }
        while (false);
      }
      else if (true)
      {
      }
    }
  }
  function f1() internal   
  {
    unchecked {
      f1();
      if (false)
      {
      }
      else if ((true != true))
      {
      }
      else
      {
      }
      int8 l0 = int8(0);
    }
  }
  function f2(bool i0) private   
  {
    if ((false && ((int88(154742504910672534362390527) % (int88(0) * int88(0))) > int88(154742504910672534362390527))))
    {
    }
    else
    {
    }
    for(    uint96 l0 = uint96((((((uint96(79071918729782193661735060962) << uint224(uint224(0))) | uint96(0)) & uint96(79228162514264337593543950335)) << uint80(uint80(0))) / uint96(79228162514264337593543950335)));
;
)
    {
      continue;
      if ((EN0(uint8(4)) >= EN0.M3))
      {
        f1();
      }
    }
  }
  modifier m1() 
  {
    assembly
    {
      switch cons0
      case 0
      {
      }
      default
      {
      }
      {
        function af0(ai0, ai1) -> ao0
        {
          let al1 := af0(ai0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        }
      }
    }
    _;
  }
  T0 public constant cons1 = T0.wrap(true);
  using L0 for *;
  event ev0(string  ep0, function () external   returns (bytes memory)  ep1);
}
struct St0 {
  EN0 el0;
  string el1;
  function (bytes20) external   returns (EN0) el2;
  int128 el3;
}
// ====
// ----
