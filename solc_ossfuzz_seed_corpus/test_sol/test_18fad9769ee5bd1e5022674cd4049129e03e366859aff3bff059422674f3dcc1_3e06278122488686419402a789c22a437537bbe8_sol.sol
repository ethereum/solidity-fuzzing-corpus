
==== Source: su0.sol ====
library L0 {
  function f0(bool i0,int120 i1) external   
  {
    bytes20 l0 = bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));
  }
  function f1(uint224 i0,function (bool, bytes6) external   returns (uint8) i1) private    returns(uint240 o0,uint176 o1)
  {
  }
}
pragma solidity >= 0.0.0;
using L0 for bool;
using L0 for bool;
using L0 for bool;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L1 {
  type T0 is int176;
  function f2() external    returns(int192 o0,bytes3 o1,uint136 o2)
  {
    L1.T0 l0 = L1.T0.wrap(int176(43358709333386359106418267111287222052188932647815503));
  }
  event ev0();
}
struct St0 {
  bytes8 el0;
  bool el1;
}
contract C0 {
  using L1 for *;
  fallback() external   payable
  {
    payable(this).transfer(0);
  }
  address payable   s0;
  int208   s1 = int208(38171977205463580068328423676768597012742620235428073952234336);
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
      address payable  l0 = s0;
      address payable  l1 = l0;
      assert(l1 == s0);
      address payable  l2 = s0;
      address payable  l3 = l2;
      assert(l3 == s0);
    }
  }
}
// ====
// ----
