
==== Source: su0.sol ====
library L0 {
  function f0(uint104 i0) external    returns(int40 o0)
  {
    string memory l0 = string("bd66095f8009ac7957bf32d433b107c7e46871b4fa618dde563c8e74257ccb3dd3950e744bd3546ff241210ad64ad473");
    uint128 l1 = (((uint128(0) - (uint80(677809387622693144934863) - uint80(1208925819614629174706175))) << uint56(uint56(72057594037927935))) ** uint192(uint192(6277101735386680763835789423207666416102355444464034512895)));
    bool l2 = true;
    address payable l3 = payable(address(0x0000000000000000000000000000000000000004));
  }
  function f1(uint80 i0,function (int128) external   returns (bytes23) i1) private    returns(address payable o0,int240 o1,bool o2)
  {
    bytes memory l0 = bytes("0000000000000000000000ffffffffffffffffffffffffffffffffffff");
    (bytes23 l1) = i1(int128(170141183460469231731687303715884105727));
    int208 l2 = ((~(int208(0))) % int208(0));
  }
}
contract C0 {
  int208   s0 = int208(0);
  fallback() external   payable
  {
  }
  using L0 for *;
  using L0 for *;
  event ev0(address payable  ep0);
}
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



using L0 for uint104;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
