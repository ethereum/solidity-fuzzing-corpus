
==== Source: su0.sol ====
library L0 {
  function f0(bytes memory i0,int96 i1) external    returns(bool o0)
  {
    uint80[10] memory l0 = [uint80(1208925819614629174706175), uint80(0), uint80(228850328543213110506997), uint80(956765550382831952982031), uint80(1208435325140595036037416), uint80(353327123542135770191616), uint80(0), uint80(1208925819614629174706175), uint80(344317558348599845111293), uint80(1208925819614629174706175)];
    assert((true ? (uint88(196089605357201112611479972) == uint88(0)) : false));
  }
}
pragma solidity >= 0.0.0;
using L0 for bytes;
using L0 for bytes;

==== Source: su1.sol ====
library L1 {
  function f1(function (int208, address, bool) external   returns (bool, address[][][6][][] memory, bool) i0) public    returns(int56 o0)
  {
    bool l0 = false;
  }
  modifier m0(function (bytes memory) internal   i0) 
  {
    bytes22 l0 = bytes22(0x00000000000000000000000000000000000000000000);
    function (bool, uint40) internal   l1;
    bytes15[10][1][][][10][5] memory l2 = [[new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2)], [new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2)], [new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2)], [new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2)], [new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2), new bytes15[10][1][][](2)]];
    _;
  }
}
using L1 for function (int208, address, bool) external   returns (bool, address[][][6][][] memory, bool);
contract C0 {
  using L1 for *;
  using L1 for *;
  using L1 for *;
  int224   s0 = int224(0);
  fallback() external virtual  
  {
    unchecked {
      int224  l0 = s0;
      int224  l1 = l0;
      assert(l1 == s0);
      int224  l2 = s0;
      int224  l3 = l2;
      assert(l3 == s0);
    }
    int224  l4 = s0;
    int224  l5 = l4;
    assert(l5 == s0);
  }
  error er0(address payable ep0);
}
using L1 for function (int208, address, bool) external   returns (bool, address[][][6][][] memory, bool);
pragma solidity >= 0.0.0;
using L1 for function (int208, address, bool) external   returns (bool, address[][][6][][] memory, bool);
// ====
// ----
