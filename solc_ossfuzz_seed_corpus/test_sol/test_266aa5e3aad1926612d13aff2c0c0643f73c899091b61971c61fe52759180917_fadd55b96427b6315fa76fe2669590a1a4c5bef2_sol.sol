
==== Source: su0.sol ====
struct St0 {
  bool el0;
}
library L0 {
  function f0(function (int104, bytes25) external   returns (bool, int48[] memory, uint192) i0) external   
  {
    address payable l0 = payable(i0.address);
    try i0(int104(10141204801825835211973625643007),bytes25(0x00000000000000000000000000000000000000000000000000)) returns (bool l1, int48[] memory l2, uint192 l3)
    {
      function (int48) internal   returns (uint120[2][][1][3] memory) l4;
      l2[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] += ((int32(0) ^ (int24(8388607) % int32(1472288781))) & int48(140737488355327));
    }
    catch
    {
    }
    catch Error(string memory l5)
    {
    }
    catch Panic(uint256 l6)
    {
      (l6) = (((uint256(((uint160(1423021741142461743585289171197608583437688588829) ** uint16(uint16(0))) / uint256(0))) >> uint176(uint176(91204717897321445075608910424050538850887485670881147))) ^ uint256(0)));
      assert(l6 == ((uint256(((uint160(1423021741142461743585289171197608583437688588829) ** uint16(uint16(0))) / uint256(0))) >> uint176(uint176(91204717897321445075608910424050538850887485670881147))) ^ uint256(0)));
    }
  }
}
pragma solidity >= 0.0.0;
using L0 for function (int104, bytes25) external   returns (bool, int48[] memory, uint192);

==== Source: su1.sol ====
library L1 {
  function f1(function (uint200, int136) external   returns (bytes8, uint184) i0) public    returns(bytes13 o0)
  {
  }
  function f2() public   
  {
  }
}
using L1 for function (uint200, int136) external   returns (bytes8, uint184);
using L1 for function (uint200, int136) external   returns (bytes8, uint184);
pragma solidity >= 0.0.0;
using L1 for function (uint200, int136) external   returns (bytes8, uint184);
// ====
// ----
