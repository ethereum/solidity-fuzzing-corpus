
==== Source: su0.sol ====
contract C0 {
  function f0() private     returns(address payable o0)  {
    return (payable(address(this)));
  }
  event ev0(bytes30 indexed ep0);
  uint192   s0 = uint192(6277101735386680763835789423207666416102355444464034512895);
  uint112  public s1 = uint112(0);
  mapping(uint192 => bytes)  public s2;
  bool immutable public s3 = true;
  constructor()   {
    s2[((~((~((~(((uint192(5453070972892370723711526352107008583854773859196124071344) ^ uint192(6153128710423483591372822312594377809018317969237353225356)) >> uint80(uint80(1208925819614629174706175))))))))) + uint192(6277101735386680763835789423207666416102355444464034512895))] = bytes("eca7b6b66e057e343d9d0b19831fb7881a3b7894df84bfffffffffffffffffffffffffffff");
    unchecked {
    }
  }
  struct St0 {
    function (int216, bytes19, bool) external   returns (int16, uint216) el0;
    bytes5 el1;
    uint72 el2;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  address payable el0;
  function (bytes19) external   el1;
}
// ====
// ----
