
==== Source: su0.sol ====
error er0();
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35
}

==== Source: su1.sol ====
library L0 {
  function f0(function (int240, bytes17, int96) external   returns (bool, bytes30, int208) i0) public    returns(uint152[10] memory o0,bool o1)
  {
    int184 l0 = (int184(((~(((int88(154742504910672534362390527) * int88(0)) & int88(83006481927743984111124915)))) / int184(-8252809137160228128810539399075118207966156822629484876))) - int184(12259964326927110866866776217202473468949912977468817407));
    function (bytes22) external   returns (uint256, address, uint120) l1;
    function (int24) internal   returns (bytes30, uint80) l2;
    address[][] memory l3 = new address[][](7);
    address l4 = address(0x0000000000000000000000000000000000000005);
  }
  function f1() external    returns(int240 o0)
  {
  }
  error er1(uint128 ep0);
}
using L0 for function (int240, bytes17, int96) external   returns (bool, bytes30, int208);
using L0 for function (int240, bytes17, int96) external   returns (bool, bytes30, int208);
contract C0 {
  using L0 for *;
  uint256   s0 = uint256(88484843788171884553180896874082180911977940157872546019840522101276397829036);
  address   s1;
  bytes30  public s2;
  bytes22 immutable  s3 = bytes22(0x00000000000000000000000000000000000000000000);
  constructor(address i0,bytes30 i1) payable  {
    s1 = (true ? address(this) : address(this));
    s2 &= bytes30(0x472330e4399679588acdf5c95ae408bfdaa8b39d0683fca5c92837c99e7c);
    unchecked {
      bytes30  l0 = s2;
      bytes30  l1 = l0;
      assert(l1 == s2);
      bytes22  l2 = s3;
      bytes22  l3 = l2;
      assert(l3 == s3);
      (s1) = (address(this));
      assert(s1 == address(this));
      address  l4 = s1;
      address  l5 = l4;
      assert(l5 == s1);
      while (true)
      {
      }
    }
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  using L0 for *;
}
pragma solidity >= 0.0.0;
library L1 {
  function f2() public    returns(address payable o0)
  {
    function (bytes14, address) external   returns (address) l0;
  }
}
// ====
// ----
