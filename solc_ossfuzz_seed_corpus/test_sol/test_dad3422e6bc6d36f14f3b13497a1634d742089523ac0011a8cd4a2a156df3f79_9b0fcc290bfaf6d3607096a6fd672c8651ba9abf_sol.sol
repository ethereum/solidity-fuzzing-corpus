
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(int56 i0,bytes memory i1) external    returns(bytes3 o0)
  {
    int8 l0 = ((-(((int8((int8(0) / int8(-63))) ^ int8(127)) * int8(0)))) ** uint176(uint176(95780971304118053647396689196894323976171195136475135)));
  }
  type T0 is address payable;
  event ev0(uint168  ep0, uint256  ep1);
}
contract C0 {
  struct St0 {
    uint208 el0;
    function () external   returns (bytes memory) el1;
    int208 el2;
  }
  function f1() external virtual   returns(function (int120) external   returns (uint64) o0)
  {
    int72 l0 = (((int72((((int72(0) & int72(382439787758051810731)) | int72(2361183241434822606847)) / int72(0))) % int72(-1562441297095724286781)) + int72(0)) * int72(2361183241434822606847));
    try this.f1() returns (function (int120) external   returns (uint64) l1)
    {
      do
      {
        (uint64 l2) = l1(int80(604462909807314587353087));
      }
      while (true);
      bytes6 l3 = bytes6(0x000000000000);
      address payable l4 = payable(address(this));
    }
    catch
    {
      bool l5 = false;
      L0.T0 l6 = (true ? L0.T0.wrap(payable(address(0x0000000000000000000000000000000000000002))) : L0.T0.wrap(payable(address(0x0000000000000000000000000000000000000008))));
    }
    return (o0);
  }
  mapping(address => string)   s0;
  constructor()   {
    s0[address(this)] = string.concat(string("8668f9e5567e9d462e685e62506d8fb374607244227d6b01b13e44cd199c714264ac2d7ab76599158e"));
    unchecked {
    }
  }
  using L0 for *;
}
using L0 for int56;
// ====
// ----
