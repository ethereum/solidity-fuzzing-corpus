==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
    function (uint96) internal   returns (function (int64[6] memory, bytes memory, bytes22) internal   returns (bool), uint8) l0;
    (bool l1, bytes memory l2) = payable(this).call{value: 0}("");
  }
  address payable   s0;
  bytes2   s1;
  mapping(bytes29 => bool)   s2;
  uint64   s3 = uint64(13513161881443923970);
  constructor(address payable i0,bytes2 i1)   {
    s0 = payable(address(this));
    s1 = bytes2(0x31e9);
    s2[bytes29(0xb11dab08f9ad5897590b0de829dc0528a2de5ce6e2b76583f0c7992ec4)] = false;
    {
    }
  }
}

==== Source: su1.sol ====
type T0 is uint232;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C1 {
  mapping(address => address)  public s4;
  mapping(uint112 => T0)  public s5;
  constructor()   {
    s4[address(this)] = address(this);
    s5[((((uint112(0) >> uint256((uint256(0) | uint256(26990818462283784252695032369067201863137054035165987764939537796200496732308)))) % uint112(2234798196889679019288086102059757)) ^ uint112(0)) % uint112(0))] = (~((T0(((T0.wrap(uint232(0)) * T0.wrap(uint232(0))) / T0.wrap(uint232(6901746346790563787434755862277025452451108972170386555162524223799295)))) & T0.wrap(uint232(4776286227651432685982051133408153570030548361502690116378929653340669)))));
    {
    }
  }
}
T0 constant cons0 = T0.wrap(6901746346790563787434755862277025452451108972170386555162524223799295);
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:86-210): Unused local variable.
// Warning 2072: (su0.sol:217-224): Unused local variable.
// Warning 2072: (su0.sol:226-241): Unused local variable.
// Warning 5667: (su0.sol:415-433): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:434-443): Unused function parameter. Remove or comment out the variable name to silence this warning.
