
==== Source: su0.sol ====
struct St0 {
  bool[5] el0;
  uint136 el1;
}
contract C0 {
  uint248   s0 = uint248(0);
  bytes10   s1 = bytes10(0x00000000000000000000);
  type T0 is address payable;
  fallback() external virtual  
  {
    for(    int8 l0 = (int8(127) + int8(((int8(int232(3450873173395281893717377931138512726225554486085193277581262111899647)) + int8(127)) / int8(0))));
false;
(false f1 /*suffix expr*/ | int176(((((int176(-29987240567196312654964677507674917816880055029394158) | int176(47890485652059026823698344598447161988085597568237567)) + int176(47890485652059026823698344598447161988085597568237567)) % int176(0)) / int176(47890485652059026823698344598447161988085597568237567)))))
    {
      continue;
    }
  }
  function f2(bytes10 i0) public virtual  payable  returns(string memory o0)  {
  }
}
pragma solidity >= 0.0.0;
function f1(bool i0) pure suffix  returns(int176 o0)
{
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
function f3(uint16 i0)    pure suffix returns(bool o0){
}
struct St1 {
  C0.T0 el0;
  St0[] el1;
}
// ====
// ----
