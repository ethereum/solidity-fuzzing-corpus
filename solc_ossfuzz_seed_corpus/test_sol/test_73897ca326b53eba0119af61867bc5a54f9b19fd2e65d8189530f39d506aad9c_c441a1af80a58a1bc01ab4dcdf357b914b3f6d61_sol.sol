==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  uint184 el0;
  bytes19 el1;
  bool el2;
  bool el3;
}
library L0 {
  function f0(bool i0,bool i1,address i2) private    returns(function (function (function (address) external   returns (int248), St0 memory) external   returns (bytes4, bytes memory), address payable) external   returns (bytes27) o0)
  {
    bytes18 l0 = (false ? ((true ? (int136(-9102098172389535868997700225375530529418) < int136(-9537424043535150856804449141920976781654)) : true) ? bytes18(0x80d3570d343ed99e9ec3812ddc0b33122c4c) : bytes18(0x22cd6789a66937b444a70c311853e19cbd8e)) : bytes18(0xe9f61dfe1d46751da5b3941dbb9df62d3a3a));
  }
}
using L0 for bool;
pragma solidity >= 0.0.0;
using L0 for bool;

==== Source: su1.sol ====
contract C0 {
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000000000000000000000000000a4affc14f89aa7"));
  }
  function f2() public    returns(bool o0)
  {
    int144 l0 = (~((((((int144(11150372599265311570767859136324180752990207) & int144(11150372599265311570767859136324180752990207)) * int144(0)) ^ int144(0)) & int144(1402814350095355630185243612763591448529659)) % int144(0))));
    bytes7 l1 = bytes7(0xae8a342fff23d7);
  }
  bytes4   s0;
  bool   s1;
  bool  public s2 = false;
  constructor(bytes4 i0,bool i1)   {
    s0 &= bytes4(0x00000000);
    s1 = false;
    unchecked {
      bytes4  l0 = s0;
      bytes4  l1 = l0;
      assert(l1 == s0);
      {
        {
          (bool l2, bytes memory l3) = address(this).call(bytes("8284fcd318a4fffa2dfdd94da66cbfbfdc6a0b07c6c3f81c1b0473a027000000"));
          bool  l4 = s1;
          bool  l5 = l4;
          assert(l5 == s1);
          bool  l6 = s2;
          bool  l7 = l6;
          assert(l7 == s2);
        }
        bool  l8 = s1;
        bool  l9 = l8;
        assert(l9 == s1);
        bool  l10 = s2;
        bool  l11 = l10;
        assert(l11 == s2);
        bytes4  l12 = s0;
        bytes4  l13 = l12;
        assert(l13 == s0);
        (s1, s2) = (false, false);
        assert(s1 == false);
        assert(s2 == false);
      }
      bool  l14 = s1;
      bool  l15 = l14;
      assert(l15 == s1);
      (s2) = ((false ? (true ? ((false ? false : false) ? false : false) : false) : true));
      assert(s2 == (false ? (true ? ((false ? false : false) ? false : false) : false) : true));
    }
  }
  struct St1 {
    function () external   el0;
    int168 el1;
    bool el2;
  }
}
struct St2 {
  bytes14 el0;
  address el1;
  int24 el2;
  mapping(address => bytes2) el3;
}
struct St3 {
  function () external   returns (bool) el0;
  string el1;
}
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su0.sol:96-103): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:104-111): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:112-122): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:143-314): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:324-334): Unused local variable.
// Warning 2072: (su1.sol:55-62): Unused local variable.
// Warning 2072: (su1.sol:64-79): Unused local variable.
// Warning 5667: (su1.sol:220-227): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:237-246): Unused local variable.
// Warning 2072: (su1.sol:467-476): Unused local variable.
// Warning 5667: (su1.sol:578-587): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:588-595): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:762-769): Unused local variable.
// Warning 2072: (su1.sol:771-786): Unused local variable.
// Warning 2018: (su0.sol:84-623): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:188-508): Function state mutability can be restricted to pure
