
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  bool el0;
  address payable el1;
}
contract C0 {
  fallback() external   
  {
    string storage l0;
    int144 l1 = (((address(this) == address(this)) ? (int144(11150372599265311570767859136324180752990207) | int144(11150372599265311570767859136324180752990207)) : int144(11150372599265311570767859136324180752990207)) % int144(11150372599265311570767859136324180752990207));
    unchecked {
      int64 l2 = int64(0);
      (l1) = ((((((int40(-467416762143) ** uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | int40(549755813887)) - int144(11150372599265311570767859136324180752990207)) % int144(11150372599265311570767859136324180752990207)) % int144(11150372599265311570767859136324180752990207)));
      assert(l1 == (((((int40(-467416762143) ** uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | int40(549755813887)) - int144(11150372599265311570767859136324180752990207)) % int144(11150372599265311570767859136324180752990207)) % int144(11150372599265311570767859136324180752990207)));
    }
  }
  St0   s0;

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}  address payable   s1 = payable(address(this));
}
pragma solidity >= 0.0.0;
// ====
// ----
