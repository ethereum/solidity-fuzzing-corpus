
==== Source: su0.sol ====
function f0(string memory i0,bytes13 i1)      returns(uint128 o0){
  do
  {
    o0 %= (((((~((uint128(340282366920938463463374607431768211455) << uint48(uint48(0))))) & uint128(340282366920938463463374607431768211455)) & uint128(340282366920938463463374607431768211455)) % uint128(238644026497819425708340357493689654500)) >> uint104(uint104(20282409603651670423947251286015)));
    break;
  }
  while (true);
}
pragma solidity >= 0.0.0;
function f1(bool i0,function (address payable) external   returns (bytes16) i1,int192[1] memory i2)      returns(int48 o0,address o1){
  if (i2.length == ((uint152((0xB17367c0F1Ebb323c7759DAF6DeCEc133D2209c2 f2 /*suffix expr*/ / uint152((uint152(4500335736533106512700548543726513797557257107) / uint152(5708990770823839524233143877797980545530986495))))) & uint152(5708990770823839524233143877797980545530986495)) ** uint176(uint176(95780971304118053647396689196894323976171195136475135))))
  {
    while (false)
    {
      return ((int48(0) + (((int48(0) * int48(39622767811695)) ** uint104(uint104(18461274536123136181794115834960))) ^ int48(140737488355327))), address(0x0000000000000000000000000000000000000003));
    }
  }
  else if (i2.length != uint256(((uint256(48842630780860527952036319002084035232451431095059155671619801164395807204041) % uint256(0)) / (uint256(79278840316519342803934310729724208346040826698977978301434717250824968501313) ^ uint256(0)))))
  {
    o1 = address(0x0000000000000000000000000000000000000008);
    assert(o1 == address(0x0000000000000000000000000000000000000008));
    while (false)
    {
      continue;
    }
  }
  return (int48(0), address(0x0000000000000000000000000000000000000006));
}
function f2(address i0) pure suffix  returns(uint152 o0)
{
  (uint128 l0) = f0({i0: string("This is a really long string that must ideally be random but is currently hard coded"), i1: bytes13(0x00000000000000000000000000)});
}

==== Source: su1.sol ====
type T0 is bytes5;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;
function f3()      returns(uint96 o0,T0 o1,function (address, T0[] memory, bool) external  [] memory o2){
  do
  {
    if ((134568668155271 f4 /*suffix expr*/ ? true : true))
    {
    }
    else
    {
      if (true)
      {
        require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
        if (true)
        {
          continue;
        }
        else if (false)
        {
          if ((((bytes2(0xffff) ^ bytes2(0xa637)) ^ bytes3(0xffffff)) != bytes22(0x00000000000000000000000000000000000000000000)))
          {
            if (false)
            {
              break;
            }
            else
            {
              break;
            }
          }
        }
      }
    }
  }
  while (false);
}
function f4(int48 i0) pure suffix  returns(bool o0)
{
  o0 = false;
  assert(o0 == false);
  return (true);
}
// ====
// ----
