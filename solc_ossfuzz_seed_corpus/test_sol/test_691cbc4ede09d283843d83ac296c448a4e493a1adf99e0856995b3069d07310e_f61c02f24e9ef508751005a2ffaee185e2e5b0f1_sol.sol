
==== Source: su0.sol ====
function f0(bool i0)      returns(int152 o0,function () external   returns (uint104, int256) o1){
  if (i0)
  {
    try o1() returns (uint104 l0, int256 l1)
    {
      for(uint solinit0 = 0; solinit0 < (uint256(66366633854887134879477486017767630680202454209258343482953141246483488983042) % 11); solinit0++)
      {
        break;
      }
    }
    catch
    {
      if (i0)
      {
      }
      try o1() returns (uint104 l2, int256 l3)
      {
        try o1() returns (uint104 l4, int256 l5)
        {
        }
        catch
        {
          try o1() returns (uint104 l6, int256 l7)
          {
          }
          catch
          {
            if (i0)
            {
              true;
              if (i0)
              {
                try o1() returns (uint104 l8, int256 l9)
                {
                  while (false)
                  {
                    delete o1;
                  }
                }
                catch
                {
                }
                catch Error(string memory l10)
                {
                }
              }
              else if (i0)
              {
              }
            }
            else
            {
            }
          }
          catch Error(string memory l11)
          {
          }
        }
        catch Error(string memory l12)
        {
        }
      }
      catch
      {
      }
    }
    catch Error(string memory l13)
    {
    }
    catch Panic(uint256 l14)
    {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
type T0 is bytes22;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C0 {
  receive() external   payable
  {
    while (true)
    {
      for(uint solinit1 = 0; solinit1 < ((((((uint256(0) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(0)) << uint80(uint80(0))) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit1++)
      {
        continue;
      }
      if (false)
      {
        bytes25 l0 = bytes8(0xffffffffffffffff);
        break;
      }
      if (false)
      {
        break;
      }
      else if (true)
      {
        return;
      }
    }
  }
  event ev0();
  T0 public constant cons0 = T0.wrap(bytes22(0x00000000000000000000000000000000000000000000));
  type T1 is int224;
  uint224   s0;
  C0.T1   s1;
  bytes7   s2 = bytes7(0x00000000000000);
  constructor(uint224 i0,C0.T1 i1)   {
    s0 = uint224(0);
    s1 = C0.T1.wrap(int224(13479973333575319897333507543509815336818572211270286240551805124607));
    unchecked {
    }
  }
}
struct St0 {
  int176 el0;
  bytes3 el1;
  mapping(address => address) el2;
  bytes4 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
