
==== Source: su0.sol ====
struct St0 {
  bytes20 el0;
  bool el1;
  bytes12 el2;
}
struct St1 {
  mapping(bytes3 => bytes15) el0;
  function () external   returns (address) el1;
  string el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  bytes20  public s0 = bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));
  St1   s1;
  int232  public s2 = int232(3206200919380517599387140185226358753413134720151210607841299650110017);
  uint136  public s3;
  constructor(uint136 i0) payable  {
    s3 %= ((uint136(83575828056543067140901872173299497167100) >> uint224(uint224(0))) % ((uint136(44860094588939420449859021452562053541848) - uint136(70272070591608880820074546779845924002387)) | uint136(0)));
    {
    }
  }
  function f0() public virtual  payable   {
    return;
  }
  function f1(int232 i0) public virtual     {
    if (i0 <= int232((uint232(0) >> uint16(uint16(0)))))
    {
    }
    else
    {
    }
    (bool l0, bytes memory l1) = address(this).call((true ? bytes("5a0d9e0000000000000000000000000000") : bytes("ffffffffffffffffffffffffffffffffffffff043b2515a94e")));
  }
  function f2() internal     returns(bool[8][10] memory o0)  {
    delete o0[((uint256(0) ** uint208(((uint136(36223466109651237182188331525188190845207) % uint136(0)) % uint208(212923301146240544264177322659067195151579636065636568590897335)))) | uint256(0))];
  }
}

==== Source: su1.sol ====
struct St2 {
  function (int136) external   returns (string memory, int104) el0;
  mapping(int16 => bytes22) el1;
}
contract C1 {
  function f3(uint56 i0,int152 i1) public virtual  payable  returns(bool o0,address o1,int80 o2)  {
    o2 -= (int80(604462909807314587353087) & int80(-584527869508806655960558));
  }
  function f4() external virtual     {
    do
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("b387bd05ae5f540fc4450000000000000000000000000000000000000000000000"));
      if ((((~(bytes6(0xffffffffffff))) | (bytes6(0xffffffffffff) ^ bytes6(0xffffffffffff))) > bytes6(0x000000000000)))
      {
        (l1) = ((((uint16(0) + uint16(12477)) < (uint16(0) << uint48(uint48(0)))) ? bytes("3f76a827cb4114000000000000000000") : bytes("0000000000000000000000000000000000")));
        assert(keccak256(bytes(l1)) == keccak256(bytes((((uint16(0) + uint16(12477)) < (uint16(0) << uint48(uint48(0)))) ? bytes("3f76a827cb4114000000000000000000") : bytes("0000000000000000000000000000000000")))));
        try this.f4()
        {
          if (false)
          {
            return;
          }
        }
        catch
        {
          continue;
        }
      }
      else if (true)
      {
        continue;
      }
    }
    while (false);
  }
  address public constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
  bytes  public s4 = bytes("00000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  int168   s5 = int168(0);
  address   s6 = address(this);
}
pragma solidity >= 0.0.0;
// ====
// ----
