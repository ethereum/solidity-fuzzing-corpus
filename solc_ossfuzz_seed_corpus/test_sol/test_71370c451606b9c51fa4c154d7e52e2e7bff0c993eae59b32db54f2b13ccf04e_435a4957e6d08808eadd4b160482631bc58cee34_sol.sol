
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(bytes1 i0,function (int224) external   returns (bytes14) i1,bytes6 i2)      returns(uint88 o0,string memory o1){
  o1 = ((false == true) ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded"));
  assert(keccak256(bytes(o1)) == keccak256(bytes(((false == true) ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded")))));
  if (false)
  {
    if (false)
    {
      (int136(((-(int136(43556142965880123323311949751266331066367))) / int136(31276744619645785560819421443680864331728))) | (int136(43556142965880123323311949751266331066367) * int136(0)));
    }
    o1 = string("This is a really long string that must ideally be random but is currently hard coded");
    assert(keccak256(bytes(o1)) == keccak256(bytes(string("This is a really long string that must ideally be random but is currently hard coded"))));
    require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  else if ((((((bytes29(0x0000000000000000000000000000000000000000000000000000000000) & bytes29(0x0000000000000000000000000000000000000000000000000000000000)) ^ bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) | bytes29(0x0000000000000000000000000000000000000000000000000000000000)) | bytes29(0x33af352ef67a600a38290124672a800a12ede284dd28a071d5cabc96b6)) <= bytes29(0x0000000000000000000000000000000000000000000000000000000000)))
  {
    (bytes14 l0) = i1(int224(2138073379119442135202380146065026278134309946664583851344714850889));
  }
}
struct St0 {
  bool el0;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bool el0;
  int224 el1;
}
contract C0 {
  event ev0(St1 indexed ep0, int88 indexed ep1, int128 indexed ep2);
  function f1() internal virtual    returns(uint128 o0,bytes6 o1)  {
  }
  bytes21   s0;
  constructor(bytes21 i0)   {
    s0 |= bytes21(0xffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  receive() external   payable
  {
    if (false)
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    else if (false)
    {
    }
    for(    uint152 l0 = ((uint152(5534628090126837486166947695111405520637359144) ^ uint152(5247034775051404016538220239320175244530079952)) - uint152(5708990770823839524233143877797980545530986495));
;
(~((bytes30(0xeab9776185ea300f04acedf557f8ff8e5dc464415ba1811eba7c2085d7d0) ^ bytes30(0x000000000000000000000000000000000000000000000000000000000000)))))
    {
      continue;
    }
    if (true)
    {
      (uint128 l1, bytes6 l2) = f1();
      return;
    }
    else if (false)
    {
      while (false)
      {
        emit ev0(St1(true, int224(-8000364999375441689012524400555314921083661233893105683196652444217)), int88(154742504910672534362390527), (-((int128(170141183460469231731687303715884105727) + int96(17663122509111989004236703854)))));
      }
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72
  }
}
// ====
// ----
