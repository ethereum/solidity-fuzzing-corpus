
==== Source: su0.sol ====
contract C0 {
  function f0() public   payable   {
    if (false)
    {
      (bool l0, bytes memory l1) = address(this).call(msg.data);
      if (true)
      {
      }
      else
      {
      }
    }
  }
  error er0(string ep0, function (int208, uint128, uint184) external   returns (uint232, bytes18) ep1);
  mapping(bool => int184)   s0;
  uint88 immutable  s1 = uint88(186101512893810478191987621);
  constructor() payable  {
    s0[true] &= int184(12259964326927110866866776217202473468949912977468817407);
    unchecked {
      do
      {
        continue;
      }
      while ((((((~(uint56((uint56(0) / uint56(72057594037927935))))) <= uint56(72057594037927935)) ? bytes26(0x0000000000000000000000000000000000000000000000000000) : bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff)) & bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff)) < bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    }
  }
  type T0 is int56;
}
type T1 is bool;

using {



eq1 as ==, neq1 as !=

} for T1 global;






function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



pragma solidity >= 0.0.0;

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
error er1();
// ====
// ----
