
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(bytes memory i0) public    returns(bool o0,function (address) external   returns (int120) o1,int112[][4][] memory o2)
  {
    uint160 l0 = (((((~((-(int88(-1600875881546127402818453))))) >= int88(0)) ? uint160(224481844055737366688895618700604114575002256832) : uint160(1461501637330902918203684832716283019655932542975)) ^ uint160(1461501637330902918203684832716283019655932542975)) * uint160(1461501637330902918203684832716283019655932542975));
  }
}

==== Source: su1.sol ====
contract C0 {
  fallback() external   payable
  {
    function (int256, bytes15, bytes3) external   returns (string memory, function () external   returns (address payable, string memory, bytes memory)) l0;
  }
  receive() external   payable
  {
    assembly
    {
      returndatacopy(add(0x80, mod(sub(0, 0), 1024)), 0, mod(0, 1024))
      pop(42942995631687608121532129703322948685712861061532365435961198591974777688391)
    }
    payable(this).transfer(0);
  }
  uint128   s0;
  address payable   s1 = payable(address(this));
  constructor(uint128 i0) payable  {
    s0 /= uint128(0);
    unchecked {
      address payable  l0 = s1;
      address payable  l1 = l0;
      assert(l1 == s1);
      (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
    }
  }
}
error er0();
library L1 {
  function f3(bytes5 i0,address payable[][6][7][] memory i1,uint200[] memory i2) external    returns(address o0,uint184 o1)
  {
    bool l0 = true;
    delete i1[((address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))) < address(bytes20(bytes8(0xffffffffffffffff)))) ? uint256(0) : uint256(0))];
    string memory l1 = string.concat(string("ffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000"));
  }
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
