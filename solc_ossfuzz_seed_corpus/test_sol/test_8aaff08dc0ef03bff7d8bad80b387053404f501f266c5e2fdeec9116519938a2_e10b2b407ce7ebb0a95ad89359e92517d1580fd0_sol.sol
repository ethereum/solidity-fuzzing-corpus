
==== Source: su0.sol ====
contract C0 {
  bytes19   s0 = bytes19(0x00000000000000000000000000000000000000);
  address immutable  s1;
  bool  public s2;
  constructor(address i0,bool i1)   {
    s1 = (false ? address(this) : address(this));
    s2 = false;
    {
    }
  }
  receive() external   payable
  {
  }
  struct St0 {
    mapping(bool => int248)[] el0;
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  address payable[5]   s3;

	function compareMemoryAndStorage(address payable[5] memory v1, address payable[5] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  C0.St0   s4;
  address   s5 = address(this);
  constructor(bool i0,address payable[5] memory i1) payable C0(address(this), (int240(91155715979528349063310203838274323714095956342849256721111367474828757) != int240(-712529692857092349039584467589374785864055612352434568099066502028950880)))
  {
    s2 = (false ? false : true);
    s3 = i1;
    {
    }
  }
  bool public constant cons0 = false;
  event ev0(bool  ep0);
}
struct St1 {
  address el0;
}
contract C2 is C0 {
  struct St2 {
    function () external   returns (address payable, C1) el0;
    C0 el1;
  }
  bytes21   s6 = bytes21(0x254a4a6781d8a49a81de4baf45e3d8ccddd1ca4e0f);
  int88   s7;
  bytes6 immutable  s8;
  uint88[]   s9;

	function compareMemoryAndStorage(uint88[] memory v1, uint88[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(bool i0,int88 i1,bytes6 i2,uint88[] memory i3) payable C0(address(this), false)
  {
    s2 = (true ? (((uint8(246) ^ uint8(255)) + uint8(255)) == uint8(84)) : false);
    s7 *= ((~(((int88(0) + (int88(154742504910672534362390527) - int88(154742504910672534362390527))) * int88(13559725678422299426124949)))) - int88(26109442529095181868842612));
    s8 = bytes6(0x6bacf38afcab);
    s9 = i3;
    {
    }
  }
  fallback() external   
  {
    s7 ^= int88(0);
  }

	function compareMemoryAndCalldata(uint88[] memory v1, uint88[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f2(uint88[] calldata i0) external virtual  payable  returns(function (uint40, uint256, bool) external   returns (bool, bool) o0,string memory o1)  {
    (s9[(((uint256(0) << uint168(uint168(374144419156711147060143317175368453031918731001855))) + uint256(28493806006376991255471334422869041042815177556228248967435021858007030558107)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]) = (uint88(309485009821345068724781055));
    assert(s9[(((uint256(0) << uint168(uint168(374144419156711147060143317175368453031918731001855))) + uint256(28493806006376991255471334422869041042815177556228248967435021858007030558107)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] == uint88(309485009821345068724781055));
    s9.pop();
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bool constant cons1 = true;
// ====
// ----
