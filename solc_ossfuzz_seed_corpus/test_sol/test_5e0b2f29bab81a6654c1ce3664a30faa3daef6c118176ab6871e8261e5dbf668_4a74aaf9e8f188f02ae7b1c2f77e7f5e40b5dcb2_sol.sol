
==== Source: su0.sol ====
contract C0 {
  modifier m0() 
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 6352242325761047007}("");
    _;
  }
  uint240  public s0;
  uint120  public s1 = uint120(1329227995784915872903807060280344575);
  int224   s2;
  constructor(uint240 i0,int224 i1)   {
    s0 >>= (((uint240(((~((uint240(122529764616564769198533405949270065512914939415888538964409141171683909) + uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)))) / uint240(475128131278320449529789330476111440037825078663177312356490395496091406))) | uint240(0)) ^ uint240(0)) & uint240(1766847064778384329583297500742918515827483896875618958121606201292619775));
    s2 += (-(int224(13479973333575319897333507543509815336818572211270286240551805124607)));
    unchecked {
      int224  l0 = s2;
      int224  l1 = l0;
      assert(l1 == s2);
      uint120  l2 = s1;
      uint120  l3 = l2;
      assert(l3 == s1);
      int224  l4 = s2;
      int224  l5 = l4;
      assert(l5 == s2);
    }
  }
  receive() external virtual  payable
  {
    uint240  l0 = s0;
    uint240  l1 = l0;
    assert(l1 == s0);
    uint120  l2 = s1;
    uint120  l3 = l2;
    assert(l3 == s1);
  }
}
pragma solidity >= 0.0.0;
library L0 {
  event ev0(address payable[4][][][6][4][10]  ep0, address payable[]  ep1, function (bool) external   returns (address, bool, uint216) indexed ep2, address payable  ep3);
  function f1(function (int32) external   returns (address payable) i0,uint128 i1) public    returns(function () external   returns (int72, bool) o0,address payable o1,int104 o2)
  {
  }
  modifier m1(bytes11 i0) 
  {
    _;
  }
}

==== Source: su1.sol ====
library L1 {
  type T0 is bytes23;
}
pragma solidity >= 0.0.0;
// ====
// ----
