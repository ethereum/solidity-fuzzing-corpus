
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(function (int128, uint136, address[][1][][] memory) external   returns (int24) i0) external    returns(address payable[][10][8][6][][3] memory o0)
  {
    (o0, o0[((~((((uint256(0) - uint256(0)) ** uint136(uint136(87112285931760246646623899502532662132735))) + uint256(37264789017109516778953597295686799395012527697911231009581220518203476464191)))) - uint256(0))]) = ([new address payable[][10][8][6][](2), new address payable[][10][8][6][](2), new address payable[][10][8][6][](2)], new address payable[][10][8][6][](2));
  }
  function f1() external    returns(bytes27 o0,bool o1)
  {
    assembly
    {
      switch exp(o0, 56535586961362294718949132998040025030940186125941068904820834891907001872482)
      case 0
      {
        o1 := o0
        calldatacopy(add(0x80, mod(102670828738699468572715226446622801226895041476895065795507833879258481396407, 1024)), 0, mod(o0, 1024))
      }
      case 28931785016727857204269092810937551872374524978361492547360041963018009324250
      {
        let al0 := signextend(smod(0, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 35551251233071547732500719450729783231821521172784795162452719222245216806676)
      }
      return(add(0x80, mod(102670828738699468572715226446622801226895041476895065795507833879258481396407, 1024)), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
    }
    uint168 l0 = (uint168(198931927013848312906976644398841509255644623368098) + uint168(374144419156711147060143317175368453031918731001855));
    assert(((uint72(3537721267023424700155) - ((uint72(0) * uint72(4722366482869645213695)) + uint72(0))) == uint72(4722366482869645213695)));
    uint216 l1 = (uint216(105312291668557186697918027683670432318895095400549111254310977535) + (((uint216(2274577023901971001659170358159390168846813132486473997254590917) % uint216(95988773954797099841708489473760768980104651247633664968359522628)) ^ uint216(0)) & uint216(40300468282805780501774721295103379635899161875131120909118527904)));
  }
  event ev0() anonymous;
}
using L0 for function (int128, uint136, address[][1][][] memory) external   returns (int24);

==== Source: su1.sol ====
contract C0 {
  uint136  public s0;
  int240  public s1;
  constructor(uint136 i0,int240 i1)   {
    s0 ^= uint136(0);
    s1 -= (((i1 *= (int240(-108081200446363535759711257761251670221552271355508312750529361996543397) % (~(int240(0))))) | ((int240((int240(883423532389192164791648750371459257913741948437809479060803100646309887) / int240(391860724949871984057155670176043988967160493522630280368171530267470420))) * int240(0)) & int240(0))) + int240(883423532389192164791648750371459257913741948437809479060803100646309887));
    unchecked {
      (s0) = ((((((~((~(uint136(0))))) << uint64(uint64(0))) ^ uint136(0)) + uint136(67357888789039993236390618261795170244681)) & uint136(87112285931760246646623899502532662132735)));
      assert(s0 == (((((~((~(uint136(0))))) << uint64(uint64(0))) ^ uint136(0)) + uint136(67357888789039993236390618261795170244681)) & uint136(87112285931760246646623899502532662132735)));
      int240  l0 = s1;
      int240  l1 = l0;
      assert(l1 == s1);
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
