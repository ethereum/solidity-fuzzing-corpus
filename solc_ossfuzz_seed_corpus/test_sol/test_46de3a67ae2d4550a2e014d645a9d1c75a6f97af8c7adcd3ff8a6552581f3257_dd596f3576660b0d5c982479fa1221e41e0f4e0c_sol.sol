
==== Source: su0.sol ====
struct St0 {
  bytes4 el0;
  int168 el1;
}
struct St1 {
  uint24 el0;
}
function f0(St1 memory i0)     {
  for(uint solinit0 = 0; solinit0 < (((((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % uint256(0)) * uint256(0)) + uint256(36808506328397186984978729655842359549656744385858238307438779665977541409540)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(0)) * uint256(43978983416831832764083169697398636864743112179640371548337536292491812653126)) % 11); solinit0++)
  {
    break;
  }
  0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is uint104;
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10
  }
  mapping(int192 => bytes[5])  public s0;
  int120   s1 = int120(380219366828573364025479371282996011);
  constructor()   {
    unchecked {
    }
  }
  type T1 is uint32;
  function f1(bytes11 i0,uint216 i1,uint112 i2) internal virtual     {
    return;
  }
}
function f2(uint8 i0)      returns(int136[] memory o0,C0.EN0 o1,address payable o2){
  return (new int136[](1), C0.EN0(uint8(1)), payable(address(0x0000000000000000000000000000000000000003)));
}
type T2 is address;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,

eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }





function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) | bytes20(T2.unwrap(y)))); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) & bytes20(T2.unwrap(y)))); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(address(bytes20(T2.unwrap(x)) ^ bytes20(T2.unwrap(y)))); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(address(~bytes20(T2.unwrap(x)))); }






function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



// ====
// ----
