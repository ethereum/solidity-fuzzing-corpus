
==== Source: su0.sol ====
contract C0 {
  event ev0();
  bytes17 public constant cons0 = bytes17(0xffffffffffffffffffffffffffffffffff);
  type T0 is uint144;
  fallback() external   
  {
    if (false)
    {
      if (true)
      {
      }
      for(      bool l0 = false;
;
)
      {
        continue;
      }
    }
    return;
  }
  function f1() public virtual  payable  returns(bool o0)  {
    emit ev0();
  }
  uint248   s0;
  mapping(address => mapping(address => int240))  public s1;
  uint40   s2 = uint40(1099511627775);
  constructor(uint248 i0)   {
    s0 *= (uint248(452312848583266388373324160190187140051835877600158453279131187530910662655) | ((uint248((uint248(295500367436026721271922427277613100091897224772439524745655103540940947397) / uint248(0))) >> uint32(uint32(1709593265))) & uint248(0)));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  int40 el0;
  C0.T0 el1;
  address el2;
}
struct St1 {
  St0 el0;
  bytes15 el1;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St2 {
  function (address, int40, bool) external   returns (address payable, uint200, address) el0;
  uint72 el1;
  bool el2;
  address el3;
}
function f2(function () external   i0,uint32 i1)      returns(string memory o0,St2 memory o1,function () external   returns (string memory, bytes21, bool) o2){
  try i0()
  {
    if (i1 >= uint32(0))
    {
    }
    else if (i1 < (((uint32(0) | ((uint32(2352011352) | uint32(4294967295)) ^ uint32(3245620366))) - uint32(0)) * uint32(4294967295)))
    {
      if ((false ? false : (((true ? int216(0) : int216(52656145834278593348959013841835216159447547700274555627155488767)) % int216(47529453017995660746487381320515975027978617723406528822270668204)) != int216(47156756052600563887442981814220642441588316587008200254412215929))))
      {
        if (true)
        {
        }
        (o1.el3) = (address(0x0000000000000000000000000000000000000007));
        assert(o1.el3 == address(0x0000000000000000000000000000000000000007));
      }
      else
      {
        try i0()
        {
          o0 = string("This is a really long string that must ideally be random but is currently hard coded");
          assert(keccak256(bytes(o0)) == keccak256(bytes(string("This is a really long string that must ideally be random but is currently hard coded"))));
          try o2() returns (string memory l0, bytes21 l1, bool l2)
          {
            for(            int64 l3 = ((int64(9223372036854775807) % (((~(int64(7012877955266233507))) % int64(772355018626863798)) % int64(9223372036854775807))) % int64(-1571927268430140556));
;
)
            {
              assert((int136(0) < ((((int136(0) & int136(43556142965880123323311949751266331066367)) & int136(0)) | int136(43556142965880123323311949751266331066367)) % int136(0))));
              for(uint solinit0 = 0; solinit0 < (uint256((uint256(0) / (hex"c3e91a8f56519cd1a1b12931a639a6f7a0f2dbd833bc628ee5327034972b" f3 /*suffix expr*/ & address(0x0000000000000000000000000000000000000006).balance))) % 11); solinit0++)
              {
                continue;
              }
              break;
            }
          }
          catch
          {
            while (true)
            {
              if (true)
              {
                break;
              }
            }
            revert(string("This is a really long string that must ideally be random but is currently hard coded"));
          }
        }
        catch
        {
        }
        catch Error(string memory l4)
        {
        }
      }
    }
  }
  catch
  {
  }
  catch Error(string memory l5)
  {
  }
}
function f3(bytes30 i0) pure suffix  returns(uint256 o0)
{
}
// ====
// ----
