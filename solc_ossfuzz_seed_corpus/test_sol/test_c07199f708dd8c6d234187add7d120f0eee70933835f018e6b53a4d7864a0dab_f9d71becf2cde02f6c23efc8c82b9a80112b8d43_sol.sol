
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  address payable   s0;
  bytes30 immutable public s1 = bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  bytes16  public s2 = bytes16(0x00000000000000000000000000000000);
  address   s3;
  constructor(address payable i0,address i1)   {
    s0 = (false ? payable(address(this)) : payable(address(this)));
    s3 = address(bytes20(address(0x0000000000000000000000000000000000000000)));
    {
    }
  }
  fallback() external   
  {
  }
  function f1(address payable i0,bytes30 i1) public    returns(uint112[][8][] memory o0)
  {
    bytes30  l0 = s1;
    bytes30  l1 = l0;
    assert(l1 == s1);
    address payable  l2 = s0;
    address payable  l3 = l2;
    assert(l3 == s0);
  }
  event ev0(int8  ep0, bool  ep1);
}

==== Source: su1.sol ====
library L0 {
  function f2(bytes32 i0) internal    returns(uint56 o0)
  {
  }
  function f3(bytes memory i0) external   
  {
    function (uint32) internal   returns (bytes26, int256) l0;
    unchecked {
      for(;
;
)
      {
        uint48 l1 = uint16(uint256(104888535018584176458703204959502670103005120324128810606030514500110613360216));
        bool l2 = true;
        address payable l3 = payable(address(0x0000000000000000000000000000000000000002));
      }
      int240 l4 = int240(883423532389192164791648750371459257913741948437809479060803100646309887);
    }
    return;
  }
}
using L0 for bytes32;
using L0 for bytes32;
pragma solidity >= 0.0.0;
uint208 constant cons0 = 192523809380692441202669316147734036400244814862713968283057304;
// ====
// ----
