
==== Source: su0.sol ====
contract C0 {
  fallback() external   payable
  {
    {
      bool l0 = false;
    }
    address payable l1 = payable(address(this));
    int208 l2 = int208(0);
    (l2) = (int208(3989940820642130579524042097542330201303806112468534273207579));
    assert(l2 == int208(3989940820642130579524042097542330201303806112468534273207579));
  }
  receive() external virtual  payable
  {
    address payable l0 = payable(address(bytes20(address(0x0000000000000000000000000000000000000000))));
    int184 l1 = (int184(int152((int152(2854495385411919762116571938898990272765493247) / int152((int152((int152(2854495385411919762116571938898990272765493247) / int152(-326422610339427585281230064687204658678336701))) / int152(0)))))) * int184(12259964326927110866866776217202473468949912977468817407));
    return;
  }
  bool   s0 = true;
  address payable  public s1;
  int176[2]   s2;

	function compareMemoryAndStorage(int176[2] memory v1, int176[2] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  uint176  public s3;
  constructor(address payable i0,int176[2] memory i1,uint176 i2)   {
    s1 = payable(msg.sender);
    s2 = i1;
    s3 <<= uint176((int176(47890485652059026823698344598447161988085597568237567) * (~(int176((int176(0) / int176(-1727929352232148677555998123006844241945339883048784)))))));
    { }
  }
}
contract C1 {
  fallback() external   
  {
  }
  bool   s4 = false;
}
pragma solidity >= 0.0.0;
// ====
// ----
