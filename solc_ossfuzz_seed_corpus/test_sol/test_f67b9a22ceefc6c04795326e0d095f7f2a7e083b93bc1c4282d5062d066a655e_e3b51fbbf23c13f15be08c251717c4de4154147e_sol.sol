==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  uint192 el0;
  address el1;
  int144 el2;
  bytes el3;
}
contract C0 {
  mapping(uint32 => int72)   s0;
  address   s1 = address(this);
  constructor()   {
    s0[uint32(4294967295)] -= 0x0000000000000000000000000000000000000000 f0 /*suffix expr*/;
    unchecked {
      if (true)
      {
        if (false)
        {
        }
        if (false)
        {
          (s1, s1) = (false f1 /*suffix expr*/, address(this));
          assert(s1 == false f1 /*suffix expr*/);
          assert(s1 == address(this));
        }
      }
      else
      {
      }
    }
  }
  function f2() public     returns(int208 o0,uint40 o1)  {
    if (false)
    {
    }
  }
}
pragma solidity >= 0.0.0;
function f0(address i0) pure suffix  returns(int72 o0)
{
  0;
  if (i0 != address(0x0000000000000000000000000000000000000003))
  {
  }
  require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
  function (St0 memory) external   returns (function (uint40, bytes6, St0[] memory) external  [] memory, function (address payable, bool) external   returns (function (uint232, bool) external   returns (bool, int208), address, bytes23), bool) l0;
}
function f1(bool i0) pure suffix  returns(address o0)
{
  if (i0)
  {
  }
  else if (i0)
  {
    return (address(0x0000000000000000000000000000000000000008));
  }
}

==== Source: su1.sol ====
contract C1 {
  event ev0();
  function f3(int160 i0,int136 i1) external   payable  returns(function () external   o0,bytes memory o1)  {
  }
  bytes23   s2;
  bool immutable  s3;
  int256   s4;
  constructor(bytes23 i0,bool i1,int256 i2)   {
    s2 &= (bytes23(0x0000000000000000000000000000000000000000000000) | bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff));
    s3 = (hex"c9b8b87695568b14146ec34f" f4 /*suffix expr*/ < payable(address(this)));
    s4 = (((int256(41408683812128457543488883167050790627327055901808614795707062328612782623140) - (int256(0) | int256(0))) ^ int256(11558338570307930153367883997919148645385891403718885292298469712831516716872)) + int256(0));
    unchecked {
      if (i2 == ((int256(27492876629091621332832684922218820412400144560652086119220497010375729156056) * int256(16103328678101737344866752460017531419514444951200297943708182440397540357487)) & (int256((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) / int256(0))) + int256(0))))
      {
      }
      else
      {
        if (i1)
        {
          int256  l0 = s4;
          int256  l1 = l0;
          assert(l1 == s4);
        }
        else
        {
          payable(this).transfer(13060636327957104317);
        }
      }
    }
  }
  fallback() external   payable
  {
    return;
  }
}
pragma solidity >= 0.0.0;
function f4(bytes12 i0) pure suffix  returns(address payable o0)
{
}
// ----
// Warning 3628: (su1.sol:0-1336): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su0.sol:615-624): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:625-634): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:757-758): Statement has no effect.
// Warning 5667: (su0.sol:743-751): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:949-1192): Unused local variable.
// Warning 5667: (su1.sol:209-219): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:582-669): Function state mutability can be restricted to pure
