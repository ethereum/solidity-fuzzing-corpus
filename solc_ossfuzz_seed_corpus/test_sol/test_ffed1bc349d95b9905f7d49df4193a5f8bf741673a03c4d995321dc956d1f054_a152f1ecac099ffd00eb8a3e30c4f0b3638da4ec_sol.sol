
==== Source: su0.sol ====
function f0(uint152 i0,function (bool, function (function (bytes20, address payable[3] memory, bytes1) external   returns (address, int176)) external   returns (uint248, uint160), address payable) external   i1)      returns(bytes28 o0,int64 o1){
  return (bytes28(0xd926c78fa7a6f928ccd57b7e9775394b1701c5efff423ed35d9b35e4), (((false ? int64(-1540955752643969007) : int64(-2765095788337569760)) - int64(4470974114372971283)) * int64(9223372036854775807)));
}
contract C0 {
  bytes30[]   s0;

	function compareMemoryAndStorage(bytes30[] memory v1, bytes30[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  mapping(uint96 => int136)   s1;
  address payable[6]   s2 = [payable(address(0x0000000000000000000000000000000000000007)), payable(address(0x0000000000000000000000000000000000000005)), payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000005))];

	function compareMemoryAndStorage(address payable[6] memory v1, address payable[6] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int64   s3 = int64(9223372036854775807);
  constructor(bytes30[] memory i0)   {
    s0 = i0;
    s1[uint96(65364089088622161636721062632)] %= int136(((int136(42729712398338709080709359325988074337624) + (((true ? int136(0) : int136(43556142965880123323311949751266331066367)) * int136(32702017047847857238477953543873388623474)) % int136(0))) / int136(43556142965880123323311949751266331066367)));
    {
    }
  }
  function f1(uint112 i0) public virtual  payable   {
  }
}
contract C1 {
  function f2(int248 i0) public virtual  payable   {
    for(uint solinit0 = 0; solinit0 < ((uint256(0) ** uint32(uint32((((uint32(0) ** uint72(uint72(3869477800900662752303))) ^ uint32(0)) / uint32(0))))) % 11); solinit0++)
    {
      continue;
    }
  }
  mapping(bytes6 => uint32)[8]   s4;
  address payable  public s5 = payable(address(this));
  struct St0 {
    address el0;
    address el1;
    address payable el2;
    bytes27 el3;
  }
  function f3(address i0,address payable i1) private      {
    return;
  }
  function f4() public   payable   {
    for(;
false;
new bytes[](3))
    {
      continue;
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St1 {
  function (int40, int120) external   returns (address, function (address payable, bytes8, bytes10) external   returns (address, uint112, bool)) el0;
  uint224 el1;
  int168 el2;
}
error er0();
pragma solidity >= 0.0.0;
function f5(int64 i0)     {
  if (i0 >= int64(9223372036854775807))
  {
    return;
  }
  if (i0 < int64(((int64(5225394843752832038) ^ (int64((int64(9223372036854775807) / int64(5265510124109920544))) - int64(9223372036854775807))) / int64(-617087461956645954))))
  {
    address payable l0 = (true ? payable(address(0x0000000000000000000000000000000000000008)) : payable(address(bytes20(address(0x0d723cD561Cc15a43Ab6B3a1c8F495E8C64E6c05)))));
    revert er0();
  }
  else
  {
  }
}
// ====
// ----
