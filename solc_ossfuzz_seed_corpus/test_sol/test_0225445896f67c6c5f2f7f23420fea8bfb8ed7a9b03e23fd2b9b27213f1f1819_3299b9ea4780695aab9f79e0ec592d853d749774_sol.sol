
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 2093734161825684180}("");
  }

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f1(bytes calldata i0) external      {
    if (i0.length > (uint256((((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) << uint240(uint240(0))) ^ uint256(0)) / uint256(0))) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))
    {
      for(      int8 l0 = (int8(127) & int8(0));
(((uint224(26959946667150639794667015087019630673637144422540572481103610249215) | (uint224(uint88(0)) % uint224(26959946667150639794667015087019630673637144422540572481103610249215))) | uint224(10630002135152010524950468171245249447973917677950612141630076091932)) <= uint224(26959946667150639794667015087019630673637144422540572481103610249215));
)
      {
        break;
      }
      uint160 l1 = (((uint160(1461501637330902918203684832716283019655932542975) >> uint224(uint224((int224(0) + int224(-9966928574735405383575853810393258857799318232471888684370740562945))))) % uint160(0)) - uint160(1114797356357092100112691392112287244024966998632));
      bytes memory l2 = i0;
      assert(compareMemoryAndCalldata(l2, i0));
      if (i0.length != uint256((uint256(99094189044898544093497510994273717323366613085778871791851976940297502024896) / (~((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) << uint184(uint184(5109770246443953638684046383380829942967583116369868823))) & uint256(0)))))))
      {
      }
    }
    else
    {
      (bytes3(0xf0cc1e) ^ (~(bytes3(0xffffff))));
      while (((uint248(0) | uint248((uint248((int248(131432520259581261109649917231172737794948321394251987716701760175057429810) ^ int248(0))) / uint248(39452410690797682503650313923565230235228667736249703773491541662496292050)))) <= uint248(249637491555762649456486055536521033265957389130483578255772332883210629796)))
      {
        continue;
      }
    }
  }
  function f2(address payable i0) public     returns(address o0)  {
    return (address(this));
  }
  bytes5   s0;
  bytes20[]  public s1;

	function compareMemoryAndStorage(bytes20[] memory v1, bytes20[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  mapping(address => bytes1)  public s2;
  mapping(int128 => address)  public s3;
  constructor(bytes5 i0,bytes20[] memory i1) payable  {
    s0 |= bytes5(0x0412318b13);
    s1 = i1;
    s2[address(this)] ^= bytes1(0x3c);
    s3[int128(170141183460469231731687303715884105727)] = s3[int128(25825354242404665326102297165442068501)];
    unchecked {
    }
  }
  event ev0();
  receive() external virtual  payable
  {
    emit ev0();
    if (true)
    {
    }
  }
}
struct St0 {
  bytes el0;
  uint160 el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
address constant cons0 = 0x0000000000000000000000000000000000000000;
int104 constant cons1 = 3741518283128934285617360736259;
pragma solidity >= 0.0.0;
// ====
// ----
