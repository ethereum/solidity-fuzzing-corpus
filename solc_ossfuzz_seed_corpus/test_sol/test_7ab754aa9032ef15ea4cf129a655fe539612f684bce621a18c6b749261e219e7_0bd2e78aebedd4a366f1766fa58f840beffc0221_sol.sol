
==== Source: su0.sol ====
struct St0 {
  bytes19 el0;
  bytes1 el1;
  address el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
  }
  int48   s0;
  constructor(int48 i0) payable  {
    s0 |= int48(140737488355327);
    {
    }
  }
  function f1() internal      {
    do
    {
      while ((bytes17(0x0000000000000000000000000000000000) < bytes16(0x00000000000000000000000000000000)))
      {
        (s0) = (int48(0));
        assert(s0 == int48(0));
        do
        {
          return;
        }
        while (((((uint40(0) | uint40(uint80(923009691884968672810461))) % uint40(42120505713)) << uint40(uint40(1099511627775))) <= uint40(114130471157)));
        continue;
      }
    }
    while (true);
  }
  error er0(uint152 ep0, bytes10[] ep1);
  receive() external   payable
  {
    (bool l0) = payable(this).send(0);
    for(uint solinit0 = 0; solinit0 < ((uint256(110405626071440452840931550078233893771740750694619134997563798134921230077857) ** uint136((uint136(19946914447114262229615809253952848492659) >> uint216(uint216(95610934463362650824256056445108668538158304064829860866703117889))))) % 11); solinit0++)
    {
      if ((false ? true : (address(this) >= address(this))))
      {
        return;
      }
      require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
    }
  }
}

==== Source: su1.sol ====
struct St1 {
  function () external   returns (bool) el0;
  string el1;
  uint200 el2;
  bytes9 el3;
}
struct St2 {
  bytes28 el0;
  int136[1] el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
