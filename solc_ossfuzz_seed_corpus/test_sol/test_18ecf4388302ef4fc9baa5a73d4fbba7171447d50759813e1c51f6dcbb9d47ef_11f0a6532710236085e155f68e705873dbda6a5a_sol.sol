
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(function (bytes19, bytes15, uint88) external   returns (uint64, uint8, bool) i0) public virtual  payable  returns(bool[10] memory o0)  {
    if (true)
    {
      o0 = [true, true, true, false, true, true, true, true, false, true];
    }
    else
    {
      if (true)
      {
      }
      else if (false)
      {
        assert(o0[(((((~(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ** uint216(uint216(43560755332005543207849750589262051742885919131412595637605111541))) & uint256(7215374465798415324173492404078151025982422135507594834213555170290079372083)) ^ uint256(84208787946665150872992457951447918874900340776866156464554188479406834676503)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]);
      }
    }
  }
  fallback() external virtual  payable
  {
    return;
  }
  bool immutable  s0 = false;
  bool immutable public s1 = true;
  bytes10[9]  public s2 = [bytes10(0x00000000000000000000), bytes10(0xffffffffffffffffffff), bytes10(0x03230867f680df9f8905), bytes10(0x00000000000000000000), bytes10(0x2db8055409ffdf2c2635), bytes10(0x440d1cb8a687865938c5), bytes10(0xffffffffffffffffffff), bytes10(0x584f574cb26eaa526948), bytes10(0x73b473dbe4e7ece55de2)];

	function compareMemoryAndStorage(bytes10[9] memory v1, bytes10[9] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int24 immutable  s3 = int24(6449221);
  function f2() public      {
    for(    0;
;
)
    {
      continue;
    }
  }
}

==== Source: su1.sol ====
struct St0 {
  uint56 el0;
  uint176 el1;
}
struct St1 {
  bytes5 el0;
  function (St0 memory, bytes13[5] memory, bytes19) external   el1;
  St0 el2;
}
struct St2 {
  uint112[9] el0;
  uint200[] el1;
}
pragma solidity >= 0.0.0;
struct St3 {
  bytes32 el0;
}
// ====
// ----
