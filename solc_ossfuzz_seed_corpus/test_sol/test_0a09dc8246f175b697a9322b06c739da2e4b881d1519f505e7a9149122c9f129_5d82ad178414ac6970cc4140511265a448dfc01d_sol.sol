
==== Source: su0.sol ====
error er0();
contract C0 {
  mapping(bool => int80)  public s0;
  uint184  public s1 = uint184(24519928653854221733733552434404946937899825954937634815);
  int224   s2 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
  constructor()   {
    s0[true] &= (false ? (-(s0[true])) : int80(604462909807314587353087));
    {
      require((uint256((uint256((((address(this) == address(this)) ? uint256(78932884138656609517403018860398577380335944369953247964620793354927699206316) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(50534387679328726124186716825678801549840067172067689137910036310997524312327))) / uint256(56828677492170810583680320538713828737546765896616439124314610372699891999287))) <= uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)), string("ffffffffffffffffffffffffffffffffffffffffffffffffffb88b4f20a84a2111e875e98994e29a366a"));
    }
  }
}
pragma solidity >= 0.0.0;
function f0()    
{
  int200 l0 = int200(0);
}
contract C1 {
  address[]   s3;

	function compareMemoryAndStorage(address[] memory v1, address[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(address[] memory i0)   {
    s3 = i0;
    unchecked {
      revert er0();
    }
  }
}
// ====
// ----
