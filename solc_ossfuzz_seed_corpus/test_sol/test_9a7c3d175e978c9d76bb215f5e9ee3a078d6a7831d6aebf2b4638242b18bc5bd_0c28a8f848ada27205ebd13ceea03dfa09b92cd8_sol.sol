
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(bool[7] memory i0,bytes18 i1)      returns(int112 o0){
  if (i1 <= (~((bytes17(0xffffffffffffffffffffffffffffffffff) & bytes17(0xffffffffffffffffffffffffffffffffff)))))
  {
  }
  else
  {
    o0 %= (int112(2596148429267413814265248164610047) & (hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" f2 /*suffix expr*/ * (true ? int112(2596148429267413814265248164610047) : int112(-1669949771088543326626955375463051))));
    address payable l0 = payable(msg.sender);
  }
  return ((((int112(((~(int40(0))) - int40(549755813887))) % int112(0)) ^ int112(896967281880755943161281666317968)) - int112(0)));
}
function f1(bytes25 i0) pure suffix  returns(uint256 o0)
{
  if (i0 > bytes17(0x0000000000000000000000000000000000))
  {
    o0 *= hex"ffffffffffffffffffffffffffffffffffffffffffff" f3 /*suffix expr*/;
  }
  (o0) = ((((uint152(5708990770823839524233143877797980545530986495) + uint152(308961753436939884894727880372092794987749426)) & uint152(0)) + uint256(47330576826616399845771722822233000828709451703498142728468053954788338699886)));
  assert(o0 == (((uint152(5708990770823839524233143877797980545530986495) + uint152(308961753436939884894727880372092794987749426)) & uint152(0)) + uint256(47330576826616399845771722822233000828709451703498142728468053954788338699886)));
}
function f2(bytes31 i0) pure suffix  returns(int112 o0)
{
}
function f3(bytes22 i0) pure suffix  returns(uint152 o0)
{
  revert((((int24(3538342) != int24(8388607)) ? false : true) ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded")));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bool constant cons0 = false;
struct St0 {
  int248 el0;
  bytes29[2] el1;
}
contract C0 {
  receive() external virtual  payable
  {
    if (cons0)
    {
      assert(false);
    }
    else if (true)
    {
      return;
    }
  }
  mapping(address => address)  public s0;
  address payable   s1 = payable(address(this));
  constructor() payable  {
    s0[address(this)] = s0[address(this)];
    unchecked {
    }
  }
  function f5() internal     returns(int32 o0)  {
    require(cons0);
    do
    {
      St0[] storage l0;
      break;
    }
    while (false);
  }
}
// ====
// ----
