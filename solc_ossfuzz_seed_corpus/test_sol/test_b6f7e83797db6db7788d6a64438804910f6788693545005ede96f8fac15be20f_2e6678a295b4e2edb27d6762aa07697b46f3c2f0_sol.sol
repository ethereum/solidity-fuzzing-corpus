
==== Source: su0.sol ====
type T0 is bytes2;
function f0()     returns(uint200 o0)
{
}
T0 constant cons0 = T0.wrap(bytes2(0x0000));
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
int24 constant cons1 = ((((int24(-2720797) & int24(uint24(16777215))) ^ int24(5823897)) & int24(6882496)) & int24(0));
struct St0 {
  address payable el0;
  int56 el1;
  address el2;
  uint256 el3;
}
import "su0.sol";
library L0 {
  event ev0() anonymous;
  function f1() internal   
  {
    emit L0.ev0();
  }
  error er0(function () external   returns (St0 memory, St0[] memory, bytes13) ep0, bytes3 ep1);
  modifier m0(St0[2] memory i0) 
  {
    _;
    assembly
    {
      i0 := difficulty()
    }
  }
  address payable public constant cons2 = payable(address((bytes20(address(0x0000000000000000000000000000000000000000)) & (((!(true)) || false) ? bytes20(address(0x0000000000000000000000000000000000000000)) : bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))))));
  type T1 is uint192;
}
pragma solidity >= 0.0.0;
// ====
// ----
