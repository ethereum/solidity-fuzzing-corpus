
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    function (bool) external   returns (int24) l0;
    bool l1 = false;
  }
  uint120   s0 = uint120(1329227995784915872903807060280344575);
  bool  public s1;
  int104 immutable  s2;
  int168   s3 = int168(0);
  constructor(bool i0,int104 i1) payable  {
    s1 = false;
    s2 = int104((int104(10141204801825835211973625643007) / (((int88(154742504910672534362390527) * int104(0)) | int104(-7547342473737239040780685156056)) % int104(10141204801825835211973625643007))));
    unchecked {
      uint120  l0 = s0;
      uint120  l1 = l0;
      assert(l1 == s0);
      uint120  l2 = s0;
      uint120  l3 = l2;
      assert(l3 == s0);
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  address payable   s4 = payable(address(this));
  address payable  public s5 = payable(address(this));
  bool immutable  s6;
  constructor(bool i0,bool i1) payable C0(((true ? (~(bytes1(bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff)))) : bytes1(0xff)) == bytes1(0xff)), int104((int104((int104(0) / int104(((int104(0) * int104(0)) / int104(3358835892155026857807104674053))))) / int104(6470609500733707390327060726999))))
  {
    s1 = false;
    s6 = ((address(this) != address(this)) ? false : false);
    {
      bool  l0 = s1;
      bool  l1 = l0;
      assert(l1 == s1);
      bool  l2 = s6;
      bool  l3 = l2;
      assert(l3 == s6);
    }
  }
  fallback() external override  
  {
  }
}

==== Source: su1.sol ====
struct St0 {
  uint152 el0;
  int32 el1;
  bool[][][4] el2;
}
pragma solidity >= 0.0.0;
// ====
// ----
