
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  uint24 immutable  s0;
  bytes32 immutable public s1;
  constructor(uint24 i0,bytes32 i1)   {
    s0 = (uint24(0) * uint24(0));
    s1 = bytes32(((~((true ? (bytes3(0x000000) & bytes3(0xe5d61b)) : bytes3(0xffffff)))) & bytes3(0x000000)));
    {
      i1 &= sha256(bytes("00000000000000000000000000000000000000000000"));
      bytes32  l0 = s1;
      bytes32  l1 = l0;
      assert(l1 == s1);
      unchecked {
        assert(false);
        (bool l2, bytes memory l3) = address(this).call(bytes("00000000000000000000000000bda4cfdf623546d1e0b5f6012f00bc83a672085630"));
        {
          bytes32  l4 = s1;
          bytes32  l5 = l4;
          assert(l5 == s1);
          {
            uint24  l6 = s0;
            uint24  l7 = l6;
            assert(l7 == s0);
            bytes32  l8 = s1;
            bytes32  l9 = l8;
            assert(l9 == s1);
            {
              bytes32  l10 = s1;
              bytes32  l11 = l10;
              assert(l11 == s1);
              uint24  l12 = s0;
              uint24  l13 = l12;
              assert(l13 == s0);
            }
          }
          bytes32  l14 = s1;
          bytes32  l15 = l14;
          assert(l15 == s1);
          bytes32  l16 = s1;
          bytes32  l17 = l16;
          assert(l17 == s1);
          uint24  l18 = s0;
          uint24  l19 = l18;
          assert(l19 == s0);
          {
            bytes32  l20 = s1;
            bytes32  l21 = l20;
            assert(l21 == s1);
            uint24  l22 = s0;
            uint24  l23 = l22;
            assert(l23 == s0);
            bytes32  l24 = s1;
            bytes32  l25 = l24;
            assert(l25 == s1);
            uint24  l26 = s0;
            uint24  l27 = l26;
            assert(l27 == s0);
          }
        }
        uint24  l28 = s0;
        uint24  l29 = l28;
        assert(l29 == s0);
        uint24  l30 = s0;
        uint24  l31 = l30;
        assert(l31 == s0);
      }
      { }
    }
  }
}
function f0()    
{
  bool[7][3][5][] memory l0 = new bool[7][3][5][](3);
  function (uint168, string memory, function (bool) external   returns (bytes12, address)) internal   returns (bool) l1;
  (l0[(uint256(24973194741383092978248671844447950118055302505118747852658477391167037180837) & (uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) >> uint40(uint40(416153007874))))], l0[uint256(21599370034758136298448364844248301687808201039698481139645308973163950162281)]) = (l0[(((uint256((uint256(int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) / uint256(0))) ^ uint256(0)) ** uint32(uint32(1363485475))) + uint256(0))], l0[((~((uint256(((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) + uint256(91789605578052413181178118362011722219740663020785279826297940158666954786859)) / uint256(44403717164904359809182546550928422037758778452547570829800702093976266659420))) - uint256(73306437774972132297031112267446486414235677941169669806802920709394890949646)))) << uint8(uint8(0)))]);
  address l2 = address(0x0000000000000000000000000000000000000006);
}
// ====
// ----
