
==== Source: su0.sol ====
library L0 {
  function f0(function (int88, int232, bool) external   returns (string memory, function (bytes14, int32) external   returns (bytes2, uint16, bool[] memory)) i0) external   
  {
    {
      require(false, string(bytes(string("fffffffffffffffffffffffffffffffff04b0224d6e9"))));
    }
  }
}
library L1 {
  function f1() external   
  {
    address l0 = msg.sender;
  }
  function f2(bytes24 i0) public   
  {
    address payable[3][][2][][2][1] memory l0 = [[new address payable[3][][2][](1), new address payable[3][][2][](1)]];
    l0[(((~(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(72307806470402292490814900466744047203774269092402858632125030357322272398769))] = [new address payable[3][][2][](1), new address payable[3][][2][](1)];
    address payable l1 = payable(address(0x0000000000000000000000000000000000000002));
  }
  function f3() external    returns(uint104 o0,bool o1,bool o2)
  {
  }
}
pragma solidity >= 0.0.0;
using L1 for bytes24;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



library L2 {
  error er0(bool ep0, int56 ep1);
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
