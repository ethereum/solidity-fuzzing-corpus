
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint200 el0;
}
struct St1 {
  St0 el0;
  function () external   returns (bool[2][] memory, address) el1;
}
library L0 {
  function f0() external    returns(function () external   o0,int248 o1,bool o2)
  {
    unchecked {
      address payable[][][5][7][] memory l0 = new address payable[][][5][7][](7);
      assembly
      {
        pop(mload(add(0x80, mod(calldataload(mod(0, calldatasize())), 2048))))
        o1 := o1
        {
          switch o1
          case 0
          {
            o1 := sdiv(0, 0)
          }
        }
      }
    }
  }
  error er0();
}

==== Source: su1.sol ====
contract C0 {
  receive() external virtual  payable
  {
    address l0 = address((((int216(52656145834278593348959013841835216159447547700274555627155488767) != int216(0)) ? bytes20(address(0x0000000000000000000000000000000000000000)) : bytes20(address(0xB368201E573e2c65b61adFD759ed439cDaE235ed))) | bytes20(address(0x1f02e34960EEf77438CcE6664950D578a01B2221))));
    bytes storage l1;
    uint136 l2 = (uint136(((false ? (uint88(121185004514351547937866506) & uint88(309485009821345068724781055)) : uint88(309485009821345068724781055)) >> uint64(uint64(15465656247397393516)))) + uint136(87112285931760246646623899502532662132735));
  }
  bytes29   s0;
  uint32   s1 = uint32(0);
  uint120 immutable  s2 = uint120(0);
  constructor(bytes29 i0)   {
    s0 ^= bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
