==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  int120 el0;
}
library L0 {
  function f0(int216 i0) public    returns(bool o0,function (address payable, bytes memory) external   returns (function () external   returns (uint256, bytes memory, uint256), int96[] memory, address) o1)
  {
    St0 memory l0 = St0({el0: int120(0)});
    function (bytes6, int88) external   returns (bytes30, St0 memory, St0 memory) l1;
  }
}
pragma solidity >= 0.0.0;
library L1 {
  function f1() external   
  {
    unchecked {
      {
        (((uint136(0) >> uint136(((uint136(0) & uint136(87112285931760246646623899502532662132735)) | uint136(0)))) ** uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))) ^ uint136(43673022054990523814593927365437886876386));
        St0 memory l0 = St0(int120(0));
      }
      St0 memory l1 = St0(int120(664613997892457936451903530140172287));
    }
    bytes11 l2 = bytes11(0x02fe3d0adfc8a172f0d557);
    assembly
    {
      let al0 := 81632836788399432298159317547881585522553798442795437772567153947916763131977
    }
    int200 l3 = ((int200(803469022129495137770981046170581301261101496891396417650687) * (int200(803469022129495137770981046170581301261101496891396417650687) + int200((int200(0) / int200(0))))) + int200(367635263832714752790336771739791317459530986066748610868781));
  }
  type T0 is bytes11;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  uint88   s0;
  constructor(uint88 i0)   {
    s0 &= (uint88(((int88(-25687966473512829426796067) | (int88(0) - int88(0))) & int88(154742504910672534362390527))) * uint88(60042476435088308575422393));
    unchecked {
      uint88  l0 = s0;
      uint88  l1 = l0;
      assert(l1 == s0);
      (bool l2, bytes memory l3) = address(this).call(bytes("6e65000000000000000000"));
      uint88  l4 = s0;
      uint88  l5 = l4;
      assert(l5 == s0);
    }
  }
}
// ----
// Warning 3149: (su0.sol:492-694): The result type of the exponentiation operation is equal to the type of the first operand (uint136) ignoring the (larger) type of the second operand (uint248) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:56-65): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:85-92): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:93-246): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:256-269): Unused local variable.
// Warning 2072: (su0.sol:299-379): Unused local variable.
// Warning 6133: (su0.sol:490-749): Statement has no effect.
// Warning 2072: (su0.sol:759-772): Unused local variable.
// Warning 2072: (su0.sol:805-818): Unused local variable.
// Warning 2072: (su0.sol:882-892): Unused local variable.
// Warning 2072: (su0.sol:1054-1063): Unused local variable.
// Warning 5667: (su1.sol:69-78): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:335-342): Unused local variable.
// Warning 2072: (su1.sol:344-359): Unused local variable.
// Warning 2018: (su0.sol:44-384): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:428-1321): Function state mutability can be restricted to pure
