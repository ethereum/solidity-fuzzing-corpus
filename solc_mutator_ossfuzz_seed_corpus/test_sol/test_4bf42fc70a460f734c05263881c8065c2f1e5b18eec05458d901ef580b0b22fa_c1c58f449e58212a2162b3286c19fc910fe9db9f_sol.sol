
==== Source: su0.sol ====
contract C0 {
  error er0();
  struct St0 {
    bytes el0;
    bytes6 el1;
    uint160 el2;
  }
  int72   s0 = int72(-2105054014816509405650);
}
pragma solidity >= 0.0.0;
error er1(bytes4 ep0, bool ep1);

==== Source: su1.sol ====
struct St1 {
  bool el0;
  uint200 el1;
}
contract C1 {
  bytes11 public constant cons0 = bytes11(0xffffffffffffffffffffff);
  receive() external virtual  payable
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  St1   s1 = St1(false, uint200(0));

	function compareMemoryAndStorage(St1 memory v1, St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}  uint120   s2 = uint120(1329227995784915872903807060280344575);
  int24   s3;
  bool  public s4 = true;
  constructor(int24 i0)   {
    s3 += int24(8388607);
    unchecked {
    }
  }
  struct St2 {
    address el0;
  }
  event ev0(C1.St2[6]  ep0, function () external   returns (St1 memory, bool) indexed ep1, uint256  ep2);
  fallback() external virtual  payable
  {
    delete s3;
    if (false)
    {
    }
    else
    {
      require(s1.el0);
    }
    for(uint solinit0 = 0; solinit0 < (((((uint256(((uint256(0) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(0))) | uint256(15292796641008015368223406271241807324746811367196674605941099011381122522132)) & uint256(0)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
    {
      return;
    }
  }
  function f2(uint120 i0) private     returns(int120 o0)  {
    payable(this).transfer(0);
  }
}
struct St3 {
  bool el0;
  bytes24 el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
