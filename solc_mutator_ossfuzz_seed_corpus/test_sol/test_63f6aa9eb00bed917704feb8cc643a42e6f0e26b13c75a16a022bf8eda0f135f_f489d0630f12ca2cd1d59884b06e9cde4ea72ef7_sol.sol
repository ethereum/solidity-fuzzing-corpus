
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  uint200   s0;
  address immutable public s1;
  bool   s2 = true;
  constructor(uint200 i0,address i1)   {
    s0 /= (uint200(0) % uint200(119093583478459344982876648969386068865943477738479510381995));
    s1 = (((-((int72(-1174814861376596460698) * int72(0)))) < int192(-2225050547808761913902266356162620376212198846444242556636)) ? address(this) : address(this));
    {
      uint200  l0 = s0;
      uint200  l1 = l0;
      assert(l1 == s0);
    }
  }
  fallback() external   
  {
    uint200  l0 = s0;
    uint200  l1 = l0;
    assert(l1 == s0);
  }
  struct St0 {
    bool el0;
    address[2][][6][][5] el1;
    bool el2;
    function (int216, bool) external   returns (string memory, uint184, int104) el3;
  }
}
library L0 {
  function f2(int40[][][][9] memory i0) public    returns(uint176 o0,function (C0.St0 memory, bool[8][9] memory, bool) external   returns (function (bytes memory, bytes9, bool) external   returns (bool, uint216)) o1)
  {
  }
}
using L0 for int40[][][][9];
using L0 for int40[][][][9];

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f3(function (bytes27, uint120) external   returns (bool, uint160) i0)    
{
}
// ====
// ----
