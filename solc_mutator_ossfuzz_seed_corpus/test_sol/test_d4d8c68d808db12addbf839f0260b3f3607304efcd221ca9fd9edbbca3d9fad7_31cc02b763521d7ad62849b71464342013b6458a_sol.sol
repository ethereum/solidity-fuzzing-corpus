
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint184 el0;
}
function f0(int184 i0,uint248 i1)     {
  bool l0 = (((uint232(6901746346790563787434755862277025452451108972170386555162524223799295) % uint232((uint192(6277101735386680763835789423207666416102355444464034512895) / uint232(6901746346790563787434755862277025452451108972170386555162524223799295)))) & uint232(0)) > uint232(0));
}
struct St1 {
  bytes1 el0;
  St0 el1;
  string el2;
}

==== Source: su1.sol ====
struct St2 {
  bytes9 el0;
  int192 el1;
}
error er0(St2 ep0);
pragma solidity >= 0.0.0;
contract C0 {
  address  public s0 = address(this);
  function f1(address i0) private     returns(St2 memory o0)  {
    for(    bytes20 l0 = (true ? (~(ripemd160((false ? bytes("00000000000000000000000000000000000000000000000000ffffffffffffffffff") : bytes("000000000000000000000000000000000000ffff"))))) : bytes20(address(0x0000000000000000000000000000000000000000)));
true;
)
    {
      (bool l1, bytes memory l2) = address(this).call(bytes("2925bab456cefed8c2c0029fe0b70509dc3dd62eeaabb500f09fb612146b0e1474bcd296a9fa8aae91166e0274949f78c8110fb221d2ae"));
      (s0, o0.el0) = (address(bytes20(address(0x0000000000000000000000000000000000000000))), bytes9(0xffffffffffffffffff));
      assert(s0 == address(bytes20(address(0x0000000000000000000000000000000000000000))));
      assert(o0.el0 == bytes9(0xffffffffffffffffff));
    }
    (o0.el1, o0.el0) = (int192(1633551704070520629971561040803889735324163915322611765803), o0.el0);
    assert(o0.el1 == int192(1633551704070520629971561040803889735324163915322611765803));
    assert(o0.el0 == o0.el0);
  }
}
struct St3 {
  bytes4 el0;
  bytes7 el1;
  uint64 el2;
}
// ====
// ----
