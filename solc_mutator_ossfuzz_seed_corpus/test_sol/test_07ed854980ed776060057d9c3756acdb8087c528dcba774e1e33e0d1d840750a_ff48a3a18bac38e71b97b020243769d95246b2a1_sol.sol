
==== Source: su0.sol ====
error er0(address ep0);
error er1();
function f0()     {
  revert er0(address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  address payable el0;
  mapping(bytes6 => bytes[]) el1;
}
contract C0 {
  receive() external   payable
  {
    if (true)
    {
    }
    else if (true)
    {
      for(uint solinit0 = 0; solinit0 < (uint256(0) % 11); solinit0++)
      {
        continue;
      }
    }
  }
  function f2(bytes27 i0) external   payable  returns(function (address payable, function () external   returns (bool, uint80)) external   returns (string memory, bytes memory) o0)  {
  }
  function f3(address payable i0) public virtual  payable  returns(bool o0)  {
    if (i0 < payable(address(this)))
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    else
    {
      for(;
(false ? (true ? false : (bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) > bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))) : true);
payable(address(this)))
      {
        continue;
      }
      return (false);
    }
    uint136((uint136(44810666421890567637789145309812694226541) / uint136(72395747273924875791326262031211691794628)));
  }
  int112[3]   s0 = [int112(-1548637980372990756188842342376714), int112(2318110489492104056560908520922689), int112(-1989771727374777222804923464036227)];

	function compareMemoryAndStorage(int112[3] memory v1, int112[3] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool immutable  s1;
  uint56   s2 = uint56(0);
  int56   s3;
  constructor(bool i0,int56 i1)   {
    s1 = false;
    s3 /= (((((int32(-1287266259) ^ int32(2147483647)) | int56(36028797018963967)) + int56(-34683002779468605)) * int56(7727987692556760)) - int56(36028797018963967));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
