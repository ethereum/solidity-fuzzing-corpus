
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  error er0(uint56 ep0);
  int240   s0 = int240(-647149809868089441736451967256997677360534896874533513350564433903380829);
  uint216 immutable  s1 = uint216(18821425159528309789273658884194052558111368322914091190405440730);
  bool  public s2;
  bool   s3;
  constructor(bool i0,bool i1) payable  {
    s2 = true;
    s3 = i1;
    {
    }
  }
  function f0() public   payable  returns(uint256 o0,function (uint184, uint32, bool) external   returns (uint96) o1)  {
    (uint96 l0) = o1(uint184(0),uint32((uint32(0) / uint32(784692183))),true);
  }
  function f1(bool i0,uint216 i1) private      {
    if (i0)
    {
      return;
    }
    if (i1 > uint216(105312291668557186697918027683670432318895095400549111254310977535))
    {
      s2 = false;
      assert(s2 == false);
      revert er0(uint56(((((uint56(0) * (uint56(72057594037927935) ** uint168(uint168(0)))) ^ uint56(72057594037927935)) & uint56(0)) / uint56(0))));
    }
  }
}
struct St0 {
  int104 el0;
  mapping(address => uint248) el1;
  bytes el2;
  function (bytes1, bytes10) external   returns (bytes9, bytes9) el3;
}
struct St1 {
  mapping(uint104 => mapping(address => bool)[]) el0;
  uint232 el1;
  address el2;
}

==== Source: su1.sol ====
struct St2 {
  bytes12 el0;
  int40 el1;
  uint104 el2;
  uint32 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
