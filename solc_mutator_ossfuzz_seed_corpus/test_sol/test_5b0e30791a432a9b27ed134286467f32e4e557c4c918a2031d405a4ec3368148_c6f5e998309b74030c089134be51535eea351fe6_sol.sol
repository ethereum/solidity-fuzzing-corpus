
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  error er0();
  int232   s0 = int232(-424152239593401956473277030005108380053872146874218729701655612393157);
  uint72   s1 = uint72(4722366482869645213695);
  int224  public s2;
  constructor(int224 i0) payable  {
    s2 &= ((((((int224(13479973333575319897333507543509815336818572211270286240551805124607) - int224(-4358611737854304621944157378990677392706542676000860831166917679120)) ^ int224(-13027973400397718886952299093713966347230215935693456108706201283592)) ^ int224(13479973333575319897333507543509815336818572211270286240551805124607)) ^ int224(-28525994153539286549395322029656682557318561686587845773977348377)) & int224(13479973333575319897333507543509815336818572211270286240551805124607)) | int224(0));
    unchecked {
      uint72  l0 = s1;
      uint72  l1 = l0;
      assert(l1 == s1);
      (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
      uint72  l4 = s1;
      uint72  l5 = l4;
      assert(l5 == s1);
      int232  l6 = s0;
      int232  l7 = l6;
      assert(l7 == s0);
    }
  }
  fallback() external   
  {
    uint72  l0 = s1;
    uint72  l1 = l0;
    assert(l1 == s1);
    delete s2;
    uint72  l2 = s1;
    uint72  l3 = l2;
    assert(l3 == s1);
  }
}

==== Source: su1.sol ====
function f1()     returns(address payable o0)
{
  return (payable(address(0x0000000000000000000000000000000000000007)));
}
pragma solidity >= 0.0.0;
// ====
// ----
