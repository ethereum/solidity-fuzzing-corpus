
==== Source: su0.sol ====
contract C0 {
  fallback() external   
  {
    function () internal   returns (bool, bool, address) l0;
    uint48 l1 = uint48(0);
    bytes15 l2 = bytes15(0x000000000000000000000000000000);
  }
  bytes31  public s0 = bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  uint184   s1;
  uint64   s2 = uint64(18446744073709551615);
  constructor(uint184 i0)   {
    s1 >>= (uint16((uint16(0) / (~(uint16(28456))))) ** uint160(uint160(0)));
    unchecked {
      uint64  l0 = s2;
      uint64  l1 = l0;
      assert(l1 == s2);
      uint64  l2 = s2;
      uint64  l3 = l2;
      assert(l3 == s2);
      (bool l4, bytes memory l5) = address(this).call(bytes("37ddfc658a35494a81e9cd4e47e36b28769266f0d3255bae"));
      for(uint solinit0 = 0; solinit0 < ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) + (~(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))) % 11); solinit0++)
      {
        continue;
      }
    }
  }
}
library L0 {
  int120 public constant cons0 = -149973130393477505798179131025786484;
  function f1(address i0,uint120 i1,address[9][10] memory i2) external   
  {
    int56 l0 = (((int56(((int56(36028797018963967) + int56(36028797018963967)) / int56(0))) + int56(36028797018963967)) * int56(36028797018963967)) % int56(-31805133339042537));
    int184 l1 = (-((((true ? false : false) ? int184(12259964326927110866866776217202473468949912977468817407) : int184(-3819735285114818691677545553154787142359064923699004983)) ^ int184(12259964326927110866866776217202473468949912977468817407))));
  }
}
using L0 for address;
pragma solidity >= 0.0.0;
struct St0 {
  bytes el0;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
