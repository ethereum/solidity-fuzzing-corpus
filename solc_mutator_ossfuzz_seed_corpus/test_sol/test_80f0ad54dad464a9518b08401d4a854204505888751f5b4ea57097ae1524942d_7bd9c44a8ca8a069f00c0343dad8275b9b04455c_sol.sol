
==== Source: su0.sol ====
struct St0 {
  mapping(uint48 => bool) el0;
  function (int136, uint144) external   returns (function (bytes7, int40, bytes15) external   returns (function (uint136) external   returns (int120, int240[10] memory), uint240, string memory)) el1;
  address el2;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  struct St1 {
    uint72 el0;
  }
  receive() external virtual  payable
  {
  }
  address   s0 = address(this);
  address payable   s1;
  constructor(address payable i0) payable  {
    s1 = payable(address(this));
    unchecked {
    }
  }
  struct St2 {
    bytes7[] el0;
  }
  fallback() external virtual  
  {
    if (true)
    {
      if (false)
      {
        if (true)
        {
          if (false)
          {
            (false ? bytes7(0xffffffffffffff) : (bytes7(0x00000000000000) ^ bytes7(0xffffffffffffff)));
          }
        }
        address payable  l0 = s1;
        address payable  l1 = l0;
        assert(l1 == s1);
        return;
      }
    }
    else if (true)
    {
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 {
  uint64 immutable  s2 = uint64(0);
  C0.St1   s3;

	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  int48   s4;
  uint96  public s5 = uint96(79228162514264337593543950335);
  constructor(int48 i0)   {
    s4 |= int48(140737488355327);
    unchecked {
    }
  }
  type T0 is uint64;
}
// ====
// ----
