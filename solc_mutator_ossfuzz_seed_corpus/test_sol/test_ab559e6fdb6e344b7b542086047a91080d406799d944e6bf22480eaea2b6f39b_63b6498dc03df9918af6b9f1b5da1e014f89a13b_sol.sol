
==== Source: su0.sol ====
struct St0 {
  function (address, string memory, uint256) external   returns (function (bytes15, function (bytes21, uint64, bool) external   returns (function (uint192) external   returns (bool, bytes17, bool), address), function (function (bytes memory, bool, uint216) external   returns (bool), int176, uint216) external   returns (uint112)) external  , uint152, function (bytes memory) external  ) el0;
  bool el1;
  bytes12 el2;
  uint56 el3;
}
function f0()     returns(address payable o0)
{
  {
  }
  (o0) = (payable(address(0x0000000000000000000000000000000000000004)));
}
library L0 {
  event ev0(function (St0 memory, address payable) external   returns (bool, bytes16[2] memory, uint104)  ep0, int120  ep1);
  error er0();
  enum EN0 {
    M0, M1, M2, M3, M4, M5
  }
  modifier m0(uint24 i0) 
  {
    _;
  }
  error er1();
  type T0 is bool;
  using L0 for *;
}
L0.T0 constant cons0 = L0.T0.wrap(false);
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6
}
type T1 is uint136;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
enum EN2 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81
}
contract C0 {
  modifier m1(L0.T0 i0,string memory i1) 
  {
    if (false)
    {
      for(;
true;
)
      {
        break;
        continue;
        _;
      }
      do
      {
        delete i1;
        _;
        payable(this).transfer(10305984896529299253);
      }
      while (true);
    }
    else if ((uint128(340282366920938463463374607431768211455) <= (uint128((((uint128(340282366920938463463374607431768211455) >> uint192(uint192(0))) % uint128(220340783116099309322924750481912827677)) / uint128(340282366920938463463374607431768211455))) + uint128(0))))
    {
    }
  }
  using L0 for *;
  modifier m2(int80 i0,uint32 i1) virtual
  {
    _;
  }
  receive() external  m1(L0.T0.wrap(true),string("ffffffffffffffffffffffffffffffffffffffffffffff")) payable
  {
    for(;
;
)
    {
    }
    for(    EN2.M75;
false;
)
    {
      continue;
      if (false)
      {
      }
      else
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 16801601131446027587}("");
      }
    }
  }
  function f2(bytes calldata i0,uint56 i1) external  m2(int80(0),((((((uint32(0) + uint32(4294967295)) * uint32(1871611087)) + uint32(4294967295)) ** uint136(uint136(24400496733915034567658155366187950906020))) & uint32(0)) ^ uint32(3823872307))) payable returns(bytes24 o0,St0 memory o1)
  {
    return (bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff), o1);
  }
  bytes7   s0 = bytes7(0xc030b04444ebe7);
  bytes28 immutable public s1 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
  struct St1 {
    bytes2 el0;
  }
  enum EN3 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95

  }
  bool public constant cons1 = (((!((!(((true || false) ? false : true))))) || true) == false);
}
T1 constant cons2 = T1.wrap(uint136(87112285931760246646623899502532662132735));
struct St2 {
  bool el0;
}
using L0 for uint;
// ====
// ----
