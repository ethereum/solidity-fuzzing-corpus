
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint24 el0;
  mapping(int184 => bytes8[6]) el1;
  string el2;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L0 {
  error er0(uint248 ep0, bool ep1);
  event ev0(bytes20  ep0, int24  ep1, bool indexed ep2);
  function f0(bool i0) external    returns(string memory o0)
  {
    while (false)
    {
      bytes11 l0 = bytes9(0xffffffffffffffffff);
    }
    int104 l1 = ((int104(0) & int104(-6808992076165300085596268242811)) + ((int104(0) * int104(10141204801825835211973625643007)) ** uint24(uint24(0))));
  }
}
using L0 for bool;
contract C0 {
  function f1() internal virtual   returns(bytes memory o0,int232 o1)
  {
    (bool l0, bytes memory l1) = address(this).call(((address(this) <= address(bytes20(address(0x862B5DC262Ce64B6426059Ea01C35c178Eda9A84)))) ? o0 : bytes("ffffff6c1d875051e960a8771c3b31432f5af1666705930a")));
    bytes20 l2 = (false ? ripemd160(bytes("ec7ebf871b20f5ae6dfba70f87c018ab542a76a51f8bc28f494483ca54f2195c4148d63975042d163edf35f3dc1b5731a6a31d")) : bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
  }
  string  public s0 = string("ffffffffffa3ee43ec334c07d8bd9d8d0ad92cecbd7da4d9bffda787ebee");

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint136 immutable public s1;
  bytes24  public s2 = bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff);
  constructor(uint136 i0)   {
    s1 = ((uint136(87112285931760246646623899502532662132735) & uint136(0)) ^ uint136(17978197824908440662184492393917544330223));
    unchecked {
      bytes24  l0 = s2;
      bytes24  l1 = l0;
      assert(l1 == s2);
      bytes24  l2 = s2;
      bytes24  l3 = l2;
      assert(l3 == s2);
    }
  }
}
// ====
// ----
