
==== Source: su0.sol ====
struct St0 {
  address el0;
  address el1;
  int8 el2;
}
contract C0 {
  address  public s0 = address(this);
  St0   s1;

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}  address   s2;
  constructor(address i0) payable  {
    s2 = address(bytes20(address(0x5615fCDa5e6E30de65fdAF923a515c13a9D4f020)));
    {
    }
  }
  receive() external   payable
  {
    if (true)
    {
      return;
    }
  }
  event ev0(uint56  ep0, int32 indexed ep1, address payable[9]  ep2);
  function f1(address i0) private      {
    emit ev0(uint56((uint24((uint24((((true ? uint24(0) : uint24(1030537)) | uint24(16777215)) / uint24(0))) / uint24(1588283))) / uint56(0))), int32(-1852768487), [payable(address(0x0000000000000000000000000000000000000002)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000002)), payable(address(0x0000000000000000000000000000000000000008)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000004)), payable(address(0x0000000000000000000000000000000000000002)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000001))]);
    for(    bool l0 = true;
;
)
    {
      break;
    }
    emit ev0((uint56(0) + uint56(72057594037927935)), int32(0), [payable(address(0x0000000000000000000000000000000000000006)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000004)), payable(address(0x0000000000000000000000000000000000000005)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000003)), payable(address(0x0000000000000000000000000000000000000001)), payable(address(0x0000000000000000000000000000000000000003)), payable(address(0x0000000000000000000000000000000000000005))]);
    assert(true);
  }
  function f2() public     returns(bytes7 o0,bool o1)  {
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
contract C1 {
  struct St1 {
    bool el0;
    C0 el1;
    St0 el2;
  }
  mapping(bytes7 => address)   s3;
  bytes28   s4;
  constructor(bytes28 i0) payable  {
    s4 = bytes28(0xb65b4672e555f0a2717368c85bc72fe31ef2575665de1a17c36f8405);
    s3[(true ? (false ? (bytes7(0x00000000000000) & bytes7(0xffffffffffffff)) : bytes7(0x00000000000000)) : bytes7(0xeca3e0b3cab56d))] = msg.sender;
    unchecked {
    }
  }
  fallback() external   
  {
  }
}
struct St2 {
  int248 el0;
  string el1;
  address el2;
}
// ====
// ----
