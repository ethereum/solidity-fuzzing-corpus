
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int120 el0;
  address el1;
  bytes[] el2;
  uint56[] el3;
}
function f0()     {
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  int208 el0;
  uint168 el1;
  mapping(int128 => int16[9]) el2;
}
contract C0 {
  St1   s0;
  mapping(bool => bytes31)   s1;
  St1  public s2;
  constructor()   {
    s1[(true ? (int144(-7114544358365437676694162205849584895761962) <= int144(7871193025616250892191272251652098888748347)) : true)] &= (bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes31(bytes5(0x11f3af63ad)));
    unchecked {
    }
  }
  receive() external   payable
  {
    if (true)
    {
    }
    if (false)
    {
      if ((bytes13(0x80c6ad5e34e83a60f4b27030d7) >= bytes13(0xe403d6794ddbea67f9131b2119)))
      {
        for(uint solinit0 = 0; solinit0 < (((((uint216((uint216(103504235541150200181783867316791915954313123932731221312537255505) / uint216(0))) >> uint64(uint64(18446744073709551615))) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
        {
        }
      }
    }
    else if (false)
    {
    }
  }
  function f2() public virtual    returns(uint224[5] memory o0)  {
  }
  fallback() external virtual  
  {
    s0.el0 ^= (-(int208(-162597123573620361602184387122947564800455227408774597860763905)));
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  struct St2 {
    function () external   el0;
    address el1;
  }
  struct St3 {
    function (bytes12, int184, bool) external   returns (address) el0;
    bool el1;
    bytes16 el2;
  }
}
struct St4 {
  bytes16 el0;
  bool el1;
}
// ====
// ----
