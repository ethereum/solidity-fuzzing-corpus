==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(uint128  ep0, function () external    ep1);
  function f0(address payable i0) public virtual  payable  returns(int168 o0)  {
    (bool l0, bytes memory l1) = address(this).call(abi.encodeCall(this.f0, (payable(address(bytes20(address(0xD9C0B7ccd83d600D503e6F770C5882577e4a4cDF)))))));
    (o0) = ((int168(0) & (int168(187072209578355573530071658587684226515959365500927) & (~((int168(187072209578355573530071658587684226515959365500927) + int168(187072209578355573530071658587684226515959365500927)))))));
    assert(o0 == (int168(0) & (int168(187072209578355573530071658587684226515959365500927) & (~((int168(187072209578355573530071658587684226515959365500927) + int168(187072209578355573530071658587684226515959365500927)))))));
  }
  bytes27  public s0;
  constructor(bytes27 i0)   {
    s0 = (bytes27(0xbdf82d30aed8812188c722fae4a5d86cfc297cd73399b673357cc9) & bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff));
    unchecked {
    }
  }
  type T0 is address;
}
struct St0 {
  bytes3 el0;
  mapping(bool => uint184) el1;
}
struct St1 {
  bool el0;
  int192 el1;
}

==== Source: su1.sol ====
contract C1 {
  receive() external virtual  payable
  {
    for(uint solinit0 = 0; solinit0 < (((uint256(0) - (uint256(0) + uint16(0))) ^ uint256(0)) % 11); solinit0++)
    {
      break;
    }
  }
  bool   s1 = true;
  address  public s2;
  mapping(uint24 => uint184)   s3;
  constructor(address i0)   {
    s2 = address(this);
    s3[(uint24(16777215) | uint24(16777215))] |= uint184(24519928653854221733733552434404946937899825954937634815);
    unchecked {
    }
  }
  struct St2 {
    mapping(uint8 => uint8) el0;
    uint216 el1;
    bytes26 el2;
  }
  function f2() public      {
    while (false)
    {
      assert(true);
    }
  }
}
contract C2 is C1 {
  struct St3 {
    bytes el0;
    address el1;
  }
  uint8 immutable  s4;
  bool   s5 = true;
  int72  public s6;
  constructor(address i0,uint8 i1,int72 i2)  C1(address(this))
  {
    s2 = address(this);
    s4 = uint8(255);
    s6 /= int72(((uint72(4722366482869645213695) >> uint184(uint184(24519928653854221733733552434404946937899825954937634815))) % (uint72(503609467423666271742) ** uint32(uint32(1304717187)))));
    s3[uint24(6072825)] %= (uint184(24519928653854221733733552434404946937899825954937634815) >> uint200((uint200((uint200(0) / (uint200(0) ** uint56(uint56(3784382322478187))))) + uint200(1606938044258990275541962092341162602522202993782792835301375))));
    unchecked {
    }
  }
  receive() external virtual override  payable
  {
    while (((int176(-6235558937911869062868783242993973109707981248366382) & int176(47890485652059026823698344598447161988085597568237567)) <= ((true ? int176(0) : int176(0)) & int176(47890485652059026823698344598447161988085597568237567))))
    {
      break;
    }
    (s5) = (true);
    assert(s5 == true);
  }
}
pragma solidity >= 0.0.0;
error er0();
// ----
// Warning 5740: (su1.sol:157-167): Unreachable code.
// Warning 5667: (su0.sol:110-128): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:182-189): Unused local variable.
// Warning 2072: (su0.sol:191-206): Unused local variable.
// Warning 5667: (su0.sol:824-834): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:289-299): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:791-801): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:802-810): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:811-819): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:559-640): Function state mutability can be restricted to pure
