==== Source:  ====

==== Source: su0.sol ====
function f0(bytes16[] memory i0,address i1)     returns(bytes8 o0,uint72 o1)
{
}
uint96 constant cons0 = (~((~(((((~(uint96(0))) ** uint64(18446744073709551615)) ** uint56(72057594037927935)) ** uint256(89809372053834913057911477552818798706486831204673348472987837758366347723910))))));
contract C0 {
  event ev0();
  receive() external virtual  payable
  {
    if (true)
    {
      emit ev0();
      return;
    }
    else if (false)
    {
      assert((int24(6053199) != (~(int24(8388607)))));
    }
    else
    {
    }
    (bool l0, bytes memory l1) = payable(this).call{value: 5399810405202835676}("");
  }
  function f2() external   payable
  {
    return;
    emit ev0();
  }
  enum EN0 {
    M0, M1, M2
  }
  event ev1(uint240  ep0);
  bytes14[2]  s0;
  constructor(bytes14[2] memory i0)   {
    s0 = i0;
    unchecked {
      require(true);
      s0[0] |= bytes14(0x0000000000000000000000000000);
    }
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112
  }
  type T0 is address;
}
type T1 is bytes11;
pragma solidity >= 0.0.0;
library L0 {
  C0.EN0 public constant cons1 = C0.EN0.M2;
  error er0(bytes ep0);
  event ev2(address  ep0, bool indexed ep1);
  error er1(uint176 ep0, bool ep1);
  type T2 is int48;
  function f3(address i0) public   
  {
    require(true);
  }
  bool public constant cons2 = true;
}
error er2(L0.T2 ep0);
// ----
// Warning 3149: (su0.sol:112-281): The result type of the exponentiation operation is equal to the type of the first operand (uint96) ignoring the (larger) type of the second operand (uint256) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:669-679): Unreachable code.
// Warning 2072: (su0.sol:530-537): Unused local variable.
// Warning 2072: (su0.sol:539-554): Unused local variable.
// Warning 5667: (su0.sol:1828-1838): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1816-1876): Function state mutability can be restricted to pure
