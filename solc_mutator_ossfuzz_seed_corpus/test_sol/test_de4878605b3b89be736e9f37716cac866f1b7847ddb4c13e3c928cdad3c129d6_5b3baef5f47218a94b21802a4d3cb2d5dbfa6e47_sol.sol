
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address payable el0;
  int168 el1;
  bool el2;
}

==== Source: su1.sol ====
import "su0.sol";
struct St1 {
  bytes15 el0;
  int88 el1;
}
contract C0 {
  bytes30 immutable  s0 = bytes30(0xf2498e6e8cc95826872449d487c738396f96aa5d2c3709656b356323ecc0);
  uint104  public s1;
  uint136   s2 = uint136(51185080002742772438356563976404850301258);
  constructor(uint104 i0)   {
    s1 += uint104(20282409603651670423947251286015);
    {
    }
  }
  receive() external virtual  payable
  {
    do
    {
      int88[] storage l0;
      0;
    }
    while (true);
    if (true)
    {
    }
    else if ((bytes19(0x706b2750b1624fa500ed83870c33ca45c85cd6) < bytes19(bytes22(0x00000000000000000000000000000000000000000000))))
    {
    }
  }
  fallback() external   
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  function f2(uint104 i0,uint136 i1) public   payable  returns(address payable o0,function (address) external   o1,int192 o2)  {
    o2 &= (int192(3138550867693340381917894711603833208051177722232017256447) ^ (-(int192(0))));
    uint136  l0 = s2;
    uint136  l1 = l0;
    assert(l1 == s2);
    for(;
(false ? true : 40708723421521229256916447156806049308 f3 /*suffix expr*/);
((bytes10(0x00000000000000000000) & (bytes10(0xffffffffffffffffffff) & (~(bytes10(0x00000000000000000000))))) ^ bytes10(0xffffffffffffffffffff)))
    {
      break;
    }
  }
}
pragma solidity >= 0.0.0;
function f3(int128 i0) pure suffix  returns(bool o0)
{
}
// ====
// ----
