
==== Source: su0.sol ====
library L0 {
  modifier m0(bytes10 i0,int232 i1) 
  {
    _;
    assembly
    {
    }
    assembly
    {
      if 37594240055478772695201126715220769829052935751775752206448428766963642404806
      {
      }
      for 
      {
      }
      i0
      {
        let al0 := 0
      }
      {
      }
      for 
      {
      }
      calldataload(mod(i1, calldatasize()))
      {
      }
      {
      }
      {
        return(i1, 0)
      }
    }
  }
  modifier m1(uint40 i0,uint160 i1) 
  {
    _;
  }
  error er0(bytes22 ep0);
  error er1(address payable ep0);
  event ev0(bytes29  ep0, bool  ep1);
  type T0 is address;
  L0.T0 public constant cons0 = L0.T0.wrap(address(0x0000000000000000000000000000000000000005));
  function f0(function (uint232, address[] memory) external   i0) external    returns(uint192 o0)
  {
    bool l0 = false;
  }
  function f1() public  m1(((uint40(((uint40(1099511627775) + (uint40(1099511627775) + uint40(0))) / uint40(112294580028))) << uint48(uint48(130774956498475))) % uint40(194909981535)),((uint160((uint160(1461501637330902918203684832716283019655932542975) / ((uint160(1271928542411849993135768171502571910117260231845) % uint160(0)) & uint160(0)))) - uint160(0)) - uint160(1461501637330902918203684832716283019655932542975)))  returns(uint256 o0,function (uint160) external   returns (int184, int64, bytes18) o1)
  {
    function () external   l0;
    address payable l1 = payable(address(0x0000000000000000000000000000000000000004));
  }
}
int248 constant cons1 = ((~(((((int248(13599275039789880978642459575321916850590924276369267418181900278067215420) & int248(0)) ^ int248(0)) | int248(0)) * int248(226156424291633194186662080095093570025917938800079226639565593765455331327)))) % int248(104443173156732268062789148864823865787838146502840916988522192107507272982));
function f2()    
{
}
pragma solidity >= 0.0.0;
error er2();
using L0 for uint;
type T1 is uint64;
// ====
// ----
