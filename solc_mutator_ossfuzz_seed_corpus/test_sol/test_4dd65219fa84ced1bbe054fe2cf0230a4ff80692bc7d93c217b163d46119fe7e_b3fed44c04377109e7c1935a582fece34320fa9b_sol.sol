
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call((false ? bytes("ffffffffff00000000000000000000000000000000000000000000000000") : bytes("ffffffffffffffffffffffffffff000000000000000000000000000000000000")));
    function (bytes19, uint160, uint168) internal   returns (bool, bool, bool) l2;
  }
  type T0 is address payable;
  bytes22   s0;
  C0.T0  public s1 = C0.T0.wrap(payable(address(0x0000000000000000000000000000000000000002)));
  int80  public s2 = int80(-580870883492425724172253);
  bytes23   s3 = bytes23(0x30c5bb49575ca877f2744d36cc0718a80d3e94fb33b6e6);
  constructor(bytes22 i0) payable  {
    s0 ^= bytes22(0xffffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
      {
        {
          require((uint40(878496908421) >= uint40(0)));
        }
        (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000"));
        s2 /= int80(0);
        {
        }
      }
      bytes23  l2 = s3;
      bytes23  l3 = l2;
      assert(l3 == s3);
      C0.T0  l4 = s1;
      C0.T0  l5 = l4;
      assert(l5 == s1);
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L0 {
  modifier m0(bytes memory i0) 
  {
    _;
  }
}
// ====
// ----
