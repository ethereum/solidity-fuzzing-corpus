
==== Source: su0.sol ====
library L0 {
  function f0() external    returns(address payable o0)
  {
    int256 l0 = int256(40019228638426675735678852664492554244941745835165277536703012184902939736660);
    uint176 l1 = ((((((uint176(0) + uint176(95780971304118053647396689196894323976171195136475135)) + uint176(18355469211213159851572579734700875750837249361398985)) << uint64(uint64(7716979830754274928))) & uint176(95780971304118053647396689196894323976171195136475135)) ^ uint176(433923651967607227276346717959680367532872414267174)) ^ uint176(95780971304118053647396689196894323976171195136475135));
    bytes30 l2 = (bytes30(0x000000000000000000000000000000000000000000000000000000000000) ^ bytes30(0x000000000000000000000000000000000000000000000000000000000000));
  }
  function f1() public   
  {
    assembly
    {
      return(115792089237316195423570985008687907853269984665640564039457584007913129639935, calldataload(mod(0, calldatasize())))
    }
    bool l0 = (payable(address(0x0000000000000000000000000000000000000006)) >= payable(address(0x0000000000000000000000000000000000000003)));
  }
  address payable public constant cons0 = payable(0x0000000000000000000000000000000000000000);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L1 {
  error er0();
}
function f2(function (uint200, uint168) external   returns (function (bytes2) external  , int88[][][] memory) i0,address payable i1)    
{
  unchecked {
  }
}
struct St0 {
  bool el0;
  bytes18 el1;
  uint56 el2;
}
// ====
// ----
