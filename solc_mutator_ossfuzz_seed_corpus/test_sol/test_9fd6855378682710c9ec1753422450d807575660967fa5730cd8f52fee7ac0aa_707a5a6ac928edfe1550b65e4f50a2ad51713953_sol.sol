
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(bool ep0);
struct St0 {
  bytes6 el0;
  int232 el1;
  address payable el2;
}
contract C0 {
  event ev0();
  mapping(bytes18 => mapping(uint32 => St0))   s0;
  constructor()   {
    {
    }
  }
  receive() external   payable
  {
    while (((true ? true : true) ? true : true))
    {
      continue;
    }
    if ((false ? true : (payable(address(this)) < payable(address(this)))))
    {
    }
    if (false)
    {
    }
    revert(390538823637 f1 /*suffix expr*/);
  }
  struct St1 {
    int32 el0;
  }
  type T0 is bool;
  fallback() external   
  {
    revert er0(true);
  }
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
}
function f1(int40 i0) pure suffix  returns(string memory o0)
{
  uint144 l0 = (uint144(((uint144(0) ^ uint104(0)) / uint144(4826661803336315109990221317454984386896499))) * uint144(0));
  o0 = 0 f3 /*suffix expr*/;
  assert(keccak256(bytes(o0)) == keccak256(bytes(0 f3 /*suffix expr*/)));
}
function f3(uint184 i0) pure suffix  returns(string memory o0)
{
  return (string("This is a really long string that must ideally be random but is currently hard coded"));
}

==== Source: su1.sol ====
function f4()     {
}
function f5(address payable i0,bytes memory i1)     {
  if (i1.length >= (i1.length + ((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) - uint256(0)) % uint256(0)) ^ uint256(81622371970125159829219476393638271817475275884064997181280079351732070733571)) % uint256(52905630502594734918716393510938822128265780184524483257939919375168147349142))))
  {
    for(;
;
true)
    {
      break;
    }
    if (i0 < payable(address(0x0000000000000000000000000000000000000005)))
    {
      if (i1.length < uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))
      {
        if (i0 != payable(address(0x0000000000000000000000000000000000000008)))
        {
          (i0) = ((((((address(0x0000000000000000000000000000000000000003) >= address(0x0000000000000000000000000000000000000003)) ? true : true) ? true : true) ? true : false) ? payable(address(0x0000000000000000000000000000000000000001)) : payable(address(0x0000000000000000000000000000000000000003))));
          assert(i0 == (((((address(0x0000000000000000000000000000000000000003) >= address(0x0000000000000000000000000000000000000003)) ? true : true) ? true : true) ? true : false) ? payable(address(0x0000000000000000000000000000000000000001)) : payable(address(0x0000000000000000000000000000000000000003))));
        }
        else if (i0 > payable(address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))))
        {
          for(uint solinit0 = 0; solinit0 < (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % 11); solinit0++)
          {
          }
        }
        delete i0;
      }
    }
    else
    {
    }
  }
  else
  {
  }
}
function f7()      returns(bytes3 o0){
}
pragma solidity >= 0.0.0;
struct St2 {
  bytes6 el0;
  mapping(int248 => int96) el1;
  int240 el2;
  int96 el3;
}
function f6(bool i0) pure suffix  returns(uint176 o0)
{
  address l0 = msg.sender;
  if (i0)
  {
    return ((true f8 /*suffix expr*/ | (uint176(70226958431761924179106707843366689527448277250495803) + (uint176(95780971304118053647396689196894323976171195136475135) & uint176(45200788235312454733055924912048759861902137954759480)))));
  }
}
function f8(bool i0) pure suffix  returns(uint176 o0)
{
}
// ====
// ----
