
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    uint248 el0;
    address el1;
    function () external   el2;
  }
  bytes3[7]   s0 = [bytes3(0x399434), bytes3(0x000000), bytes3(0xc4ad1e), bytes3(0x8a82a4), bytes3(0xffffff), bytes3(0xffffff), bytes3(0x7cb7e4)];

	function compareMemoryAndStorage(bytes3[7] memory v1, bytes3[7] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int208   s1 = int208(205688069665150755269371147819668813122841983204197482918576127);
  function f0(int208 i0) internal virtual     {
    (s0[s0.length]) = ((bytes3(0x4f75cf) & 0x0000000000000000000000000000000000000004 f1 /*suffix expr*/));
    assert(s0[s0.length] == (bytes3(0x4f75cf) & 0x0000000000000000000000000000000000000004 f1 /*suffix expr*/));
    for(uint solinit0 = 0; solinit0 < (uint256(36292301065503585801611089413448778569481935116082461883171335867290200956162) % 11); solinit0++)
    {
      continue;
    }
  }
  fallback() external virtual  
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
function f3(int104 i0)    pure suffix returns(uint72 o0){
  revert(string.concat((true ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded")), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")));
}
pragma solidity >= 0.0.0;
int208 constant cons0 = 185474768495391197447283211421986944945500737310541318021875684;
function f1(address i0) pure suffix  returns(bytes3 o0)
{
  return (false f4 /*suffix expr*/);
}
function f4(bool i0) pure suffix  returns(bytes3 o0)
{
  o0 = (false ? bytes3(0xffffff) : bytes3(0xffffff));
  assert(o0 == (false ? bytes3(0xffffff) : bytes3(0xffffff)));
}

==== Source: su1.sol ====
struct St1 {
  bytes23 el0;
  address payable el1;
}
contract C1 {
  bytes2   s2 = bytes2(0x0000);
  mapping(int16 => function (bytes memory, bool, uint48) internal  [])   s3;
  function (string memory, function (function (function () external   returns (uint192, function (uint240[] memory) external   returns (int48, function (bytes13, uint80, bytes memory) external   returns (function (address payable, uint72) external  , int160)))) external  , string memory) external  ) external  []   s4;

	function compareMemoryAndStorage(function (string memory, function (function (function () external   returns (uint192, function (uint240[] memory) external   returns (int48, function (bytes13, uint80, bytes memory) external   returns (function (address payable, uint72) external  , int160)))) external  , string memory) external  ) external  [] memory v1, function (string memory, function (function (function () external   returns (uint192, function (uint240[] memory) external   returns (int48, function (bytes13, uint80, bytes memory) external   returns (function (address payable, uint72) external  , int160)))) external  , string memory) external  ) external  [] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool   s5 = false;
  constructor(function (string memory, function (function (function () external   returns (uint192, function (uint240[] memory) external   returns (int48, function (bytes13, uint80, bytes memory) external   returns (function (address payable, uint72) external  , int160)))) external  , string memory) external  ) external  [] memory i0)   {
    s4 = i0;
    unchecked {
    }
  }
  error er0();
  error er1(bytes7[9] ep0, St1 ep1);
}
pragma solidity >= 0.0.0;
// ====
// ----
