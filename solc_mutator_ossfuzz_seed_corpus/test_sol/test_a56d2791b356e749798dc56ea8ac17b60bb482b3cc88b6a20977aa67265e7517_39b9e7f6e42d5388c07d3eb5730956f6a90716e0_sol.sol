
==== Source: su0.sol ====
function f0(bool i0,uint72 i1)     {
  if (i0)
  {
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  receive() external   payable
  {
    payable(this).transfer(3258861084554857473);
  }
  struct St0 {
    bool el0;
    function (address, uint240) external   returns (bytes memory) el1;
    address payable el2;
    bytes27 el3;
  }
  function f2(address i0,uint64 i1) public      {
    if (i1 != (uint64(0) & (((uint64(0) | uint64(0)) + uint64(2212094994787695256)) & uint64(18446744073709551615))))
    {
      if (i1 != ((((uint64(18446744073709551615) % uint64(524055112216270468)) - uint64(0)) + uint64(18446744073709551615)) >> uint192(uint192(0))))
      {
        delete i0;
      }
      else if (i0 < address(this))
      {
      }
      if (i0 >= msg.sender)
      {
        (bool l0) = payable(this).send(11402007229509307133);
      }
      else if (i0 != address(this))
      {
        (bool l1) = payable(this).send(14038411473979342824);
      }
    }
    else if (i1 <= (uint64(18446744073709551615) - (((uint64(18446744073709551615) - uint64(18446744073709551615)) % uint64(0)) & uint64(0))))
    {
      (bool l2, bytes memory l3) = payable(this).call{value: 4203510500139591211}("");
    }
    while (((int176(28075957520514679086808290432251221589479339605329556) != int176(47890485652059026823698344598447161988085597568237567)) ? false : false))
    {
      continue;
    }
  }
  fallback() external virtual  payable
  {
    this.f2({i0: address(this), i1: uint64(18446744073709551615)});
    (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSelector(this.f2.selector, address(this),uint64(18446744073709551615)));
  }
  C0.St0[]   s0;

	function compareMemoryAndStorage(C0.St0[] memory v1, C0.St0[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}  mapping(address => bool)   s1;
  C0.St0   s2;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}  constructor()   {
    s1[address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))] = false;
    unchecked {
    }
  }
  event ev0(address payable  ep0, address payable indexed ep1, bool  ep2);
  function f4(uint208 i0) public     returns(function (bytes18, bytes15[] memory) external   returns (bytes31) o0)  {
    return (o0);
  }
}
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C1 {
  event ev1();
  uint176   s3;
  constructor(uint176 i0)   {
    s3 >>= ((uint176(((((uint176(31637440710202256696437650711785824395253055817924584) | uint176(56739149036649019532778877512115287777752543174179796)) | uint176(95780971304118053647396689196894323976171195136475135)) + uint176(54038784113338247181148263318931384519426103196116543)) / uint176(95780971304118053647396689196894323976171195136475135))) ^ uint176(95780971304118053647396689196894323976171195136475135)) * uint176(38627966653264052680719126655772872222665695143297154));
    unchecked {
    }
  }
  receive() external   payable
  {
    return;
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  bytes27 el0;
  mapping(bool => uint224) el1;
  bool el2;
}
// ====
// ----
