==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  function (uint120, bool) external   returns (bytes32, int216) el0;
  int88 el1;
  bool el2;
  mapping(bytes22 => bool) el3;
}
library L0 {
  event ev0(address  ep0, uint40 indexed ep1, address  ep2) anonymous;
  function f0(bytes4 i0,function (function (bytes13, address payable) external   returns (bytes22, int24)) external   returns (bool[][][][] memory, uint224) i1) internal    returns(int128 o0)
  {
  }
}
contract C0 {
  fallback() external   
  {
    emit L0.ev0(address((bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) & bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)))), ((false ? uint40(773933165793) : uint40(495065044759)) & uint40(1099511627775)), address(this));
  }
  bytes10   s0;
  bool  public s1 = true;
  address payable   s2;
  uint32  public s3 = uint32(1185225535);
  constructor(bytes10 i0,address payable i1)   {
    s0 ^= (false ? (~((i0 |= bytes10(0x4ae6e9242f01b63391da)))) : ((bytes10(0xffffffffffffffffffff) ^ bytes10(0xffffffffffffffffffff)) & bytes10(0xffffffffffffffffffff)));
    s2 = payable(address(this));
    unchecked {
      bool  l0 = s1;
      bool  l1 = l0;
      assert(l1 == s1);
      uint32  l2 = s3;
      uint32  l3 = l2;
      assert(l3 == s3);
    }
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
}
contract C1 is C0 {
  using L0 for *;
  using L0 for *;
  address payable   s4 = payable(address(this));
  St0   s5;
  constructor(bytes10 i0,address payable i1)  C0(((true ? ((address(this) <= address(this)) ? bytes10(0xffffffffffffffffffff) : bytes10(0xffffffffffffffffffff)) : bytes10(0xffffffffffffffffffff)) ^ bytes10(0x00000000000000000000)), ((s5.el2 ? true : true) ? payable(address(bytes20(address(0x0000000000000000000000000000000000000000)))) : payable(address(this))))
  {
    s0 |= (false ? bytes10((false ? bytes("ffffffffe40850bbc2b6fe0cd6e4aa32a3a566e831962af2093ac9f7ef31d38e96") : bytes("e2ce91340d9f88d05d1c6301aac1abe29a4d45c3e71fc20c7786ec15ef"))) : bytes10(0x7abd68d30a08f3b58f57));
    s2 = (true ? payable(address(this)) : payable(address(this)));
    {
      address payable  l0 = s4;
      address payable  l1 = l0;
      assert(l1 == s4);
    }
  }
  event ev1(int256 indexed ep0, function (bytes30) external   returns (int112[8][] memory, uint224, int152)  ep1, bytes19 indexed ep2);
  using L0 for *;
}
using L0 for bytes4;
// ----
// Warning 5667: (su0.sol:882-900): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1460-1470): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1471-1489): Unused function parameter. Remove or comment out the variable name to silence this warning.
