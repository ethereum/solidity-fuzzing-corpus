==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  mapping(address => int72)   s0;
  uint248   s1 = uint248(0);
  int72  public s2 = int72(0);
  constructor() payable  {
    s0[address(this)] /= (((-(int56(36028797018963967))) ^ (int72(1821533434144004030033) % int72(2361183241434822606847))) & int72(2361183241434822606847));
    unchecked {
      int72  l0 = s2;
      int72  l1 = l0;
      assert(l1 == s2);
      (bool l2, bytes memory l3) = address(this).call((true ? bytes("771e4fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff") : bytes("6516b3038be0000000000000000000000000000000000000000000000000")));
    }
  }
}
struct St0 {
  function (bytes8[8] memory) external   returns (address, int184) el0;
  uint40 el1;
}
contract C1 {
  receive() external   payable
  {
    int240 l0 = ((false ? int240(-833091695380963951203873331940822267252613539584598455612963090268738221) : ((int240(883423532389192164791648750371459257913741948437809479060803100646309887) % int240(883423532389192164791648750371459257913741948437809479060803100646309887)) ^ int240(883423532389192164791648750371459257913741948437809479060803100646309887))) & int240(0));
    bytes4 l1 = bytes4(0xee21303a);
  }
  string   s3 = string("00000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffff");

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
}
library L0 {
  function f1() internal   
  {
    bytes7 l0 = (bytes7(bytes14(0x52432724a89356f394332b603dd0)) ^ bytes7(0xffffffffffffff));
    bool l1 = false;
    l0 &= (bytes7(0x00000000000000) & bytes7(0x446d7fdb8a2d31));
  }
  function f2(address payable i0,bytes13[][] memory i1) internal   
  {
    bytes32 l0 = bytes32((bytes7(0x97223174636a0f) & bytes7(0x00000000000000)));
    delete i1[uint256(((uint256(0) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))];
    i1[((uint256(0) ^ (((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) - uint256(0)) << uint72(uint72(0))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) * uint256(78326390418579502787957499589306872696657949656535025103152915180452087865808))] = new bytes13[](2);
    St0 memory l1;
    for(uint solinit0 = 0; solinit0 < ((false ? uint256(0) : uint256(48050634150735161109421746104561982203746188476453048534116301699473668206081)) % 11); solinit0++)
    {
    }
  }
  function f3(C0 i0,function (bytes24, int72, uint120) external   i1) public    returns(address o0)
  {
    function (int8, St0 memory) internal   returns (St0 memory, bytes memory, bool[][][][9][6][] memory) l0;
  }
}
using L0 for address payable;
// ----
// Warning 2072: (su0.sol:410-417): Unused local variable.
// Warning 2072: (su0.sol:419-434): Unused local variable.
// Warning 2072: (su0.sol:780-789): Unused local variable.
// Warning 2072: (su0.sol:1156-1165): Unused local variable.
// Warning 2072: (su0.sol:1610-1617): Unused local variable.
// Warning 5667: (su0.sol:1710-1728): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1772-1782): Unused local variable.
// Warning 2072: (su0.sol:2425-2438): Unused local variable.
// Warning 5667: (su0.sol:2638-2643): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2644-2692): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2712-2722): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2732-2835): Unused local variable.
// Warning 2018: (su0.sol:1482-1695): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:1698-2623): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:2626-2840): Function state mutability can be restricted to pure
