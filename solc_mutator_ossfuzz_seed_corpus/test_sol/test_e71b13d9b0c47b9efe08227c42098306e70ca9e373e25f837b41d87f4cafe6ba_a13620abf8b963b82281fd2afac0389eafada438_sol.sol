
==== Source: su0.sol ====
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
contract C0 {
  function f0() external virtual  payable  returns(bool o0,uint136 o1,string memory o2)  {
  }
  mapping(bool => uint144)  public s0;
  constructor()   {
    s0[0 f1 /*suffix expr*/] ^= (uint144((hex"000000000000000000000000000000000000000000000000000000000000" f2 /*suffix expr*/ / uint144(22300745198530623141535718272648361505980415))) | uint144(0));
    unchecked {
      if (false)
      {
        (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSelector(this.f0.selector));
        if (true)
        {
        }
      }
      else if (true)
      {
      }
    }
  }
  error er0();
  function f3(uint168 i0,int200 i1) public virtual     {
    return;
  }
  error er1(function () external   returns (bytes32, address payable, int56) ep0);
}
function f1(int24 i0) pure suffix  returns(bool o0)
{
}
function f2(bytes30 i0) pure suffix  returns(uint144 o0)
{
}
// ====
// ----
