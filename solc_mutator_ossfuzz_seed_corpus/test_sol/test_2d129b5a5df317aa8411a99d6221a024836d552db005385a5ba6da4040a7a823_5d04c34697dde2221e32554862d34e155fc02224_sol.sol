
==== Source: su0.sol ====
contract C0 {
  address  public s0 = address(this);
  receive() external   payable
  {
    address  l0 = s0;
    address  l1 = l0;
    assert(l1 == s0);
    address  l2 = s0;
    address  l3 = l2;
    assert(l3 == s0);
  }
}
library L0 {
  function f1(address i0,address payable i1) external   
  {
    bool l0 = ((int232(0) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)) <= (int232(3450873173395281893717377931138512726225554486085193277581262111899647) % int232(3450873173395281893717377931138512726225554486085193277581262111899647)));
    int256 l1 = int256(0);
  }
  function f2() external   
  {
    unchecked {
      assembly
      {
        {
          let al0 := staticcall(64884715368118499731587439074877275332584268010762684451684845271728853483850, 0, 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 75551813182743077693530864656252766585551424142348241225210122257520449369825)
        }
      }
      {
      }
      bool l0 = true;
      bool l1 = (true ? false : true);
      function () internal   returns (int152) l2;
      {
        uint200 l3 = (uint48(74484051637387) & uint200(725690416971143511657264787292192323072868498601880519471079));
        address payable l4 = payable(address(0x0000000000000000000000000000000000000001));
      }
      bytes30 l5 = bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
      return;
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
