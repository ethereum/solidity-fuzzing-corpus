
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    bool[][] memory l0 = (true ? new bool[][](3) : new bool[][](3));
    int200 l1 = int200(803469022129495137770981046170581301261101496891396417650687);
  }
  mapping(bytes2 => mapping(uint176 => int168))  public s0;
  int32 immutable  s1 = int32(0);
  constructor()   {
    unchecked {
      int32  l0 = s1;
      int32  l1 = l0;
      assert(l1 == s1);
      int32  l2 = s1;
      int32  l3 = l2;
      assert(l3 == s1);
      int32  l4 = s1;
      int32  l5 = l4;
      assert(l5 == s1);
      for(uint solinit0 = 0; solinit0 < (uint256((((((uint256(0) ^ uint256(0)) * uint256(75803896595431064385875103463655732504344684547790172004947676526518787445343)) | uint256(0)) % uint256(0)) / uint256(42885237593429666818065997601493675143806059835073615814824198972794631848549))) % 11); solinit0++)
      {
        int232 l6 = int232(2948551254042660486293989562163461238636089806352212171251092721220980);
        bool l7 = true;
        int32 l8 = ((((true ? int32(2147483647) : int32(2147483647)) * int32(0)) * int32(275905834)) & int32(2147483647));
      }
      revert(string("30ace67b53fd346b09a10ede75ffffff"));
    }
  }
  function f1(int32 i0,int32 i1) public    returns(int128[7][8] memory o0)
  {
    (o0[((uint184(24519928653854221733733552434404946937899825954937634815) * ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) * uint256(104508804565094597789253281758209378505623076777646969557527301556610453891011))]) = ([int128(25246972555379772910064576158568937475), int128(-7347774058245040201611166658852744572), int128(0), int128(170141183460469231731687303715884105727), int128(170141183460469231731687303715884105727), int128(164919288158837153261338924574275638307), int128(0)]);
    int32  l0 = s1;
    int32  l1 = l0;
    assert(l1 == s1);
    assembly
    {
      o0 := sload(0)
    }
  }
  receive() external   payable
  {
  }
}
library L0 {
  function f3(function (bool) external   returns (bool, bool[7][][][3][5][] memory) i0) public    returns(uint144 o0)
  {
    function (uint256) external   returns (int40, int216, uint256) l0;
    function (function (bytes24, bytes11, int24) external   returns (int208, bytes30), uint56) external   returns (address, int96, address) l1;
    string memory l2 = (true ? string("7bc67a93bb9a3631cec081d1a85823a473da5210bface8d1dbf7a1f694aa1e358aca2a87a2fc27c23368c4e8382fb68c") : (true ? string.concat(string("000000000000000000000000000000000000000000000000000000000000000000000000000000"), string("0000000000000000000000000000000000000000d567bf5e215f10d4798a5d2b45a879f9f871101d"), string("058b9f4a26dc742dabde347823c1249efc394517d0c563b49b85403ad1f1ff8dd765bfeb8c2e")) : string("0000000000000000000000000000009c84d2bc9688eed00b")));
  }
  event ev0(address payable  ep0, bytes14  ep1);
  function f4(int160 i0,address i1,bool i2) public   
  {
    address l0 = address(0x0000000000000000000000000000000000000006);
  }
}
using L0 for function (bool) external   returns (bool, bool[7][][][3][5][] memory);

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
