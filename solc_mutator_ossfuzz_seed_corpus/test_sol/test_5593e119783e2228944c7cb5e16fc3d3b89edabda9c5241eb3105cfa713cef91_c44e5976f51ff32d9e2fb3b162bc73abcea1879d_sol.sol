==== Source:  ====

==== Source: su0.sol ====
library L0 {
  modifier m0(string memory i0) 
  {
    _;
    function (bytes17, address payable) external   l0;
  }
  function f0(bool i0) public    returns(bytes17 o0)
  {
    uint184 l0 = uint184(0);
    uint200 l1 = (((((false ? uint200(1606938044258990275541962092341162602522202993782792835301375) : uint200(793983243338358767261407492620689356007533648916870686631408)) * uint200(1606938044258990275541962092341162602522202993782792835301375)) + uint200(0)) ^ uint200(1606938044258990275541962092341162602522202993782792835301375)) + uint200(1606938044258990275541962092341162602522202993782792835301375));
  }
  function f1() external  m0(string("ffffffffffffffffffffffffffffffffffffffffffffffffffff6f5026ecbc2de8")) 
  {
    function (address payable, int32, uint32) external   returns (bool, uint224) l0;
  }
}
contract C0 {
  bool  public s0;
  address immutable  s1 = address(this);
  bytes30   s2;
  int120   s3;
  constructor(bool i0,bytes30 i1,int120 i2) payable  {
    s0 = (int216(((int216(0) - int216(51589884770622703199925221640758535253605805633928711643104007866)) / (int216(52656145834278593348959013841835216159447547700274555627155488767) ^ int216(52656145834278593348959013841835216159447547700274555627155488767)))) == int216(-1177548902728940657695953079961826924672276892615616643705640904));
    s2 &= bytes30(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    s3 |= int120(-1391149318772856005803679222378353);
    unchecked {
      {
        bool  l0 = s0;
        bool  l1 = l0;
        assert(l1 == s0);
        {
          revert(string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
        }
      }
      s2 = bytes30(0x000000000000000000000000000000000000000000000000000000000000);
      assert(s2 == bytes30(0x000000000000000000000000000000000000000000000000000000000000));
      bytes30  l2 = s2;
      bytes30  l3 = l2;
      assert(l3 == s2);
      bool  l4 = s0;
      bool  l5 = l4;
      assert(l5 == s0);
      bool  l6 = s0;
      bool  l7 = l6;
      assert(l7 == s0);
    }
  }
  using L0 for *;
  using L0 for *;
  fallback() external   payable
  {
  }
  using L0 for *;
}
using L0 for bool;
pragma solidity >= 0.0.0;
using L0 for bool;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:820-2215): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5740: (su0.sol:1735-1904): Unreachable code.
// Warning 5740: (su0.sol:1912-1976): Unreachable code.
// Warning 5740: (su0.sol:1984-2042): Unreachable code.
// Warning 5740: (su0.sol:2050-2108): Unreachable code.
// Warning 5667: (su0.sol:130-137): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:157-167): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:177-187): Unused local variable.
// Warning 2072: (su0.sol:206-216): Unused local variable.
// Warning 2072: (su0.sol:733-812): Unused local variable.
// Warning 5667: (su0.sol:939-946): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:947-957): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:958-967): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:118-616): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:619-817): Function state mutability can be restricted to pure
