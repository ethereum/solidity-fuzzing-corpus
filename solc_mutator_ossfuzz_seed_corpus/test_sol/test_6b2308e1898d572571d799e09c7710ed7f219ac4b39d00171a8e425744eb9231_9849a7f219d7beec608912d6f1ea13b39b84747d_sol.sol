
==== Source: su0.sol ====
bytes23 constant cons0 = bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff);
contract C0 {
  event ev0();
  struct St0 {
    int56 el0;
    mapping(uint16 => address) el1;
    int104 el2;
    int128 el3;
  }
  mapping(address => int112)   s0;
  bytes18  public s1;
  constructor(bytes18 i0)   {
    s1 &= bytes18(0xffffffffffffffffffffffffffffffffffff);
    s0[address(this)] += int112(2596148429267413814265248164610047);
    {
    }
  }
  function f0() external   
  {
  }
  address public constant cons1 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
  fallback() external   
  {
    try this.f0()
    {
      0;
    }
    catch
    {
    }
    catch Panic(uint256 l0)
    {
    }
    this.f0();
    for(;
false;
bytes13(0x00000000000000000000000000))
    {
      (bool l1, bytes memory l2) = address(this).call(bytes("7554243cc5b70000000000000000000000000000000000000000000000000000000000000000"));
      continue;
    }
  }
  error er0();
}
pragma solidity >= 0.0.0;
struct St1 {
  address el0;
  bytes20 el1;
  uint216 el2;
}
contract C1 {
  uint128   s2 = uint128(3147459114179300884322045030828826034);
  C0   s3 = C0(address(this));
  mapping(bool => bytes13)   s4;
  address   s5;
  constructor(address i0) payable  {
    s5 = address(this);
    s4[false] ^= bytes13(0xffffffffffffffffffffffffff);
    unchecked {
      if (true)
      {
      }
      else if (true)
      {
      }
    }
  }
  modifier m0() 
  {
    (bool l0, bytes memory l1) = address(this).call("000000000000000000000000000000000000000000000000000000");
    _;
  }
  modifier m1() virtual
  {
    _;
  }
  function f2() internal virtual m0() 
  {
    address payable l0 = payable(address(this));
    if (false)
    {
    }
    else
    {
      do
      {
        unchecked {
          uint72 l1 = uint72(((uint72(0) | uint72(0)) / ((~(uint72(4722366482869645213695))) % uint72(2353204179965693604129))));
          s2 >>= uint128(173690487612920795087881069759312461537);
          {
            (bool l2, bytes memory l3) = address(this).call(bytes("ed55a2a2b206677b91c492464b40c153485f9183f8bd0ff5e688dd68a07682caf5e51948c4cf"));
          }
          require((bytes8(0x0000000000000000) <= bytes8(0x0000000000000000)), "00b8a9caa25d7d267858de6dd999ca1caab58a36c4e701063eba12c77e5fd0c291");
          continue;
        }
        continue;
      }
      while (false);
      if (true)
      {
      }
      else if (true)
      {
        for(        bool l4 = false;
true;
bytes16(0x00000000000000000000000000000000))
        {
        }
      }
      else if ((true && (false || ((true != true) && true))))
      {
      }
    }
    if ((int88(154742504910672534362390527) >= int88(0)))
    {
    }
    else if ((bytes5(0xbd3bcc1586) != bytes5(0xcd7c85f919)))
    {
    }
    else if ((false && (int112(1051256753580320544929593544367733) > int112(0))))
    {
      { }
      revert C0.er0();
    }
    for(    bytes9 l5 = bytes9(0x68eb74e841623a9c32);
;
(true ? true : false))
    {
      return;
    }
  }
  error er1(C0[2] ep0, uint200 ep1);
  bytes12 public constant cons2 = bytes12(0xffffffffffffffffffffffff);
  function f3(uint64 i0) external  m1()  returns(address o0)
  {
  }
  event ev1(bool indexed ep0, int40  ep1);
}
library L0 {
  bytes6 public constant cons3 = bytes6(0xffffffffffff);
  event ev2(string  ep0, C0 indexed ep1, bytes27[2][1]  ep2);
  error er2(address payable ep0);
  function f4() external   
  {
  }
  event ev3(address payable  ep0, C0  ep1, function () external   indexed ep2, uint256  ep3);
  error er3(function (int40, bytes[] memory, address payable) external   ep0, address ep1);
}
error er4();
function f5(bool i0,bytes2 i1)     returns(bytes1 o0,function (St1 memory, address payable) external   o1)
{
}
using L0 for uint;

==== Source: su1.sol ====
struct St2 {
  bytes11 el0;
}
pragma solidity >= 0.0.0;
type T0 is uint80;
// ====
// ----
