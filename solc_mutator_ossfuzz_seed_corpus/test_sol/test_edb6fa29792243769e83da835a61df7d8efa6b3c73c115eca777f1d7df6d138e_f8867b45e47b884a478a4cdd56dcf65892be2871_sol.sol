
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(function () external   i0)      returns(int96 o0){
  if (false)
  {
    try i0()
    {
      return (int40(0));
    }
    catch
    {
    }
  }
}
function f1(int168[1] memory i0,address i1,uint96 i2)     {
  if (i2 > uint96(79228162514264337593543950335))
  {
    function (bytes7, int176) internal   returns (address payable) l0;
  }
  else
  {
    if (i2 == uint96(50312315658032899624667388643))
    {
      if (i1 == address(bytes20(bytes19(0x2f0bbd432abebf8d70bca12fd3812193fa7c83))))
      {
        if (i0.length != ((uint256(0) >> uint120((uint120(((uint120(1329227995784915872903807060280344575) * uint120(1329227995784915872903807060280344575)) / uint120(1329227995784915872903807060280344575))) & uint120(0)))) & uint256(0)))
        {
          if (i1 != address(0x0000000000000000000000000000000000000001))
          {
          }
        }
      }
    }
    else if (i1 == address(0x0000000000000000000000000000000000000005))
    {
    }
  }
}

==== Source: su1.sol ====
contract C0 {
  function f2(int24 i0) public     returns(uint240 o0)  {
    if (i0 > int24(8388607))
    {
    }
    o0 %= uint240(1766847064778384329583297500742918515827483896875618958121606201292619775);
  }
  type T0 is bytes18;
  address payable   s0 = payable(address(this));
  bytes6[]  public s1;

	function compareMemoryAndStorage(bytes6[] memory v1, bytes6[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  uint144[10]   s2 = [uint144(22300745198530623141535718272648361505980415), uint144(0), uint144(21703397775112892616211151364449292701507882), uint144(7798531231761453661234291478197311808287760), uint144(0), uint144(0), uint144(0), uint144(22300745198530623141535718272648361505980415), uint144(7852816535889669821594926775949848692685841), uint144(834030719188585416927225613550149412170298)];

	function compareMemoryAndStorage(uint144[10] memory v1, uint144[10] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(bytes6[] memory i0)   {
    s1 = i0;
    unchecked {
      while (false)
      {
        continue;
      }
    }
  }
  receive() external   payable
  {
    return;
  }
}
error er0(bytes9 ep0, bool ep1);
error er1(bytes27 ep0);
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
