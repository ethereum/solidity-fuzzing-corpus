
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
bool constant cons0 = false;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  error er0();
  uint216  public s0 = uint216(95924036072637642129195070025862830459049299694762687463906777720);
  int168   s1 = int168(0);
  event ev0();
  fallback() external virtual  payable
  {
  }
  function f1() public      {
  }
}
contract C1 {
  address   s2;
  mapping(uint256 => int8)   s3;
  address payable   s4 = payable(address(this));
  constructor(address i0) payable  {
    s2 = address(this);
    s3[(((uint256(6775810549012975603917742780962128231488038322461394176556952300120009830326) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) << uint232(uint232(0))) & uint256(35854424950322317895836304167292776307500979528242124362319369061523575684660))] |= (-((int8(0) - (int8(0) * int8(127)))));
    unchecked {
      (false ? bytes22(0x4e12d589e47dfa84875b8e5de4745088346ce0a3e755) : bytes22(0xffffffffffffffffffffffffffffffffffffffffffff));
    }
  }
  function f2(bool i0,address payable i1) public     returns(address o0,function (address payable, bool, bool) external   o1,bytes31 o2)  {
    address payable  l0 = s4;
    address payable  l1 = l0;
    assert(l1 == s4);
  }
  receive() external virtual  payable
  {
  }
  struct St0 {
    mapping(address => bytes24) el0;
    address el1;
    C0 el2;
    int168 el3;
  }
  int48 public constant cons1 = 140737488355327;
  fallback() external virtual  
  {
    revert C0.er0();
  }
}
contract C2 is C1 {
  type T0 is uint40;
  type T1 is int112;
  bool  public s5 = true;
  int32   s6;
  bool immutable public s7;
  constructor(address i0,int32 i1,bool i2)  C1(address(this))
  {
    s2 = address(this);
    s6 = (int32((int32(2147483647) / ((int32(-1632076811) | int32(0)) - int32(1910577068)))) * int32(2147483647));
    s7 = false;
    s3[uint256(46226752958963796941582322263648148942683978694450429882107155025758518865859)] %= int8((int8(int240(0)) / ((int8(-70) % int8(127)) - int8(127))));
    unchecked {
      payable(this).transfer(0);
    }
  }
  function f5(address i0,int32 i1,bool i2) private      {
    if (i0 != address(this))
    {
      (s5) = (true);
      assert(s5 == true);
      require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    else if (i0 < address(this))
    {
      bool  l0 = s7;
      bool  l1 = l0;
      assert(l1 == s7);
    }
    return;
  }
  fallback() external override  
  {
    if (false)
    {
      for(;
;
C1(payable(address(this))))
      {
        continue;
      }
    }
    require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
    if (true)
    {
      if (true)
      {
        do
        {
          break;
        }
        while (false);
      }
    }
    else
    {
    }
  }
  receive() external virtual override  payable
  {
  }
}
// ====
// ----
