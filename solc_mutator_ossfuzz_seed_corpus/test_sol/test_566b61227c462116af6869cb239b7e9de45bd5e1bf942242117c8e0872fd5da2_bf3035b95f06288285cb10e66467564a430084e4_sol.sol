
==== Source: su0.sol ====
contract C0 {
  bytes6   s0 = bytes6(0x000000000000);
  int128   s1;
  constructor(int128 i0)   {
    s1 *= (int128((int128(0) / int128((int128(0) / (int128(170141183460469231731687303715884105727) | int128(170141183460469231731687303715884105727)))))) ^ int128(170141183460469231731687303715884105727));
    {
    }
  }
  struct St0 {
    address el0;
    mapping(int168 => address) el1;
    bool el2;
    mapping(uint96 => bool)[] el3;
  }
  function f0(int128 i0) external   payable  returns(bool o0,bytes6 o1)  {
    try this.f0({i0: ((((int128(66052216509511102073881325641100235227) + int128(0)) * int128(48919553769863329431454201229958915214)) % int128(170141183460469231731687303715884105727)) % int128(0))}) returns (bool l0, bytes6 l1)
    {
      (bool l2, bytes memory l3) = address(this).call(abi.encodeCall(this.f0, ((-((((~((~(int128(170141183460469231731687303715884105727))))) ^ int128(-23283869439034534421620844112369556980)) ** uint88(uint88(136699191684932181620790013))))))));
      assert(false);
    }
    catch
    {
      if (i0 > (-(int128(0))))
      {
        for(        payable(address(this));
false;
)
        {
          try this.f0((-(((o0 ? int128(0) : int128(0)) + int128(0))))) returns (bool l4, bytes6 l5)
          {
          }
          catch
          {
            while ((uint16(65535) >= uint16(0)))
            {
              continue;
            }
          }
          catch Panic(uint256 l6)
          {
            break;
          }
        }
      }
      else
      {
      }
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St1 {
  function (address, bytes17) external   returns (bool, uint88) el0;
}
struct St2 {
  St1 el0;
  address el1;
  int176 el2;
}
error er0(bytes19 ep0, uint40 ep1);
pragma solidity >= 0.0.0;
// ====
// ----
