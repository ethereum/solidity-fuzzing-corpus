
==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
    while (true)
    {
      if (true f1 /*suffix expr*/)
      {
        (((uint256(0) - (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(66776949101984717131858294228885894873364788715070307238538768099634964897921))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(28153568520935704161940323880973875532360036446839062619126836372052128421901));
        do
        {
          continue;
        }
        while (((((int136(((int136(525507828927886189032681997842492779959) - int136(0)) / int136(0))) + int136(43556142965880123323311949751266331066367)) - int136(-26076408430157685898721359234503410439284)) & int136(0)) < int136(0)));
      }
      break;
    }
  }
  event ev0(uint224  ep0, address payable  ep1, address payable  ep2);
  fallback() external   
  {
  }
  function f3() public virtual    returns(address payable o0,bytes memory o1)  {
  }
  address immutable public s0;
  address payable  public s1;
  int192[7]   s2 = [int192(0), int192(0), int192(2094602477502063500149718122218835075324772963515092159812), int192(-1440109761328367985473773979456577870433000166037574141319), int192(-2798783644488462688191282022079333500108587890019795302422), int192(0), int192(3138550867693340381917894711603833208051177722232017256447)];

	function compareMemoryAndStorage(int192[7] memory v1, int192[7] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bytes26   s3;
  constructor(address i0,address payable i1,bytes26 i2) payable  {
    s0 = address(this);
    s1 = payable(address(this));
    s3 &= (bytes26((~(bytes21(0x000000000000000000000000000000000000000000)))) | (~(i2)));
    unchecked {
    }
  }
}
address constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
struct St0 {
  bool el0;
  bytes21 el1;
  int216 el2;
  int160 el3;
}
contract C1 {
  event ev1(address payable[] indexed ep0, bytes26  ep1, bytes  ep2);
  bool immutable  s4;
  bytes4[]  public s5 = [bytes4(0x00000000), bytes4(0xffffffff), bytes4(0x00000000), bytes4(0xf900dd89)];

	function compareMemoryAndStorage(bytes4[] memory v1, bytes4[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(bool i0)   {
    s4 = (uint168(2601620921004039017690821105064239488286662979777) == uint168(145032146522900503057408039322859865201786031604141));
    {
    }
  }
}
pragma solidity >= 0.0.0;
function f1(bool i0) pure suffix  returns(bool o0)
{
  for(uint solinit0 = 0; solinit0 < (((uint120(0) | ((uint120(630500840206226236396265241262357204) >> uint64(uint64(0))) ^ uint120(1329227995784915872903807060280344575))) ^ uint256(0)) % 11); solinit0++)
  {
    continue;
  }
  while (true)
  {
    (o0, o0) = ((true f4 /*suffix expr*/ >= (((int16(18786) & int16(32767)) | int16(32767)) & int16(-31691))), (address(bytes20(address(0x2cD44895aeBae3C540270D1EC81F6f86aFDF546f))) != address(0x0000000000000000000000000000000000000006)));
    assert(o0 == (true f4 /*suffix expr*/ >= (((int16(18786) & int16(32767)) | int16(32767)) & int16(-31691))));
    assert(o0 == (address(bytes20(address(0x2cD44895aeBae3C540270D1EC81F6f86aFDF546f))) != address(0x0000000000000000000000000000000000000006)));
  }
}
function f4(bool i0) pure suffix  returns(int96 o0)
{
  C0 l0 = C0(payable(address(0x0000000000000000000000000000000000000004)));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
