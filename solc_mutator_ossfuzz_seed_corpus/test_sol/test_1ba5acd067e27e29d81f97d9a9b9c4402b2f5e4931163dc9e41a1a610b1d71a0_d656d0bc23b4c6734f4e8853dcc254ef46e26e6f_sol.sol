
==== Source: su0.sol ====
type T0 is address payable;
pragma solidity >= 0.0.0;
library L0 {
  modifier m0(T0 i0) 
  {
    _;
  }
  event ev0(bool  ep0, function (uint136) external   indexed ep1);
  bytes22 public constant cons0 = ((((bytes22(0xffffffffffffffffffffffffffffffffffffffffffff) & bytes22(0x34b15c836bdc63d6ba11ee61f9b7be922c54bada0f0a)) | bytes22(0x3d686874afdc78093b420bf4ee496fc5cfce38193f43)) ^ bytes22(0xffffffffffffffffffffffffffffffffffffffffffff)) ^ bytes22(0x00000000000000000000000000000000000000000000));
  error er0(int144 ep0);
  type T1 is int176;
  modifier m1(bytes28 i0) 
  {
    revert er0((((((int144(-669322669281971732288267124002246140384979) * int144(11150372599265311570767859136324180752990207)) & int144(0)) % int144(0)) | int144(11150372599265311570767859136324180752990207)) | int144(-10709100656600676333363788236078762876173091)));
    revert L0.er0((int144(0) * int144(1293664209986231563288459669437144976517685)));
    _;
  }
  error er1(bool ep0);
  event ev1(bytes  ep0, int112  ep1);
}
struct St0 {
  bool el0;
  bytes14 el1;
  function (bool, address) external   returns (bytes1, int88, int120) el2;
  int120 el3;
}
uint8 constant cons1 = (((((uint8(65) - uint8(255)) + uint8(0)) * uint8(255)) & uint8(128)) ** uint128(uint128(0)));
contract C0 {
  modifier m2() 
  {
    int216 l0 = ((int216(34993604433047510652578618626179905436722328383243114512701998612) ^ int216(42793828851892624218946099536534186858596821754449896519694258151)) ** uint192(uint192(4680480506229980895977747887784003469520561390703553727399)));
    _;
    delete l0;
  }
  function f0(int192 i0,string[] calldata i1) public  m2() payable
  {
    unchecked {
      require(true, i1[0]);
    }
  }
  error er2(function () external   returns (bool, St0 memory) ep0, address payable ep1);
  L0.T1 public constant cons2 = L0.T1.wrap(int176(0));
  uint16  public s0 = uint16(8264);
  bytes6 immutable  s1 = bytes6(0xff1af4a8415f);
  bytes6   s2;
  T0  public s3 = T0.wrap(payable(address(0x0000000000000000000000000000000000000006)));
  constructor(bytes6 i0)   {
    s2 |= bytes6(0x000000000000);
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 17290323598258526348}("");
      if (false)
      {
      }
      else if (true)
      {
        bool l2 = true;
      }
      else if (true)
      {
        do
        {
          if (((int112(0) ^ (int112(2596148429267413814265248164610047) | (int112(359914059295770079260584898544172) + int112(-195765638192549489586618361935934)))) > int112(2596148429267413814265248164610047)))
          {
            St0 memory l3;
            (s3) = (T0.wrap(payable(address(0x0000000000000000000000000000000000000007))));
          }
        }
        while (true);
      }
      (bool l4, bytes memory l5) = payable(this).call{value: 14932476043567685558}("");
    }
  }
  modifier m3() 
  {
    L0.T1 l0 = L0.T1.wrap(int176(36423282862480310747218685869312849131060203949075770));
    _;
  }
  using L0 for *;
  receive() external   payable
  {
    revert L0.er0(((int144(-7911305064667978046766498586041043630426015) | (int144(10735070663262147807541298995327686602486592) * int144(0))) & int144(6985698491003673625977753126303526860573885)));
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105
  }
  function f2() external   payable returns(L0.T1 o0,int48 o1)
  {
  }
}
// ====
// ----
