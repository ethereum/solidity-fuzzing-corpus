
==== Source: su0.sol ====
library L0 {
  function f0(function (bytes31, function (bool, uint24) external   returns (address payable)) external   returns (uint120[][1][] memory, bytes memory, address payable) i0) public    returns(uint176 o0)
  {
  }
  function f1() internal   
  {
    uint40 l0 = ((uint40((uint40((uint40(1099511627775) / (uint40(0) * uint40(1099511627775)))) / uint40(1090661089613))) & uint40(113786674021)) ^ uint40(0));
  }
}
using L0 for function (bytes31, function (bool, uint24) external   returns (address payable)) external   returns (uint120[][1][] memory, bytes memory, address payable);
pragma solidity >= 0.0.0;
contract C0 {
  using L0 for *;
  using L0 for *;
  int240[9][][2]   s0;

	function compareMemoryAndStorage(int240[9][][2] memory v1, int240[9][][2] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int240[9][] memory v1, int240[9][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int240[9] memory v1, int240[9] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  address payable  public s1 = payable(address(this));
  int144   s2;
  mapping(int192 => bool[8])   s3;
  constructor(int240[9][][2] memory i0,int144 i1)   {
    s0 = i0;
    s2 %= (int144(-7580048895979608118007344434713765688934574) % int144((int144((int144(11150372599265311570767859136324180752990207) / (int144(11150372599265311570767859136324180752990207) - int144(11150372599265311570767859136324180752990207)))) / int144(0))));
    unchecked {
      address payable  l0 = s1;
      address payable  l1 = l0;
      assert(l1 == s1);
      int240[9][][2] memory l2 = s0;
      int240[9][][2] memory l3 = l2;
      assert(compareMemoryAndStorage(l3, s0));
      s2 &= int144(11150372599265311570767859136324180752990207);
    }
  }
  fallback() external virtual  payable
  {
    s0[uint256(((false ? ((uint80(1208925819614629174706175) & uint80(1208925819614629174706175)) * uint80(1208925819614629174706175)) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(34741783369374962720783639541310078649146815648917969036163145617577263055442)))] = s0[(uint256((uint256(uint64(0)) / uint256(4588399363282626150550646720476200489048984263588400329178522200385817947561))) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))];
    address payable  l0 = s1;
    address payable  l1 = l0;
    assert(l1 == s1);
  }
}
// ====
// ----
