
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int72 el0;
  address payable el1;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(uint200 i0,int192 i1) external    returns(function (address payable, address payable) external   returns (int248, int104, int80) o0)
  {
    return (o0);
  }
  error er0(uint128 ep0);
  bytes17   s0;
  bool  public s1;
  uint96   s2;
  address  public s3;
  constructor(bytes17 i0,bool i1,uint96 i2,address i3)   {
    s0 |= bytes6((bytes5(0x0000000000) ^ bytes5(0x0000000000)));
    s1 = (bytes31(0x115c75efe0c3364ceca8508484a39cf45632ad5de01248bf29bb3c9c616bb2) == bytes31(((bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & bytes31(0x00000000000000000000000000000000000000000000000000000000000000)) ^ bytes31(0x00000000000000000000000000000000000000000000000000000000000000))));
    s2 -= uint96(0);
    s3 = address(this);
    unchecked {
      uint96  l0 = s2;
      uint96  l1 = l0;
      assert(l1 == s2);
      uint96  l2 = s2;
      uint96  l3 = l2;
      assert(l3 == s2);
      address  l4 = s3;
      address  l5 = l4;
      assert(l5 == s3);
      bytes17  l6 = s0;
      bytes17  l7 = l6;
      assert(l7 == s0);
    }
  }
  receive() external virtual  payable
  {
    {
      revert er0(uint128(340282366920938463463374607431768211455));
    }
  }
}
// ====
// ----
