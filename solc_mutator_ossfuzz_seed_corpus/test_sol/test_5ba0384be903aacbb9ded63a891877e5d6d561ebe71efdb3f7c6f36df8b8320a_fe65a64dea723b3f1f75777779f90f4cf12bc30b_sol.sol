
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(int56  ep0, function () external   returns (bytes26, uint104, bool)  ep1);
  uint8  public s0 = uint8(0);
  fallback() external   
  {
    uint8  l0 = s0;
    uint8  l1 = l0;
    assert(l1 == s0);
    (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
  }
  receive() external   payable
  {
  }
}
function f2(bytes27 i0,function () external   returns (uint32, address payable, address payable) i1)     returns(uint224 o0,address o1)
{
  assembly
  {
  }
}
contract C1 {
  int224   s1 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
  uint208  public s2;
  bytes13  public s3 = bytes13(0x80b11ddb55b4365146a7e245f8);
  uint168   s4 = uint168(0);
  constructor(uint208 i0) payable  {
    s2 %= ((true ? uint208(411376139330301510538742295639337626245683966408394965837152255) : ((uint208(0) ^ uint208(0)) << uint200(uint200(1606938044258990275541962092341162602522202993782792835301375)))) + uint208(411376139330301510538742295639337626245683966408394965837152255));
    {
      uint208  l0 = s2;
      uint208  l1 = l0;
      assert(l1 == s2);
      uint208  l2 = s2;
      uint208  l3 = l2;
      assert(l3 == s2);
      bytes13  l4 = s3;
      bytes13  l5 = l4;
      assert(l5 == s3);
    }
  }
  receive() external   payable
  {
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f4(bool i0,int96 i1)    
{
  (i0) = (true);
  assert(i0 == true);
  revert(string("000000000000000000000000000000000000000000000000000000000000000000000000000000"));
}
// ====
// ----
