
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(int192 ep0);
struct St0 {
  mapping(bytes32 => address) el0;
  uint128 el1;
}
address payable constant cons0 = payable(0x0000000000000000000000000000000000000000);
contract C0 {
  modifier m0(bytes memory i0) virtual
  {
    _;
  }
  error er1(address payable ep0, string ep1);
  uint24  public s0;
  constructor(uint24 i0)   {
    s0 &= (uint24(13160929) ** uint144((((uint144(4440347580453341267564749374201240274562851) * uint144(15311531530496167881294224045286709998829865)) | uint144(22300745198530623141535718272648361505980415)) << uint112(uint112(5192296858534827628530496329220095)))));
    unchecked {
      {
        (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffffffffffffdb5d9f527f01773c86c43dea04dbb063244b0a12ffdd8f39a2158cb9a8");
        revert("2039319d37d968f0e33d69000000000000000000000000000000000000");
        int168 l2 = (((int168(0) & (int168(0) ** uint160(uint160(0)))) ** uint144(uint144(155804854297972139880931233626877191978086))) | int168(0));
      }
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17
  }
  function f0() public  m0("ffffffffffffffffffffffff57530cba4b5f0ba5914055496644eeafc55fa09af558fb806f83ef92")  returns(function (address, int200) external   returns (C0.EN0, C0.EN0, uint184) o0)
  {
    return (o0);
  }
  struct St1 {
    address payable el0;
    address payable el1;
    C0.EN0 el2;
  }
  type T0 is address payable;
}
function f1(uint144 i0)    
{
}
// ====
// ----
