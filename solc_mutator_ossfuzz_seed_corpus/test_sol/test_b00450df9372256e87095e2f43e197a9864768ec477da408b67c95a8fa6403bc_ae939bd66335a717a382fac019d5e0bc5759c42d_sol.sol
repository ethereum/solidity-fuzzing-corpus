==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  int136   s0 = int136(0);
  uint184   s1;
  int160[][]   s2 = [[int160(730750818665451459101842416358141509827966271487), int160(730750818665451459101842416358141509827966271487), int160(657088549820864325914534096465118899368029165127), int160(730750818665451459101842416358141509827966271487), int160(465753030155111318247174404253473675259838308388)], [int160(730750818665451459101842416358141509827966271487), int160(0), int160(229844005572555159055165159739885890959674905560), int160(-6909433962813887405166355638002219689755707502), int160(-38475676183963324373761405585343948305099909116)], [int160(730750818665451459101842416358141509827966271487), int160(730750818665451459101842416358141509827966271487), int160(-646839730930345250414745129432701977112745619473), int160(-592676989377624327772489068444297730037369228371), int160(45275565338952670846775864312978558553273620539)]];

	function compareMemoryAndStorage(int160[][] memory v1, int160[][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int160[] memory v1, int160[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(uint184 i0)   {
    s1 |= (((uint184(24519928653854221733733552434404946937899825954937634815) | uint184(20245916953889723635855235754226067472309669770236527467)) % (uint184(0) | uint184(24519928653854221733733552434404946937899825954937634815))) - uint184(24519928653854221733733552434404946937899825954937634815));
    {
      s2.push();
      (bool l0, bytes memory l1) = address(this).call(bytes("00f569dd38250364dec9c791da4cdc0db6243cf30f3f4f8e89a8"));
      delete s1;
      int136  l2 = s0;
      int136  l3 = l2;
      assert(l3 == s0);
      (s0, s2, s1, s1) = (((~((~(int136(43556142965880123323311949751266331066367))))) & int136(((int136(43556142965880123323311949751266331066367) % int136(0)) / int136(43556142965880123323311949751266331066367)))), [[int160(0), int160(0), int160(730750818665451459101842416358141509827966271487), int160(-418446495826060165862207646516653746311236444414), int160(674394483084808169087998153873661096937554646391)], [int160(0), int160(730750818665451459101842416358141509827966271487), int160(730750818665451459101842416358141509827966271487), int160(194152138254806289869001317163750231104337118601), int160(-357392787727004285479049969456375879542748018112)], [int160(0), int160(0), int160(730750818665451459101842416358141509827966271487), int160(730750818665451459101842416358141509827966271487), int160(510517932952989970887966360340881261687104193692)]], (uint184((uint184(0) / uint184(5605197246199514233717330736065398454770047680757812313))) | (uint96(79228162514264337593543950335) * uint184(0))), uint184(0));
      assert(s0 == ((~((~(int136(43556142965880123323311949751266331066367))))) & int136(((int136(43556142965880123323311949751266331066367) % int136(0)) / int136(43556142965880123323311949751266331066367)))));
      assert(s1 == (uint184((uint184(0) / uint184(5605197246199514233717330736065398454770047680757812313))) | (uint96(79228162514264337593543950335) * uint184(0))));
      assert(s1 == uint184(0));
    }
  }
  fallback() external   
  {
    assert(false);
    int160[][] memory l0 = s2;
    int160[][] memory l1 = l0;
    assert(compareMemoryAndStorage(l1, s2));
  }
}
pragma solidity >= 0.0.0;
uint248 constant cons0 = 0;
// ----
// Warning 5667: (su0.sol:1448-1458): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1796-1803): Unused local variable.
// Warning 2072: (su0.sol:1805-1820): Unused local variable.
// Warning 2018: (su0.sol:1187-1433): Function state mutability can be restricted to view
