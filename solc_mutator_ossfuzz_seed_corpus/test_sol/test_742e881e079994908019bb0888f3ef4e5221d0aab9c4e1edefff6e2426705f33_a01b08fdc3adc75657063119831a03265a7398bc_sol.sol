
==== Source: su0.sol ====
error er0(bytes ep0, address payable ep1);
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52
}
struct St0 {
  mapping(int200 => int168) el0;
  bytes3 el1;
}
contract C0 {
  error er1(function (uint224[] memory, function (function (bool) external   returns (function (int200) external   returns (bool), uint80, address), address) external   returns (int128, int32)) external   returns (uint56, function () external   returns (int56, bytes16, function (int24, int216, address) external   returns (uint168, bytes16, int88)), uint128) ep0);
  bytes20  public s0;
  St0[][1]   s1;
  constructor(bytes20 i0)   {
    s0 &= ripemd160("9604e237153788870854cf68742e8e4271d00e5bf49236ac9aac1fce0bada8");
    {
      assert((false || (true && ((uint152(0) << uint168(uint168(0))) != uint152(5708990770823839524233143877797980545530986495)))));
      if ((true || ((int200(((int200(-447032487100844806593507921488307705267571496270434495006112) ** uint184(uint184(0))) / int200(-585027780515136471976132228795289550732965788404585215596712))) > int200(676760747271522952544058065414923688201070393907578851710177)) ? false : false)))
      {
        if (true)
        {
          function (bytes10, bytes3) external   returns (int112) l0;
        }
        else if (((((uint24(16006046) + uint24((uint24(16777215) / uint24(0)))) | uint24(13863817)) * uint24(0)) != uint24(16777215)))
        {
        }
        else
        {
          (bool l1, bytes memory l2) = payable(this).call{value: 4940949500135502906}("");
        }
      }
    }
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67
  }
  receive() external   payable
  {
    bool l0 = (!(false));
  }
  fallback() external virtual  
  {
    if (false)
    {
    }
    else if (true)
    {
    }
    else
    {
      for(      int96 l0 = ((int96(0) % (((int96(39614081257132168796771975167) * int96(-37179191421526471962742301914)) ^ int96(34716095012352802659009591476)) ^ int96(39614081257132168796771975167))) | int96(0));
;
)
      {
        continue;
        assembly
        {
        }
      }
    }
    (bool l1, bytes memory l2) = payable(this).call{value: 4753609872862347532}("");
    if ((true || false))
    {
      payable(this).transfer(11128529338326116350);
    }
  }
  event ev0(address  ep0, bytes  ep1, bool  ep2);
  function f2() public virtual   returns(int208 o0,address payable o1,bytes30 o2)
  {
    if (false)
    {
    }
    else if (false)
    {
    }
    emit ev0(address(this), "000000000000000000000000000000000000000000000000", false);
    emit ev0(address(this), "000000000000000000000000000000", true);
  }
  modifier m0() virtual
  {
    emit ev0(address(this), "2eac9c00000000000000000000000000000000", false);
    unchecked {
    }
    _;
    address l0 = address(this);
  }
  int128 public constant cons0 = ((((~(int128(((~(int128(170141183460469231731687303715884105727))) / int128(-109627307539560599342770764363861788551))))) - int128(109143961934877675179009387074057259925)) * int128(47408392714959947819725690313729755962)) + int128(0));
}
pragma solidity >= 0.0.0;
// ====
// ----
