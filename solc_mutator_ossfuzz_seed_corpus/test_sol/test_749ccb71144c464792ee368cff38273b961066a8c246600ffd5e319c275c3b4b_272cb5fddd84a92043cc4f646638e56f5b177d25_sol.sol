
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint96 el0;
  bytes10 el1;
  bytes13 el2;
}

==== Source: su1.sol ====
struct St1 {
  function (int224, bytes7, int256) external   returns (bytes1)[8][4] el0;
}
contract C0 {
  type T0 is bool;
  event ev0(uint136  ep0, uint248[]  ep1);
  address  public s0 = address(this);
  uint56[7]  public s1 = [uint56(72057594037927935), uint56(58433714832278100), uint56(0), uint56(72057594037927935), uint56(0), uint56(34951220510931132), uint56(0)];

	function compareMemoryAndStorage(uint56[7] memory v1, uint56[7] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f0() external     returns(bytes memory o0,int160 o1,function (bytes26, bytes1, bytes memory) external   returns (uint256, bool, int184) o2)  {
    (((uint144(int144(782221111408381824481509925107009773215571)) & (uint144(22300745198530623141535718272648361505980415) ^ uint144(0))) > uint144(22300745198530623141535718272648361505980415)) ? false : true);
  }
  fallback() external virtual  
  {
    emit ev0((uint136(0) & ((uint136(87112285931760246646623899502532662132735) ** uint48((uint48(281474976710655) - uint48(281474976710655)))) & uint136(0))), new uint248[](6));
  }
}
uint32 constant cons0 = 0;
pragma solidity >= 0.0.0;
// ====
// ----
