
==== Source: su0.sol ====
function f0()     returns(function (address[][] memory) external   returns (function (uint144, bytes28, bytes23) external   returns (int96), address) o0,bool o1)
{
  for(;
;
address(0x0000000000000000000000000000000000000006))
  {
    try o0(new address[][](9)) returns (function (uint144, bytes28, bytes23) external   returns (int96) l0, address l1)
    {
      continue;
    }
    catch
    {
      continue;
    }
    catch Error(string memory l2)
    {
    }
    catch Panic(uint256 l3)
    {
    }
    (o1) = (false);
    assert(o1 == false);
  }
  bytes28 l4 = bytes28(bytes12(0x000000000000000000000000));
}
struct St0 {
  mapping(bool => address) el0;
  bytes21[2] el1;
  int160 el2;
  address el3;
}
contract C0 {
  mapping(int72 => uint216)   s0;
  address  public s1 = address(this);
  int176   s2 = int176(-10697385268487022970732007884031257396433718683431806);
  mapping(uint240 => mapping(bool => int136[][6][][9][2][10]))  public s3;
  constructor() payable  {
    s0[(int72(0) * int72(2361183241434822606847))] <<= uint216((uint216(((~((((uint216(105312291668557186697918027683670432318895095400549111254310977535) ** uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) >> uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) << uint24(uint24(181886))))) / uint216(0))) / uint216(0)));
    unchecked {
      address  l0 = s1;
      address  l1 = l0;
      assert(l1 == s1);
      int176  l2 = s2;
      int176  l3 = l2;
      assert(l3 == s2);
      do
      {
      }
      while (true);
      s1 = address(this);
      assert(s1 == address(this));
      address  l4 = s1;
      address  l5 = l4;
      assert(l5 == s1);
    }
  }
  fallback() external   
  {
    int176  l0 = s2;
    int176  l1 = l0;
    assert(l1 == s2);
    unchecked {
      (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
      address  l4 = s1;
      address  l5 = l4;
      assert(l5 == s1);
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
