==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0(bool i0,int72 i1) public   
  {
    uint40 l0 = uint40(225613989685);
    bytes26 l1 = bytes26(0xdef73a127067bbd1ad45598451e26d37772d61dbce9eeabe9314);
  }
}
function f1()     returns(address[10][10][][][][6] memory o0,bytes12 o1)
{
  uint128 l0 = (uint128(166026087348299433978043727709558357865) * (((uint128(340282366920938463463374607431768211455) >> uint32(uint32(4294967295))) >> uint16(uint16(58940))) + uint128(340282366920938463463374607431768211455)));
  unchecked {
    o0[uint256(0)] = (false ? new address[10][10][][][](7) : ((int56(36028797018963967) <= int56(36028797018963967)) ? new address[10][10][][][](7) : new address[10][10][][][](7)));
    (o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]) = (new address[10][10][][][](7));
    (o0[uint192(0)], o0[(true ? (((uint240(0) + uint240(0)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) : uint256(0))]) = (new address[10][10][][][](7), ((msg.sender == address(0x0000000000000000000000000000000000000004)) ? new address[10][10][][][](7) : new address[10][10][][][](7)));
    address payable l1 = payable(address(0x0000000000000000000000000000000000000007));
    bytes memory l2 = bytes("9617e91ff865c422");
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  struct St0 {
    mapping(uint248 => bool) el0;
    int24 el1;
    uint120 el2;
    bytes20 el3;
  }
  address   s0;
  uint176   s1 = uint176(95780971304118053647396689196894323976171195136475135);
  uint88[][5]  public s2;

	function compareMemoryAndStorage(uint88[][5] memory v1, uint88[][5] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[] memory v1, uint88[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  uint32   s3 = uint32(4294967295);
  constructor(address i0,uint88[][5] memory i1)   {
    s0 = address(this);
    s2 = i1;
    {
      uint176  l0 = s1;
      uint176  l1 = l0;
      assert(l1 == s1);
    }
  }
  using L0 for *;
  using L0 for *;
}
using L0 for bool;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su0.sol:27-34): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:35-43): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:63-72): Unused local variable.
// Warning 2072: (su0.sol:101-111): Unused local variable.
// Warning 5667: (su0.sol:246-256): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:262-272): Unused local variable.
// Warning 2072: (su0.sol:1247-1265): Unused local variable.
// Warning 2072: (su0.sol:1334-1349): Unused local variable.
// Warning 5667: (su0.sol:2228-2238): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:15-182): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:185-1384): Function state mutability can be restricted to view
// Warning 2018: (su0.sol:1931-2177): Function state mutability can be restricted to view
