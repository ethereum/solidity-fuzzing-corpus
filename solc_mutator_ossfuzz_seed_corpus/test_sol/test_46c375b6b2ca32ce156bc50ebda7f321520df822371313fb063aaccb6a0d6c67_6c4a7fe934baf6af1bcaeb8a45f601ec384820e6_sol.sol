
==== Source: su0.sol ====
contract C0 {
  function f0() public virtual  
  {
    uint144 l0 = uint144(0);
  }
  event ev0(function (bytes memory, bool) external    ep0);
  bytes8   s0;
  int240  public s1 = int240(-676410824767048270836074442469295770311713092190330354607639176190815888);
  bool   s2 = false;
  constructor(bytes8 i0)   {
    s0 &= (false ? bytes8(0xffffffffffffffff) : (bytes1(0xff) ^ bytes1(0x00)));
    {
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
      bool  l2 = s2;
      bool  l3 = l2;
      assert(l3 == s2);
      this.f0();
      require((((uint32(4294967295) - uint32(0)) * uint32(uint168(374144419156711147060143317175368453031918731001855))) != uint32(4294967295)));
    }
  }
  receive() external virtual  payable
  {
    int240  l0 = s1;
    int240  l1 = l0;
    assert(l1 == s1);
    assert((((((uint32(137650279) % uint32(0)) & uint32(4294967295)) >> uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) >> uint24(uint24(13752178))) == uint32(4294967295)));
  }
  error er0(uint176 ep0, address payable ep1);
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  function f2(bool i0) public    returns(int80 o0,int208[5][7][][1] memory o1,function (int224, address) external   returns (uint144, bool, int40) o2)
  {
  }
  mapping(address => C0)   s3;
  int136  public s4 = int136(43556142965880123323311949751266331066367);
  constructor(bytes8 i0) payable C0(bytes8(0x0000000000000000))
  {
    s0 = i0;
    s3[address(this)] = C0(payable(address(this)));
    unchecked {
      (int80 l0, int208[5][7][][1] memory l1, function (int224, address) external   returns (uint144, bool, int40) l2) = this.f2((true ? false : true));
    }
  }
  function f0() public virtual override  
  {
    bytes8  l0 = s0;
    bytes8  l1 = l0;
    assert(l1 == s0);
  }
}
library L0 {
  function f4(bytes16 i0,uint16 i1) public    returns(C0 o0,function (int8[][4] memory, uint88) external   returns (C0, bytes19) o1)
  {
  }
  type T0 is int208;
}
// ====
// ----
