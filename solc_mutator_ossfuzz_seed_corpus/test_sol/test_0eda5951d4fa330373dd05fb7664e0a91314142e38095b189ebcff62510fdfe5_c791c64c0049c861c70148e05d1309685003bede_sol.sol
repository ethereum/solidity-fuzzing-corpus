
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
bytes30 constant cons0 = bytes30(0x000000000000000000000000000000000000000000000000000000000000);

==== Source: su1.sol ====
struct St0 {
  uint56 el0;
  bool el1;
  mapping(int16 => bytes23) el2;
}
struct St1 {
  int96 el0;
  uint208[8] el1;
  string el2;
}
contract C0 {
  struct St2 {
    string el0;
    uint136 el1;
    bytes el2;
    function (uint104, St1 memory, function (int104, bool, bool) external  ) external   returns (address, int120, address payable) el3;
  }
  receive() external virtual  payable
  {
    for(    address l0 = address(this);
;
((uint8(0) | uint8((uint8(255) / (uint8(50) + uint8(0))))) >> uint168(uint168(374144419156711147060143317175368453031918731001855))))
    {
      (l0) = (address(this));
      assert(l0 == address(this));
    }
    int184 l1 = int184(1405718665840375261070882508744610048466180017903466529);
    for(uint solinit0 = 0; solinit0 < ((((uint256((((uint256(67139559555282472408435928465478858181203559163937480595612814659084367607982) % uint256(46027777567494359897764941582011051425143941608313961166735268978959245429652)) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(107877592811402533882422832324295257464372536408129706631889299987501913715895)) % 11); solinit0++)
    {
      break;
    }
  }
  string   s0;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  C0.St2  public s1;

	function compareMemoryAndStorage(C0.St2 memory v1, C0.St2 storage v2) internal returns (bool) {

		if (!compareMemoryAndStorage(v1.el0, v2.el0))
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (!compareMemoryAndStorage(v1.el2, v2.el2))
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}
	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint128   s2;
  C0.St2   s3;
  constructor(string memory i0,uint128 i1)   {
    s0 = string("This is a really long string that must ideally be random but is currently hard coded");
    s2 = (false ? uint128(340282366920938463463374607431768211455) : (((true ? uint128(23099287059846776761840245956727087246) : uint128(327240676488761477225312526295377179132)) % uint128(0)) | uint128(340282366920938463463374607431768211455)));
    unchecked {
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36
}
pragma solidity >= 0.0.0;
// ====
// ----
