
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
    bool l0 = (true ? (false != (true != false)) : true);
    bool l1 = false;
  }
  uint80   s0;
  uint112[]   s1 = [uint112(5192296858534827628530496329220095)];

	function compareMemoryAndStorage(uint112[] memory v1, uint112[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  uint176   s2;
  constructor(uint80 i0,uint176 i1) payable  {
    s0 >>= (uint80(0) % (uint80((uint80(516960418397091769880342) / (uint80(174963855165074738955463) << uint192(uint192(0))))) | uint80(1208925819614629174706175)));
    s2 /= uint176(0);
    unchecked {
      uint112[] memory l0 = s1;
      uint112[] memory l1 = l0;
      assert(compareMemoryAndStorage(l1, s1));
      s2 |= (uint176(74232255476404350679747919796222124275019680058121349) ^ (uint176(66553678594564180349001860998587032029798807867765951) & ((uint176(82510281137571025602635282368142153878432535182272041) << uint232(uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) >> uint64(uint64(0)))));
      assert(false);
    }
  }
  struct St0 {
    bool el0;
    uint48 el1;
    function (bytes27) external   returns (address payable, uint168) el2;
    int192 el3;
  }
}
// ====
// ----
