
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() public virtual   returns(bytes memory o0)
  {
    delete o0;
    for(;
;
[new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2), new address payable[][](2)])
    {
      int128 l0 = int128(129471279960751096055836285670700931179);
    }
  }
  function f1() internal virtual   returns(bytes19 o0,bytes26 o1)
  {
    (bool l0) = payable(this).send(15029038507995366197);
    uint200 l1 = uint40(0);
    address payable l2 = payable(address(this));
  }
  function f2(address i0,function () external   returns (bytes18, string memory, function (bytes1[10][][4] memory, uint216) external   returns (int232, uint112, bytes memory)) i1) external    returns(bytes23 o0)
  {
    bytes5 l0 = bytes5(bytes15(0x85d2ab0d8cdbb6e2bb7adca9910c4c));
    ((int256(0) * int256(-34808037516267067588819583307052219338757802915605683320547295856998128206841)) ^ (int256(19199552947151336049902907955491733364409429689136291968772539577770028796079) - int256(-29106726875265162683583857745679122693711518483815339960828355537041448599816)));
    unchecked {
    }
    address payable l1 = payable(address(this));
  }
  receive() external   payable
  {
    int64 l0 = int64(9223372036854775807);
  }
  uint208  public s0 = uint208(0);
  int160[][][]   s1;

	function compareMemoryAndStorage(int160[][][] memory v1, int160[][][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int160[][] memory v1, int160[][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(int160[] memory v1, int160[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  constructor(int160[][][] memory i0) payable  {
    s1 = i0;
    unchecked {
      int160[][][] memory l0 = s1;
      int160[][][] memory l1 = l0;
      assert(compareMemoryAndStorage(l1, s1));
      uint208  l2 = s0;
      uint208  l3 = l2;
      assert(l3 == s0);
      uint208  l4 = s0;
      uint208  l5 = l4;
      assert(l5 == s0);
      int160[][][] memory l6 = s1;
      int160[][][] memory l7 = l6;
      assert(compareMemoryAndStorage(l7, s1));
      s1.push(new int160[][](2));
    }
  }
}
// ====
// ----
