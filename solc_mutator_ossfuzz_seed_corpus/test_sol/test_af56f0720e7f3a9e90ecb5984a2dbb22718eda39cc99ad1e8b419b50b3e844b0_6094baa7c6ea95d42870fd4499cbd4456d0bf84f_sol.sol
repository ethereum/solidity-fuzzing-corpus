
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
  address el1;
  bool el2;
  address payable el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is int168;
  mapping(address => address[])   s0;
  constructor() payable  {
    {
    }
  }
  event ev0();
}
contract C1 is C0 {
  receive() external virtual  payable
  {
    if (true)
    {
    }
    if (true)
    {
      emit ev0();
    }
    else if ((bytes4(0xffffffff) <= bytes4(bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))))
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 14852451722901827450}("");
      if (false)
      {
        revert((false ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded")));
      }
      else
      {
        emit ev0();
      }
      for(uint solinit0 = 0; solinit0 < (((((uint256(59161758871308050625009596945023640969030029862891813932438238935638494770889) >> uint56(uint32(1122071257))) & uint256(91186158808540413323411853635755460864839648216063389714840191452205971469309)) ** uint168(uint168(374144419156711147060143317175368453031918731001855))) - uint256(94161099208824691680107568498808757337491326928189775891013459018846975173764)) % 11); solinit0++)
      {
        if (true)
        {
        }
        break;
      }
      return;
    }
  }
  error er0(address ep0);
  function f1(int256 i0) public     returns(bytes memory o0)  {
  }
  error er1(function (address payable) external   returns (uint128, function (bool, uint160) external   returns (bytes32)) ep0, C0.T0 ep1);
  event ev1();
  function f2() private     returns(address[1] memory o0,int128 o1)  {
    delete o0[uint256(0)];
    emit ev0();
    return ([address(0x0000000000000000000000000000000000000006)], int128((int128(170141183460469231731687303715884105727) / int128(170141183460469231731687303715884105727))));
  }
  C0 immutable public s1 = C0(address(this));
  constructor()   {
    unchecked {
    }
  }
}
struct St1 {
  string el0;
  C0 el1;
  address payable[2] el2;
  uint96 el3;
}
struct St2 {
  uint232 el0;
}
// ====
// ----
