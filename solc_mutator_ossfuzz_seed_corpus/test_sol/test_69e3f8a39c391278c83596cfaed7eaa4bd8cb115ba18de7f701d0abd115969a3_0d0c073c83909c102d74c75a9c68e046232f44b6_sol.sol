
==== Source: su0.sol ====
library L0 {
  function f0() external    returns(int128[1] memory o0,bool o1)
  {
    int136[5][][5][3][][] memory l0 = (true ? new int136[5][][5][3][][](5) : new int136[5][][5][3][][](5));
    o0[payable(address(0x0000000000000000000000000000000000000006)).balance] %= (int128(170141183460469231731687303715884105727) | (-((~((o0[uint256(33331985357322250142488358110159727181027955848074312339289326987856743028474)] /= o0[(uint256(0) & uint256(91653468409424280629146100813730395073682185434744525155471498777573619440504))]))))));
  }
  function f1() public   
  {
    function (int184, function () external   returns (address payable, bytes memory), string memory) external   returns (int24, int80[3][] memory) l0;
    function () external   returns (uint104) l1;
  }
  modifier m0() 
  {
    uint128 l0 = uint128(uint56(43962071969378488));
    assert(false);
    _;
  }
}
contract C0 {
  using L0 for *;
  using L0 for *;
  fallback() external   
  {
    bytes20 l0 = bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));
    bytes17 l1 = bytes17(0x0000000000000000000000000000000000);
  }
  uint160  public s0 = uint160(0);
}
pragma solidity >= 0.0.0;
type T0 is bytes6;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
