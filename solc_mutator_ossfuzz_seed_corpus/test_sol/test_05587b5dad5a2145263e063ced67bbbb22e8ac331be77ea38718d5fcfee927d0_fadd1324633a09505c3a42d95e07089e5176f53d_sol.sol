==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0();

==== Source: su1.sol ====
contract C0 {
  bool   s0 = false;
  bool  public s1;
  address  public s2 = address(this);
  constructor(bool i0)   {
    s1 = false;
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 16416329121261048872}("");
    }
  }
  function f0(bool i0) public   payable   {
    if (i0)
    {
      for(uint solinit0 = 0; solinit0 < ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * ((((uint256(50702736186326318535536802608848177334586608800381740990582434271344850575296) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(0)) & uint256(0)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) % 11); solinit0++)
      {
        if (i0)
        {
        }
        return;
      }
    }
  }
  struct St0 {
    mapping(uint72 => bytes18) el0;
  }
  receive() external virtual  payable
  {
    bool  l0 = s0;
    bool  l1 = l0;
    assert(l1 == s0);
    for(uint solinit1 = 0; solinit1 < ((((((true ? uint256(100138071580612196822877158995093524845448006743057979297848155835614071881287) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) - uint256(97920669583566608313836966593065990421812981747775758098134380359893174289736)) | uint256(93213877984093481203471966669695639276061143497299724370274260929305323231985)) ^ uint256(0)) % 11); solinit1++)
    {
      while (true)
      {
        for(uint solinit2 = 0; solinit2 < ((((((uint256((uint256(0) / uint256(64802332023948620507951996878623577030550526048161886245528723327403725763520))) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint192(uint192(6277101735386680763835789423207666416102355444464034512895))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ** uint48(uint48(0))) % 11); solinit2++)
        {
          break;
        }
        if ((((uint208(0) - (uint208(0) - uint208(0))) + uint208(400160507200150215957681808779806486788290467749395017731057861)) <= uint208(400737106528493860288310631297070779976492563975717719832102662)))
        {
          return;
        }
      }
      continue;
    }
  }
}
contract C1 {
  struct St1 {
    bool el0;
    function (uint136) external   returns (int112, address) el1;
    uint96[5] el2;
  }
  error er1();
  bool immutable  s3 = true;
  uint40   s4;
  constructor(uint40 i0)   {
    s4 ^= (((uint40(0) + uint40(1099511627775)) * (uint40(347724592687) * uint40(982058784383))) & uint40(0));
    unchecked {
    }
  }
  error er2(int184 ep0);
}
function f2()      returns(uint160 o0){
}
struct St2 {
  uint168 el0;
  bool el1;
  mapping(address => bytes21) el2;
}
pragma solidity >= 0.0.0;
// ----
// Warning 5740: (su1.sol:742-752): Unreachable code.
// Warning 5740: (su1.sol:2091-2101): Unreachable code.
// Warning 5667: (su1.sol:106-113): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:148-155): Unused local variable.
// Warning 2072: (su1.sol:157-172): Unused local variable.
// Warning 5667: (su1.sol:2627-2636): Unused function parameter. Remove or comment out the variable name to silence this warning.
