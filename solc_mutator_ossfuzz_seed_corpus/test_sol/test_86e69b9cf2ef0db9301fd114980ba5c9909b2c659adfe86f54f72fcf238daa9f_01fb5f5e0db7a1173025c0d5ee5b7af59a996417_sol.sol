
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  modifier m0(address payable i0,bytes12 i1) 
  {
    _;
    address payable l0 = payable(address(0x0000000000000000000000000000000000000001));
  }
  function f0(int136 i0,bytes memory i1) public  m0(payable(msg.sender),bytes12(0xffffffffffffffffffffffff))  returns(int192[7][][] memory o0)
  {
    delete o0[(((((~(uint256(0))) - uint256(0)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(0)) << uint56(uint56(72057594037927935)))];
    address payable l0 = payable(address(0x0000000000000000000000000000000000000003));
    bytes18 l1 = bytes18(0x46a739bf6b22b899278e9f81b7cc0cbdec68);
  }
  error er0(bytes1 ep0);
}
function f1(uint152 i0,uint168[] memory i1)     returns(bytes12 o0)
{
  i1[uint256(0)] >>= uint168(143843616242272958983497908745027588582960997208982);
  int72 l0 = int72(0);
  bytes memory l1 = (true ? bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000") : bytes("98e19c71889218f720e27d20534935a5d5d40d76d68dfe626c43ca3a8b"));
}
int48 constant cons0 = 74735023454992;
contract C0 {
  using L0 for *;
  using L0 for *;
  address payable   s0 = payable(address(this));
  function f2() external    returns(int40 o0,bool o1)
  {
    address payable  l0 = s0;
    address payable  l1 = l0;
    assert(l1 == s0);
    require(true);
    address payable  l2 = s0;
    address payable  l3 = l2;
    assert(l3 == s0);
  }
  using L0 for *;
}
// ====
// ----
