
==== Source: su0.sol ====
struct St0 {
  function (int256) external   returns (address, int192, uint152) el0;
  mapping(address => int24) el1;
  uint224[7][5] el2;
}
contract C0 {
  receive() external virtual  payable
  {
    int72 l0 = (-(int72(0)));
    string memory l1 = string("000000000000000000ccf86ac2937cd4918f9658");
    (bool l2) = payable(this).send(0);
  }
  fallback() external   
  {
    assembly
    {
      switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
      case 0
      {
        stop()
      }
      if 95827161408858582271539024634407993758025058906555692113497035790726543400771
      {
        stop()
      }
    }
    address l0 = address(this);
  }

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(bytes calldata i0) external virtual   returns(bool o0,uint56 o1)
  {
    for(    uint232 l0 = ((uint232(612850046682306713386857641901557320894293568902139385596020129955802) + ((uint8(149) % uint232(6901746346790563787434755862277025452451108972170386555162524223799295)) + uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) + uint232(6901746346790563787434755862277025452451108972170386555162524223799295));
false;
this.f2.address)
    {
      int72 l1 = (-(int72(2341070908376199370336)));
    }
    address l2 = address(this);
    bytes memory l3 = i0;
    assert(compareMemoryAndCalldata(l3, i0));
  }
  address payable  public s0 = payable(address(this));
}
pragma solidity >= 0.0.0;
// ====
// ----
