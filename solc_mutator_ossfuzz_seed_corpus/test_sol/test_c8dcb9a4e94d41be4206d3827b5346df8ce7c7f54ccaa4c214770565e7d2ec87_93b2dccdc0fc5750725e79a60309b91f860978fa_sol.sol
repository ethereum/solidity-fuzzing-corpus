
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0() external    returns(function (bytes31, bool) external   returns (bool, bytes23[1] memory, uint120) o0,int112 o1)
  {
  }
  type T0 is address payable;
}
contract C0 {
  using L0 for *;
  L0.T0   s0;
  constructor(L0.T0 i0)   {
    s0 = L0.T0.wrap(payable(address(0x0000000000000000000000000000000000000004)));
    {
    }
  }
  using L0 for *;
  using L0 for *;
  fallback() external   payable
  {
    {
      L0.T0  l0 = s0;
      L0.T0  l1 = l0;
      assert(l1 == s0);
      L0.T0  l2 = s0;
      L0.T0  l3 = l2;
      assert(l3 == s0);
      unchecked {
        L0.T0  l4 = s0;
        L0.T0  l5 = l4;
        assert(l5 == s0);
        (bool l6) = payable(this).send(0);
        L0.T0  l7 = s0;
        L0.T0  l8 = l7;
        assert(l8 == s0);
        L0.T0  l9 = s0;
        L0.T0  l10 = l9;
        assert(l10 == s0);
        require(false, string("9dea020d85cb3104af189db4384dabbed0423a681affffffffffff"));
      }
      L0.T0  l11 = s0;
      L0.T0  l12 = l11;
      assert(l12 == s0);
      L0.T0  l13 = s0;
      L0.T0  l14 = l13;
      assert(l14 == s0);
      L0.T0  l15 = s0;
      L0.T0  l16 = l15;
      assert(l16 == s0);
    }
    L0.T0  l17 = s0;
    L0.T0  l18 = l17;
    assert(l18 == s0);
    for(    bool l19 = true;
;
)
    {
    }
  }
  using L0 for *;
}
// ====
// ----
