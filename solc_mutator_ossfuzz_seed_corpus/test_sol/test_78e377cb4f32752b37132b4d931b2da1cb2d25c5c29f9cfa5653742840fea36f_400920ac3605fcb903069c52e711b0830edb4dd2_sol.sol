
==== Source: su0.sol ====
library L0 {
  function f0(uint208 i0,int144[8][] memory i1) private   
  {
    address l0 = address(0x0000000000000000000000000000000000000001);
  }
  event ev0(int48  ep0, uint24  ep1);
  modifier m0(int16 i0) 
  {
    uint248 l0 = uint248((((uint248(0) ** uint128(((uint128(0) * uint128(47679877460347029373079771010229522753)) | uint128(0)))) | uint248(128860696218193625528970268148661752723820532234171981646820463288880590361)) / uint248(37670017312969879859508861431085564578933521894259959644851055527331011614)));
    _;
  }
}
library L1 {
  event ev1(string  ep0, bool  ep1);
  function f1(bytes19 i0,string memory i1,uint16 i2) private    returns(address payable o0,address payable o1,bool o2)
  {
    bytes7[][][][][][9] memory l0 = [new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3), new bytes7[][][][][](3)];
    bytes9 l1 = bytes9(0xffffffffffffffffff);
    bytes26 l2 = bytes26(0x0000000000000000000000000000000000000000000000000000);
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  uint208 el0;
  bytes20 el1;
  function (uint88, bool) external   returns (bool, address payable, function () external   returns (string memory)) el2;
}

==== Source: su1.sol ====
contract C0 {
  receive() external   payable
  {
    uint16[][2] storage l0;
    address l1 = address(this);
  }
  uint80   s0 = uint80(721350278144022640095192);
}
pragma solidity >= 0.0.0;
// ====
// ----
