==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  function (bool, function (bool, bytes24) external   returns (bool[8][1][] memory, bool, bytes30)) external   returns (function (int128, uint224, bool[] memory) external   returns (address payable)) el0;
  uint88 el1;
}
library L0 {
  modifier m0(address payable i0) 
  {
    for(;
;
(((~(int240(883423532389192164791648750371459257913741948437809479060803100646309887))) ^ ((int240(883423532389192164791648750371459257913741948437809479060803100646309887) - int240(841205526231211849480831026403172170010547464766658178256820156985174400)) | int240(0))) & int240(86136460715149305943575175225045637417449584192412405401434304710407427)))
    {
      _;
      address payable l0 = payable(address(0x0000000000000000000000000000000000000008));
      address l1 = msg.sender;
      address l2 = address(0x0000000000000000000000000000000000000002);
    }
    assembly
    {
      for 
      {
        i0 := 0
        return(i0, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
      i0
      {
        i0 := mload(add(0x80, mod(i0, 2048)))
      }
      {
        switch i0
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
        }
        case 59357768857183341321480731322831097212063632754811715128751839572760479062260
        {
          stop()
        }
        continue
      }
      for 
      { let yulinit0 := 0 } lt(yulinit0, mod(blockhash(i0), 11)) { yulinit0 := add(yulinit0, 1) }
      {
      }
      stop()
    }
  }
  error er0(St0 ep0);
}
contract C0 {
  function f0() internal virtual   returns(int120 o0)
  {
  }
  function f1(int240 i0) external virtual  payable returns(St0 memory o0)
  {
  }
  fallback() external   
  {
    address l0 = address(this);
    (bool l1, bytes memory l2) = address(this).call(abi.encodeWithSignature("f1(int240)", int240(883423532389192164791648750371459257913741948437809479060803100646309887)));
    uint216 l3 = (uint216(0) | ((uint216(105312291668557186697918027683670432318895095400549111254310977535) - uint216(0)) | uint216(71196413843550562909067705808308102764120135262391480225660764142)));
  }
  bool[10]   s0;

	function compareMemoryAndStorage(bool[10] memory v1, bool[10] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool  public s1 = true;
  constructor(bool[10] memory i0)   {
    s0 = i0;
    unchecked {
      bool[10] memory l0 = s0;
      bool[10] memory l1 = l0;
      assert(compareMemoryAndStorage(l1, s0));
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
import "su0.sol";
// ----
// Warning 6133: (su0.sol:298-651): Statement has no effect.
// Warning 2072: (su0.sol:1752-1762): Unused local variable.
// Warning 2072: (su0.sol:1785-1792): Unused local variable.
// Warning 2072: (su0.sol:1794-1809): Unused local variable.
// Warning 2072: (su0.sol:1958-1968): Unused local variable.
// Warning 2018: (su0.sol:2180-2426): Function state mutability can be restricted to view
