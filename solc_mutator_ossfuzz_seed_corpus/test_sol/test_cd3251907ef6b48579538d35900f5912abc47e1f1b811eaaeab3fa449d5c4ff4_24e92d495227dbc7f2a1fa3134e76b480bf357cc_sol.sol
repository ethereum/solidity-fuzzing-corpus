
==== Source: su0.sol ====
contract C0 {
  bytes7  public s0;
  uint184   s1 = uint184(0);
  bool  public s2;
  bytes26   s3 = bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff);
  constructor(bytes7 i0,bool i1)   {
    s0 = bytes2(0x34e7);
    s2 = (payable(address(this)) > payable(msg.sender));
    {
    }
  }
  receive() external virtual  payable
  {
    uint184  l0 = s1;
    uint184  l1 = l0;
    assert(l1 == s1);
  }
  fallback() external   
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38
}
contract C1 {
  fallback() external   payable
  {
    uint8 l0 = ((uint8(0) << uint192((uint192(6277101735386680763835789423207666416102355444464034512895) & uint192(5476275279556851618287605836204831290360313884807091219333)))) * uint8(167));
    payable(this).transfer(0);
    payable(this).transfer(1286991492457228392);
  }
  bytes2   s4;
  constructor(bytes2 i0)   {
    s4 ^= bytes2(0xffff);
    unchecked {
      bytes2  l0 = s4;
      bytes2  l1 = l0;
      assert(l1 == s4);
      bytes2  l2 = s4;
      bytes2  l3 = l2;
      assert(l3 == s4);
      bytes2  l4 = s4;
      bytes2  l5 = l4;
      assert(l5 == s4);
      bytes2  l6 = s4;
      bytes2  l7 = l6;
      assert(l7 == s4);
      bytes2  l8 = s4;
      bytes2  l9 = l8;
      assert(l9 == s4);
      bytes2  l10 = s4;
      bytes2  l11 = l10;
      assert(l11 == s4);
      bytes2  l12 = s4;
      bytes2  l13 = l12;
      assert(l13 == s4);
      bytes2  l14 = s4;
      bytes2  l15 = l14;
      assert(l15 == s4);
    }
  }
}
function f3()    
{
  EN0 l0 = EN0.M24;
}
// ====
// ----
