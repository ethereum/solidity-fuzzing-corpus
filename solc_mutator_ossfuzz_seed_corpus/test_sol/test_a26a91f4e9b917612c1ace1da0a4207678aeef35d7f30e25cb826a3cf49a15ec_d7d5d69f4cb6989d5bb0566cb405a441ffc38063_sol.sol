
==== Source: su0.sol ====
struct St0 {
  bytes el0;
  uint8 el1;
  function () external   returns (bytes13, address payable[] memory, bytes25) el2;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  bytes27   s0;
  mapping(uint144 => address)  public s1;
  constructor(bytes27 i0) payable  {
    s0 = ((bytes27(0x000000000000000000000000000000000000000000000000000000) & (~(bytes27(0x000000000000000000000000000000000000000000000000000000)))) & (false ? bytes27(0x000000000000000000000000000000000000000000000000000000) : bytes27(0x115de7db20f2ad795df1a9b0a96a8f7baf839b23c00be5f2a437fc)));
    s1[uint144((uint144(21808056452414779130364019874022425668005961) / uint144((uint144(2506060123437753746085363973361770074505123) / (~((uint144(0) >> uint24(uint24(8923614)))))))))] = address(this);
    {
    }
  }
  function f0() external virtual  payable returns(bytes4 o0)
  {
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
