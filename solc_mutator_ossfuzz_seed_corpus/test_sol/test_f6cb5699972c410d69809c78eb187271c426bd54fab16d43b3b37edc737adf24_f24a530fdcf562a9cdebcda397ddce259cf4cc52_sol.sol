
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  event ev0();
  error er0(bytes19 ep0);
  function f0(bytes26 i0) private   
  {
    revert L0.er0(bytes19(0x8df9dd2f6806019229ee4a096756b728db8e50));
  }
  using L0 for *;
}
contract C0 {
  modifier m0() virtual
  {
    uint208 l0 = (uint208(328583741952052613154026405455750460731588328327188090886667393) + (((uint208(411376139330301510538742295639337626245683966408394965837152255) | uint208(0)) & uint208(223672291290786061374837133975165561319886765391956292482268329)) - uint208(0)));
    (bool l1, bytes memory l2) = address(this).call("ffffffffffffffffffffffffffffffff");
    _;
  }
  type T0 is bool;
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10
  }
  modifier m1(int160 i0,C0.EN0 i1) 
  {
    _;
    _;
    (bool l0, bytes memory l1) = address(this).call("00000000000000000000000000000000ffffffffffffffffffffffff");
  }
  fallback() external  m0() m1(int160(0),C0.EN0.M1) 
  {
    if ((bytes9(0x79a45272ce001dae03) <= bytes9(0xbe0bdf8c3b4e3f8ab1)))
    {
    }
    return;
    revert L0.er0(bytes19(0xffffffffffffffffffffffffffffffffffffff));
  }
  event ev1(C0.T0  ep0, function (bool, int48) external   returns (bytes12, C0.EN0, bytes26)  ep1);
  mapping(bytes31 => int88)  public s0;
  constructor()   {
    s0[bytes31(0x00000000000000000000000000000000000000000000000000000000000000)] *= int88(((int88(28440039056499236897135460) ^ (int88(0) ^ (int88(0) * int88(33728134331633313570728376)))) / int88(154742504910672534362390527)));
    unchecked {
      {
        revert("000000000000002da0");
      }
      revert L0.er0(bytes19(0x00000000000000000000000000000000000000));
      do
      {
        break;
        revert L0.er0(bytes19(0xffffffffffffffffffffffffffffffffffffff));
      }
      while (false);
    }
  }
  modifier m2() 
  {
    _;
    assembly
    {
      for 
      {
        revert(caller(), 46394618644282668243206997045449193492427308207334502116726311532771412105388)
        return(s0, 0)
      }
      115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      {
        return(0, s0.slot)
      }
      let al0 := s0
      switch s0
      case 0
      {
        function af0(ai0, ai1)
        {
          if sload(ai1)
          {
            af0(mload(mod(s0.offset, 2048)), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
            {
              pop(0)
              if 0
              {
                ai0 := s0.offset
              }
            }
          }
          af0(calldataload(mod(ai1, calldatasize())), 55292184106157679352132382670207833994680419988067046548652724787144014035144)
        }
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      case 30250689083050767099140068166171679154213902445021581688172744677961252175961
      {
        return(s0, s0.offset)
      }
    }
  }
  event ev2(C0.T0  ep0, C0.EN0  ep1);
  int64 public constant cons0 = int64(0);
}
using L0 for uint;
bytes26 constant cons1 = ((bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff) | (((C0.EN0.M2 == C0.EN0.M9) || false) ? bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff) : bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff))) ^ bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
// ====
// ----
