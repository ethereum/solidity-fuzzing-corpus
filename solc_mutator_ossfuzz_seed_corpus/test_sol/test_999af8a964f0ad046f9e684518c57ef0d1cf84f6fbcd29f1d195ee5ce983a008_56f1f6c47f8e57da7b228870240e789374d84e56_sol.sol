
==== Source: su0.sol ====
struct St0 {
  int104 el0;
  address payable el1;
}
pragma solidity >= 0.0.0;
type T0 is int208;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=,
unsub0 as -
} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function unsub0(T0 x) pure returns (T0) { return T0.wrap(-T0.unwrap(x)); }


function f0(int48 i0)      returns(uint232 o0){
  return (((uint8(95) >> uint224((uint224(0) ^ uint224(0)))) & uint8(255)));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f1(function () external   returns (uint88) i0,function (bytes25, uint96[] memory, int72) external   returns (bool, string memory, address[3] memory) i1,uint32 i2) external virtual     {
    (i1) = (0 f2 /*suffix expr*/);
    assert(i1 == 0 f2 /*suffix expr*/);
    do
    {
      break;
    }
    while (true);
  }
  int168   s0;
  int32   s1;
  bytes23 immutable  s2 = bytes23(0x76afda3cc9c5ada0829dca878b0a7b701c598c0ef0fa6b);
  int8   s3;
  constructor(int168 i0,int32 i1,int8 i2)   {
    s0 |= int168(187072209578355573530071658587684226515959365500927);
    s1 %= (int32(1354075066) ^ int32(2147483647));
    s3 &= int8(-49);
    unchecked {
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31

}
function f2(uint144 i0) pure suffix  returns(function (bytes25, uint96[] memory, int72) external   returns (bool, string memory, address[3] memory) o0)
{
  if (i0 == (((uint224(26959946667150639794667015087019630673637144422540572481103610249215) + (~((uint224(0) ^ uint224(0))))) < uint224(19393426206564200905907175700772730253730421538974126405401995941902)) ? uint144(0) : uint144(22300745198530623141535718272648361505980415)))
  {
    if (i0 >= uint144(((uint144(22300745198530623141535718272648361505980415) & uint144(0)) / ((uint144(0) >> uint96(uint96(79228162514264337593543950335))) & uint144(8887796930120242075707811162744991914610332)))))
    {
    }
  }
  while (false)
  {
    break;
  }
}
// ====
// ----
