
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  bool  public s0 = false;
  uint240  public s1 = uint240(1766847064778384329583297500742918515827483896875618958121606201292619775);
  function f0(bool i0) public   payable  returns(bytes memory o0,uint192 o1)  {
    o1 %= ((address(this) == address(this)) ? ((~(uint192(6277101735386680763835789423207666416102355444464034512895))) ^ uint192(6277101735386680763835789423207666416102355444464034512895)) : uint192(0));
    (s1) = (uint240(0));
    assert(s1 == uint240(0));
  }
  receive() external virtual  payable
  {
  }
  function f2(bool i0,bool i1) public   payable   {
    while (true)
    {
      if (i1)
      {
        break;
      }
      else
      {
        bool l0 = false;
        (s1) = (uint240((((uint240(472686397874327726646843896322243593936804495438650841658468933359327582) | uint128(340282366920938463463374607431768211455)) % uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) / uint240(0))));
        assert(s1 == uint240((((uint240(472686397874327726646843896322243593936804495438650841658468933359327582) | uint128(340282366920938463463374607431768211455)) % uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) / uint240(0))));
      }
      (bool l1, bytes memory l2) = payable(this).call{value: 5898316006675651093}("");
      (s0, s0) = (false, false);
      assert(s0 == false);
      assert(s0 == false);
    }
    return;
  }
  function f3(uint240 i0) public virtual     {
    return;
  }
}
error er0();
contract C1 {
  string   s2 = string("This is a really long string that must ideally be random but is currently hard coded");

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bool   s3 = true;
  uint248   s4;
  mapping(uint96 => mapping(bool => address[10]))  public s5;
  constructor(uint248 i0)   {
    s4 >>= ((((((uint248(0) ** uint232(uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) + uint248(0)) ^ uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)) | uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)) ^ uint248(78984169839794894018946940080842085442437328108518151465835392560624726776)) * uint248(452312848583266388373324160190187140051835877600158453279131187530910662655));
    unchecked {
    }
  }
  struct St0 {
    C0 el0;
    bool el1;
    bytes el2;
    int88 el3;
  }
  function f4() external     returns(C1.St0 memory o0,int176 o1,address payable o2)  {
    revert er0();
  }
  error er1(bool ep0);
  function f5(bool i0,bool i1) external virtual  payable  returns(C0 o0)  {
    uint248  l0 = s4;
    uint248  l1 = l0;
    assert(l1 == s4);
    (bytes memory l2, uint192 l3) = o0.f0(true);
    (bool l4, bytes memory l5) = payable(o0).call{value: 16669619108824110496}("");
  }
  function f6(int216 i0) external   payable   {
    return;
  }
}
int48 constant cons0 = 140737488355327;

==== Source: su1.sol ====
address payable constant cons1 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
struct St1 {
  string el0;
  uint24 el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
