==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0() private    returns(uint48 o0,address o1)
  {
  }
  receive() external   payable
  {
    unchecked {
      for(uint solinit0 = 0; solinit0 < (uint256(4394994425587685292090324736632880511426293552764638769782982297994296563848) % 11); solinit0++)
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 15070683766233982332}("");
      }
    }
    uint240 l2 = ((uint240(0) << uint232(uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) - ((uint240(1766847064778384329583297500742918515827483896875618958121606201292619775) - uint240(314290732003032939087763405157270148835513677923643203231420242987681203)) & uint240(1165186257701513737214591353804822395774965899594289350153424918629015715)));
    int88 l3 = (int88(47705246643343468435592719) - int88(70995640326636048652150415));
    payable(this).transfer(0);
  }
  address payable immutable public s0;
  constructor(address payable i0) payable  {
    s0 = payable(address(this));
    { }
  }
  fallback() external virtual  
  {
    address payable  l0 = s0;
    address payable  l1 = l0;
    assert(l1 == s0);
    address payable  l2 = s0;
    address payable  l3 = l2;
    assert(l3 == s0);
  }
}
library L0 {
  function f3(function (uint216, function (bool, string memory, uint232) external  ) external   returns (uint184) i0,uint104 i1) external    returns(bytes25 o0)
  {
    o0 |= (~((~(bytes25(0x44a8858fc0086f01473b2610e67356bb67015b5648c214d928)))));
    bytes17 l0 = bytes17(0x0000000000000000000000000000000000);
  }
  modifier m0(address payable i0) 
  {
    function (function (bool) external  , string memory) external   returns (uint120, bytes memory) l0;
    int160 l1 = (int160(0) * (((-((int160(662573116823307360287045052760941997295191078851) % int160(167934242236623392843046415714737356950992060763)))) - int160(0)) % int160(0)));
    _;
  }
}
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
library L1 {
  function f4(bool[][2] memory i0) public   
  {
    bool l0 = true;
    function (bytes4) external   returns (bytes23, function () external  ) l1;
    bytes1 l2 = bytes1(0xe8);
  }
}
using L1 for bool[][2];
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su0.sol:293-300): Unused local variable.
// Warning 2072: (su0.sol:302-317): Unused local variable.
// Warning 2072: (su0.sol:392-402): Unused local variable.
// Warning 2072: (su0.sol:775-783): Unused local variable.
// Warning 5667: (su0.sol:947-965): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1256-1358): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1359-1369): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1494-1504): Unused local variable.
// Warning 5667: (su0.sol:2009-2028): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2048-2055): Unused local variable.
// Warning 2072: (su0.sol:2068-2141): Unused local variable.
// Warning 2072: (su0.sol:2147-2156): Unused local variable.
// Warning 2018: (su0.sol:1244-1557): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:1997-2176): Function state mutability can be restricted to pure
