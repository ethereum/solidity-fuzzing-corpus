==== Source:  ====

==== Source: su0.sol ====
error er0();
contract C0 {
  receive() external   payable
  {
    while (true)
    {
    }
    if (false)
    {
    }
    else if (true)
    {
      bytes10 l0 = bytes10(0xf64552fd0cbb53c26562);
    }
    else
    {
      for(      function (uint112, bytes32) internal   returns (int240) l1;
true;
)
      {
      }
      if ((((uint200(324251358900159872987215502567377560643848375692447254488856) * uint200(0)) * (uint200(0) - uint200(0))) != uint200(1520024333751210041011297619796388038058345431503519551477316)))
      {
      }
      else if (true)
      {
      }
      else
      {
      }
    }
    if (true)
    {
      unchecked {
        {
          if (false)
          {
          }
          else if (false)
          {
            return;
          }
          else
          {
          }
          (bool l2, bytes memory l3) = payable(this).call{value: 8153363694639642962}("");
          return;
          return;
          assert(((!(((true ? (!(false)) : false) || false))) && true));
        }
        if (true)
        {
          while (false)
          {
            return;
          }
        }
        else if (true)
        {
        }
        else
        {
        }
        return;
      }
    }
  }
  modifier m0() 
  {
    _;
  }
  error er1();
  struct St0 {
    uint48 el0;
  }
  type T0 is bytes29;
  error er2();
  C0.T0   s0;
  bool   s1 = true;
  bool   s2 = false;
  constructor(C0.T0 i0)   {
    s0 = C0.T0.wrap(bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
    { }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112, M113, M114, M115, M116
  }
  event ev0(address  ep0);
  int8 public constant cons0 = ((((((int8(127) % int8(0)) & int8(0)) ^ int8(127)) * int8(12)) ** uint16(uint16(65535))) & int8(-125));
}
pragma solidity >= 0.0.0;
library L0 {
  type T1 is int160;
  modifier m1(function () external   returns (uint48, C0.St0 memory) i0,int136 i1) 
  {
    _;
  }
  event ev1();
  bool public constant cons1 = true;
  error er3(function (bool, bytes5, uint152) external   returns (bytes30, int24, L0.T1) ep0);
  error er4(function (C0.St0 memory, bool) external   returns (C0.St0 memory) ep0, uint112 ep1);
  modifier m2() 
  {
    if (cons1)
    {
      for(      C0.St0 memory l0 = C0.St0(uint48(83509124603561));
;
)
      {
        _;
      }
      if (true)
      {
      }
      else if (cons1)
      {
        if (false)
        {
          emit L0.ev1();
        }
        else if (true)
        {
          _;
          assert(true);
          emit L0.ev1();
        }
      }
    }
    else if (false)
    {
      if (false)
      {
      }
    }
    _;
    revert er0();
  }
}
struct St1 {
  mapping(C0.T0 => mapping(bytes10 => C0.EN0)) el0;
  C0.St0 el1;
  function (string memory, uint88) external   returns (C0.St0 memory) el2;
  address[] el3;
}
C0.T0 constant cons2 = C0.T0.wrap(bytes29(0x0000000000000000000000000000000000000000000000000000000000));
using L0 for uint;
type T2 is bytes18;
// ----
// Warning 3149: (su0.sol:2266-2351): The result type of the exponentiation operation is equal to the type of the first operand (int8) ignoring the (larger) type of the second operand (uint16) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su0.sol:925-932): Unreachable code.
// Warning 5740: (su0.sol:943-1004): Unreachable code.
// Warning 5740: (su0.sol:1024-1197): Unreachable code.
// Warning 5740: (su0.sol:1206-1213): Unreachable code.
// Warning 2072: (su0.sol:149-159): Unused local variable.
// Warning 2072: (su0.sol:232-290): Unused local variable.
// Warning 2072: (su0.sol:817-824): Unused local variable.
// Warning 2072: (su0.sol:826-841): Unused local variable.
// Warning 5667: (su0.sol:1420-1428): Unused function parameter. Remove or comment out the variable name to silence this warning.
