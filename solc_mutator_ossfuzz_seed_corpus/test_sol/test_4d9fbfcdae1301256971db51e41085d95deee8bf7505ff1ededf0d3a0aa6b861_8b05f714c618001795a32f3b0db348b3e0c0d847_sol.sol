
==== Source: su0.sol ====
contract C0 {
  error er0();
  bool   s0;
  int72   s1;
  bool  public s2 = true;
  mapping(address => uint48)  public s3;
  constructor(bool i0,int72 i1) payable  {
    s0 = ((true f0 /*suffix expr*/ != (((uint256(0) + uint256(46325691187252451185785457613352362580219410170233842599047477278572355634246)) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ? false : false);
    s1 ^= (int72(0) + int72(((((int72(0) + int72(336648020126499560144)) ^ int72(2361183241434822606847)) % int72(804579247856641740109)) / int72(0))));
    s3[address(this)] ^= (uint48(206504718048826) ^ uint48(19068131241635));
    {
    }
  }
}
pragma solidity >= 0.0.0;
int176 constant cons0 = 12899664264225883582082787506049706304165224856928769;
struct St0 {
  int128 el0;
  bytes32 el1;
}
function f0(bool i0) pure suffix  returns(uint256 o0)
{
}

==== Source: su1.sol ====
struct St1 {
  int88 el0;
  string el1;
}
pragma solidity >= 0.0.0;
// ====
// ----
