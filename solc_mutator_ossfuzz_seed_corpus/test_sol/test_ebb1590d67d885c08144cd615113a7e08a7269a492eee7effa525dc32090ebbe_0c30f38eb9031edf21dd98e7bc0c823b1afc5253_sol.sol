==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  event ev0(uint112 indexed ep0);
  function f0(bool i0) external    returns(address[] memory o0,uint184 o1)
  {
  }
}
using L0 for bool;
function f1()    
{
  uint80 l0 = uint80(int80(0));
  uint136 l1 = ((((uint128(150977839650252669692721505020508276481) * uint128(256824916930841493431539675789270531510)) % uint128(340282366920938463463374607431768211455)) * uint136(0)) & uint136(0));
  int48((((int48(0) * (int48(140737488355327) & int48(24856954991990))) * int48(0)) / int48(-64911049060679)));
}
contract C0 {
  address payable  public s0;
  bytes25   s1;
  constructor(address payable i0,bytes25 i1)   {
    s0 = payable(address(this));
    s1 ^= bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  using L0 for *;
  fallback() external   
  {
    address payable  l0 = s0;
    address payable  l1 = l0;
    assert(l1 == s0);
    address payable  l2 = s0;
    address payable  l3 = l2;
    assert(l3 == s0);
  }
  using L0 for *;
  receive() external virtual  payable
  {
  }
}

==== Source: su1.sol ====
library L1 {
  function f4(bytes memory i0,uint80 i1,bool i2) external   
  {
    uint216[][10] memory l0 = [new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3)];
    for(    int8 l1 = int8(0);
false;
)
    {
      (l1, l0, l0[(((uint256((uint256((uint256((uint256(0) / uint256(0))) / uint256(62989462849862108569587628554995088811617742986890991868096613911337020263300))) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ** uint112(uint112(1894270148633568501330439165847661))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]) = ((int8(127) - (int8(0) | (int8((int8(0) / int8(0))) * int8(127)))), [new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3), new uint216[](3)], l0[(~(uint256(87670753664976807264636048129057858977246654719390324943545545296233010254008)))]);
      assert(l1 == (int8(127) - (int8(0) | (int8((int8(0) / int8(0))) * int8(127)))));
    }
    unchecked {
      assembly
      {
        i0 := i2
        let al0 := i1
      }
      bool l2 = true;
    }
    l0[uint256(93689907154673575300841628772884788910412448989496277793326865083801826103178)] = l0[uint256(0)];
  }
  event ev1(address payable indexed ep0);
  event ev2(function (address, bool) external    ep0);
}
pragma solidity >= 0.0.0;
using L1 for bytes;
// ----
// Warning 6133: (su0.sol:432-540): Statement has no effect.
// Warning 2072: (su0.sol:199-208): Unused local variable.
// Warning 2072: (su0.sol:231-241): Unused local variable.
// Warning 5667: (su0.sol:618-636): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:637-647): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1369-1376): Unused local variable.
// Warning 2018: (su0.sol:177-543): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:15-1507): Function state mutability can be restricted to pure
