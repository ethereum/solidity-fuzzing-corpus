
==== Source: su0.sol ====
library L0 {
  function f0(int248[][] memory i0,bool i1) internal   
  {
    int120 l0 = (int120(664613997892457936451903530140172287) % int120(664613997892457936451903530140172287));
    i0[((uint256((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & (uint256(15477075858064256167221837351246049082431536952802205281010797313993372680040) << uint192(uint192(6277101735386680763835789423207666416102355444464034512895)))) % uint256(0))] = (i0[(uint256(0) ^ ((~((i0.length >> uint120(uint120(0))))) + uint256(12843138598667560241381227317480393251319868855696955001331978042257037551347)))] = i0[(~(((((uint256(0) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint160(uint160(586995913398880349446914754661079869979425890151))) ^ uint256(59889542688380458902423859873669806650852585667154767428956331443295770989249)) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))))]);
  }
  modifier m0() 
  {
    bool l0 = (bytes30(0x000000000000000000000000000000000000000000000000000000000000) > (~((false ? bytes30(0x000000000000000000000000000000000000000000000000000000000000) : bytes30(0x000000000000000000000000000000000000000000000000000000000000)))));
    address l1 = address(0x0000000000000000000000000000000000000003);
    _;
    (l1) = (address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
    assert(l1 == address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))));
    _;
    bool l2 = true;
    _;
    bool l3 = (bytes1(0xff) == ((false ? (bytes1(0xff) | bytes1(0xff)) : bytes1(0xff)) ^ bytes1(0x00)));
  }
}
contract C0 {
  bool   s0 = false;
  mapping(bool => bytes)  public s1;
  constructor()   {
    s1[(true != false)] = bytes("0000000000000000000000000000003d49f767de31c31402ba20a5aa173e0765e0a91136bd4eea649057a2");
    unchecked {
      (s0) = (false);
      assert(s0 == false);
      {
      }
    }
  }
  using L0 for *;
  fallback() external   payable
  {
    bool  l0 = s0;
    bool  l1 = l0;
    assert(l1 == s0);
  }
}
pragma solidity >= 0.0.0;
using L0 for int248[][];
// ====
// ----
