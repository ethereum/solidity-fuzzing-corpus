==== Source:  ====

==== Source: su0.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23

}
bool constant cons0 = true;
type T0 is uint208;
pragma solidity >= 0.0.0;
contract C0 {
  bytes3   s0 = bytes3(0xffffff);
  mapping(address => function (EN0) external   returns (bytes5)[])  public s1;
  bytes2   s2 = bytes2(0x0000);
  address   s3 = address(this);
  constructor()   {
    {
      for(      payable(address(this));
;
T0.wrap(uint208(0)))
      {
        continue;
      }
    }
  }
  event ev0(bool  ep0);
  type T1 is address payable;
  struct St0 {
    C0.T1 el0;
    EN0 el1;
    bytes7[] el2;
    address el3;
  }
  modifier m0() virtual
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000e089bf11f83bd4412c42f8b0b2fc84f294f30ce3"));
    emit ev0(false);
    _;
  }
  uint72 public constant cons1 = ((uint72((uint72(0) / ((uint72(1617275141156464314693) ** uint72(uint72(4722366482869645213695))) % uint72(0)))) - uint72(0)) & uint72(781624138785521514245));
}
struct St1 {
  function (string[] memory, function (int200) external   returns (bool), EN0) external   returns (int216, EN0) el0;
  mapping(EN0 => uint208) el1;
}
// ----
// Warning 6133: (su0.sol:462-481): Statement has no effect.
