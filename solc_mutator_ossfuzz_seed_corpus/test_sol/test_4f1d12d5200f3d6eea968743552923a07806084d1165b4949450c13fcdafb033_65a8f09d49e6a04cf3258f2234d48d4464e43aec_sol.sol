
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  address payable immutable public s0;
  bytes18   s1 = bytes18(0xacbd963b97f2c33086701fd4b9ef430a90aa);
  mapping(bool => uint8)   s2;
  constructor(address payable i0)   {
    s0 = (false ? payable(address(this)) : payable(address(this)));
    s2[(int56(36028797018963967) != int56((int56(0) / ((int56(0) & int56(0)) % int56(0)))))] <<= ((((((uint8(255) % uint8(196)) + uint8(83)) * uint8(255)) - uint8(0)) | uint8(193)) + uint8(255));
    {
      bytes18  l0 = s1;
      bytes18  l1 = l0;
      assert(l1 == s1);
      bytes18  l2 = s1;
      bytes18  l3 = l2;
      assert(l3 == s1);
      unchecked {
        s1 ^= bytes18(bytes8(0xffffffffffffffff));
        bytes18  l4 = s1;
        bytes18  l5 = l4;
        assert(l5 == s1);
      }
      revert(string("fffffffffffffffffffffffffffffffffffffffffffffe5ce23c10a534d2543441cdd8f373559569b9b327"));
    }
  }
}
contract C1 {
  function f1(bytes11 i0) public virtual   returns(int56[10][][][][][5] memory o0)
  {
  }
  uint88   s3;
  bool   s4 = true;
  constructor(uint88 i0)   {
    s3 -= (((uint88(226270050259418438285422478) << uint216(uint216(0))) % (uint88(0) % uint88(0))) * uint88(309485009821345068724781055));
    {
      bool  l0 = s4;
      bool  l1 = l0;
      assert(l1 == s4);
      bool  l2 = s4;
      bool  l3 = l2;
      assert(l3 == s4);
      (s4) = ((int56((int56(36028797018963967) / ((int8(127) - int8(127)) % int56(36028797018963967)))) >= int56(0)));
      assert(s4 == (int56((int56(36028797018963967) / ((int8(127) - int8(127)) % int56(36028797018963967)))) >= int56(0)));
      uint88  l4 = s3;
      uint88  l5 = l4;
      assert(l5 == s3);
      (bool l6, bytes memory l7) = address(this).call(abi.encodeWithSignature("f1(bytes11)", bytes11(0xffffffffffffffffffffff)));
    }
  }
  fallback() external virtual  
  {
  }
}
contract C2 {
  fallback() external   
  {
  }
  uint152   s5 = uint152(0);
  uint208  public s6;
  C0   s7 = C0(payable(address(this)));
  address payable immutable  s8 = payable(address(this));
  constructor(uint208 i0)   {
    s6 &= uint208((((~((uint208(411376139330301510538742295639337626245683966408394965837152255) * (uint208(411376139330301510538742295639337626245683966408394965837152255) ^ uint208(271612760098081857304123767413188228209597414695724590075329196))))) % uint208(411376139330301510538742295639337626245683966408394965837152255)) / uint208(0)));
    unchecked {
      {
        C0  l0 = s7;
        C0  l1 = l0;
        assert(l1 == s7);
        uint152  l2 = s5;
        uint152  l3 = l2;
        assert(l3 == s5);
        uint152  l4 = s5;
        uint152  l5 = l4;
        assert(l5 == s5);
      }
      C0  l6 = s7;
      C0  l7 = l6;
      assert(l7 == s7);
    }
  }
  struct St0 {
    uint88 el0;
    string el1;
    address payable el2;
    int168[][] el3;
  }
}
struct St1 {
  address el0;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
