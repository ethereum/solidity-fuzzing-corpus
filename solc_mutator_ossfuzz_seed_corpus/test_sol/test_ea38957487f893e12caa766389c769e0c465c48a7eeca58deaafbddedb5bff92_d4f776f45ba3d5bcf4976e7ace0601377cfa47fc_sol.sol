
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(uint224 i0)     returns(int48 o0,bool o1)
{
  {
    function () external   returns (bytes32[9][][][9][][] memory) l0;
    address(0x0000000000000000000000000000000000000005);
    bool l1 = true;
  }
}
contract C0 {
  function f1() public   payable
  {
  }
  address immutable  s0;
  bytes11  public s1;
  address payable   s2;
  constructor(address i0,bytes11 i1,address payable i2) payable  {
    s0 = address(this);
    s1 |= (~(bytes11(0x0000000000000000000000)));
    s2 = payable(address(this));
    unchecked {
      s2 = payable(address(this));
      assert(s2 == payable(address(this)));
      address payable  l0 = s2;
      address payable  l1 = l0;
      assert(l1 == s2);
      bytes11  l2 = s1;
      bytes11  l3 = l2;
      assert(l3 == s1);
      for(uint solinit0 = 0; solinit0 < ((~((((uint256(92303074941118261015128857650111576533787633494035986226408812980830111485683) << uint192(uint192(6277101735386680763835789423207666416102355444464034512895))) ^ uint256(42654005654126797659227896016306039228002363864230457093358133066082508797240)) + uint256(0)))) % 11); solinit0++)
      {
        bool l4 = false;
        string memory l5 = string("0000000000000000000000000000000000000000000000");
      }
      address payable  l6 = s2;
      address payable  l7 = l6;
      assert(l7 == s2);
      address  l8 = s0;
      address  l9 = l8;
      assert(l9 == s0);
      address payable  l10 = s2;
      address payable  l11 = l10;
      assert(l11 == s2);
    }
  }
  struct St0 {
    address el0;
    mapping(uint144 => bool) el1;
  }
}
library L0 {
  event ev0(bytes14 indexed ep0, uint72  ep1);
  function f2(uint232 i0) external    returns(function () external   returns (uint232) o0)
  {
    (uint232 l0) = o0();
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
