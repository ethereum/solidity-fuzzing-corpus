
==== Source: su0.sol ====
struct St0 {
  bool el0;
  uint176 el1;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16
}
type T0 is bool;
contract C0 {
  modifier m0() 
  {
    _;
    _;
  }
  modifier m1() virtual
  {
    bytes memory l0 = "14d0825da72224144e3441135d828dc81b6d66ad3991";
    _;
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81
  }
  modifier m2(int72 i0) 
  {
    _;
    C0.EN1[] storage l0;
  }
  St0   s0 = St0(false, uint176(0));
  uint16  public s1 = uint16(30552);
  function f0() public  m0() 
  {
    T0 l0 = T0.wrap(true);
    if (s0.el0)
    {
      (s0.el0, s0.el1, s0.el0) = ((bytes5(0x0000000000) != bytes5(0xffffffffff)), uint176((((uint176(12212017991744911530240048300717995692295822964131833) ^ ((uint176(95780971304118053647396689196894323976171195136475135) ^ uint176(0)) | uint176(0))) >> uint120(uint120(1329227995784915872903807060280344575))) / uint176(0))), false);
      return;
    }
    else if (false)
    {
      assembly
      {
      }
      return;
      (bool l1, bytes memory l2) = address(this).call("12c3843abc880d2d16b2c839c19069431d815c7711521df5856d815c12c3000000");
    }
    else if ((bytes1(0xff) <= bytes1(0x1e)))
    {
      St0 memory l3 = St0(true, uint176(34847173829685882167773090496385777885814088786829776));
    }
    (bool l4, bytes memory l5) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  modifier m3() 
  {
    if ((bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff) != bytes27(0x000000000000000000000000000000000000000000000000000000)))
    {
      _;
    }
    else
    {
      for(      bytes2 l0 = bytes2(0x91f3);
s0.el0;
)
      {
        if (false)
        {
          (bool l1, bytes memory l2) = address(this).call("00ffffffffffffffffffffffffffffffffffffffffff");
        }
        else if (false)
        {
          (bool l3, bytes memory l4) = address(this).call(abi.encodeWithSelector(this.f0.selector));
        }
        else if (true)
        {
        }
      }
    }
    (bool l5, bytes memory l6) = address(this).call("c38f7fe7703450e19582129179acbab51d0432a8ebb1ce9818a2f3a7561ffe719aebdd62e9dcbe57a04c7b4ecc1b28430d9f5820f4d009c8");
    _;
  }
  type T1 is uint256;
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
  fallback() external  m1() 
  {
    if ((int224(0) >= (int224(13479973333575319897333507543509815336818572211270286240551805124607) % int224(-8809034372905581777371061310336312351332207390552665136101012869223))))
    {
    }
    else if ((true && (true ? (C0.EN1.M55 != C0.EN1(uint8(33))) : false)))
    {
      return;
      for(;
true;
)
      {
      }
    }
  }
  struct St1 {
    C0.T1 el0;
    uint8 el1;
    mapping(EN0 => T0) el2;
  }
}
pragma solidity >= 0.0.0;
address payable constant cons1 = payable(0xF76ba922d9aDf93e50E5bD4bC7e8cc1f6BE7e0fc);
error er0(address ep0);
// ====
// ----
