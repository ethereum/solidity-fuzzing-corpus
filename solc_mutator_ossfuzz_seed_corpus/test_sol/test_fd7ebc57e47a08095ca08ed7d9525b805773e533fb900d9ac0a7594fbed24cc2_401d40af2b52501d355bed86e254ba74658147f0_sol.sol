
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint152 el0;
  int192 el1;
  address el2;
  bool el3;
}
library L0 {
  function f0(int232[] memory i0,uint184 i1) private    returns(function () external   returns (int184, bool, bytes32) o0,St0 memory o1)
  {
    (i0[uint256((uint256(0) / (uint256(0) ^ ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(0)) ^ uint256(101201838338964470945435689486954461954448861087874244315364825746808241757162)))))], o1, o1.el3) = ((int232(-375224137619677269234652469420382400144211511042996865745639935757461) * (true ? (int88(0) * int88(0)) : int88(13409774042923772324458271))), St0(uint152(5708990770823839524233143877797980545530986495), int192(-2119340646908649868817323627738952953107658297201225249164), address(0x0000000000000000000000000000000000000007), false), true);
    assert(i0[uint256((uint256(0) / (uint256(0) ^ ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(0)) ^ uint256(101201838338964470945435689486954461954448861087874244315364825746808241757162)))))] == (int232(-375224137619677269234652469420382400144211511042996865745639935757461) * (true ? (int88(0) * int88(0)) : int88(13409774042923772324458271))));
    assert(o1.el3 == true);
    address payable l0 = payable(address(0x0000000000000000000000000000000000000004));
  }
  function f1(bool[10] memory i0,int232 i1,int240 i2) public    returns(string memory o0,bytes2 o1)
  {
    int232 l0 = (int232(-1388229721502559163612619904445091712913429520495735925262042201582865) % (-(int232((((~(int232(-2910619536950532002462147475072837333233539343174481743057029577017888))) * int232(3450873173395281893717377931138512726225554486085193277581262111899647)) / int232(3450873173395281893717377931138512726225554486085193277581262111899647))))));
  }
}
using L0 for int232[];
// ====
// ----
