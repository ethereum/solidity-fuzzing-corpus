==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L0 {
  error er0(function (bytes10, address) external   returns (function (bool) external   returns (bytes26, bytes15, bool), uint16) ep0, uint104[8] ep1);
}
pragma solidity >= 0.0.0;
struct St0 {
  bytes7 el0;
  bytes23 el1;
}
contract C0 {
  using L0 for *;
  using L0 for *;
  bytes1   s0 = bytes1(0xb1);
  bytes8   s1;
  int160   s2 = int160(331319539348089813274996117211184991390450895504);
  constructor(bytes8 i0)   {
    s1 |= bytes8(0xf10048157197d42c);
    {
      int160  l0 = s2;
      int160  l1 = l0;
      assert(l1 == s2);
      {
        {
          do
          {
            function (uint88, int216) external   l2;
            unchecked {
              assert((uint168(55927527069112633986697575838613314568998863009123) > (((uint168(21866446040036505538343063092348804193620674568698) * uint168(374144419156711147060143317175368453031918731001855)) + uint168(177400034252881883849881610851223530668178766427676)) % uint168(362242474581294767923464130148507513018455328353368))));
              bool l3 = false;
              bool l4 = ((bytes15(0x64cc28850d08f30efa81dbdcbf62f7) < bytes15(0x4dce2cae82c0eb6ac814a24a298277)) ? true : false);
            }
            bytes10 l5 = bytes9(0x0596f853dc76a42eb9);
          }
          while ((((~(uint144(0))) >> uint8(uint8(0))) < (uint144(0) & uint144(0))));
          bytes1  l6 = s0;
          bytes1  l7 = l6;
          assert(l7 == s0);
          int160  l8 = s2;
          int160  l9 = l8;
          assert(l9 == s2);
        }
        bytes8  l10 = s1;
        bytes8  l11 = l10;
        assert(l11 == s1);
        (bool l12, bytes memory l13) = address(this).call(bytes("0000000000ff"));
        do
        {
          (s0) = ((bytes1(0xff) & bytes1(0x00)));
          assert(s0 == (bytes1(0xff) & bytes1(0x00)));
        }
        while (false);
        unchecked {
          int160  l14 = s2;
          int160  l15 = l14;
          assert(l15 == s2);
        }
      }
      bytes1  l16 = s0;
      bytes1  l17 = l16;
      assert(l17 == s0);
      bytes("00000000000000000000000000000000000000000000000000ffff");
      bytes8  l18 = s1;
      bytes8  l19 = l18;
      assert(l19 == s1);
      int160  l20 = s2;
      int160  l21 = l20;
      assert(l21 == s2);
      int160  l22 = s2;
      int160  l23 = l22;
      assert(l23 == s2);
    }
  }
}
function f0()    
{
}
// ----
// Warning 6133: (su1.sol:2037-2100): Statement has no effect.
// Warning 5667: (su1.sol:419-428): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:603-642): Unused local variable.
// Warning 2072: (su1.sol:1024-1031): Unused local variable.
// Warning 2072: (su1.sol:1055-1062): Unused local variable.
// Warning 2072: (su1.sol:1197-1207): Unused local variable.
// Warning 2072: (su1.sol:1601-1609): Unused local variable.
// Warning 2072: (su1.sol:1611-1627): Unused local variable.
