==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0() private    returns(bool o0)
  {
    unchecked {
      int64 l0 = int64(0);
      int32[3] storage l1;
      o0 = true;
      assert(o0 == true);
      {
        function (int24[][][] memory, function (address, int32, bool) external   returns (uint8)) external   returns (bool[10][4][2] memory) l2;
        (l1[(uint256((((true ? uint256(0) : uint256(25595059734974606594643086750367483995291293736146011271856087813232007486863)) * uint256(0)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | uint256(0))], l1[(((((uint256(0) * uint256(0)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(18618278170283009117485541087720446407875091567064623470506321223624184000808)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(0))], l1[uint256(76267360619091310727047574199288523215131869190915769881105284561008273405614)], l1[uint256(0)]) = ((int32((int32(1675324697) / (int32(2147483647) % (int32(0) | int32(-1952462849))))) | int32(-374906218)), (-((int32(147716296) + (int32(518730158) * (int32(2147483647) & int32(2147483647)))))), int32(0), (l1[l1.length] ^ int32(2147483647)));
        assert(l1[(uint256((((true ? uint256(0) : uint256(25595059734974606594643086750367483995291293736146011271856087813232007486863)) * uint256(0)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | uint256(0))] == (int32((int32(1675324697) / (int32(2147483647) % (int32(0) | int32(-1952462849))))) | int32(-374906218)));
        assert(l1[(((((uint256(0) * uint256(0)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(18618278170283009117485541087720446407875091567064623470506321223624184000808)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(0))] == (-((int32(147716296) + (int32(518730158) * (int32(2147483647) & int32(2147483647)))))));
        assert(l1[uint256(76267360619091310727047574199288523215131869190915769881105284561008273405614)] == int32(0));
        assert(l1[uint256(0)] == (l1[l1.length] ^ int32(2147483647)));
        bool l3 = ((uint248(452312848583266388373324160190187140051835877600158453279131187530910662655) % (uint248(0) - (uint248(76638015706399011944279926438354884020345141848768167183922118789532626028) - uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)))) < uint248(452312848583266388373324160190187140051835877600158453279131187530910662655));
        bytes10 l4 = bytes10(0xffffffffffffffffffff);
      }
      address payable l5 = payable(address(this));
    }
    bool l6 = (false ? true : (true == false));
  }
  receive() external virtual  payable
  {
    bytes storage l0;
    address payable l1 = payable(address(this));
    function (function (int104, address payable) external   returns (function (uint96, bytes25) external   returns (uint168, bytes13[3][][][] memory)), address, bytes31) external   l2;
    int160 l3 = int160(0);
  }
  bytes20   s0;
  int96 immutable public s1 = int96(0);
  constructor(bytes20 i0)   {
    s0 ^= bytes9((bytes5(0xffffffffff) | bytes5(0x0000000000)));
    unchecked {
      payable(this).transfer(4106402853078037751);
      bytes20  l0 = s0;
      bytes20  l1 = l0;
      assert(l1 == s0);
      int96  l2 = s1;
      int96  l3 = l2;
      assert(l3 == s1);
      payable(this).transfer(16749902434292482572);
      int96  l4 = s1;
      int96  l5 = l4;
      assert(l5 == s1);
    }
  }
}
contract C1 {
  bytes29  public s2 = bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
}
struct St0 {
  int200 el0;
  bool[][6][][][][1] el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bytes24 el0;
  string el1;
  uint8 el2;
  int56 el3;
}
// ----
// TypeError 3464: (su0.sol:337-339): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:582-584): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:903-905): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:995-997): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1219-1221): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1222-1224): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1271-1273): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:1640-1642): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2067-2069): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2187-2189): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2206-2208): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
// TypeError 3464: (su0.sol:2209-2211): This variable is of storage pointer type and can be accessed without prior assignment, which would lead to undefined behaviour.
