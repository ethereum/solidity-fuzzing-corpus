==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
    function (int160[][][][] memory, uint192) external   returns (bytes32, function (bool, function (int200, int176[][8] memory, uint232[] memory) external  , bool) external   returns (bytes memory)) l0;
    function (address payable, int160, uint104) internal   returns (bool, bool) l1;
    bytes29 l2 = (~(bytes29(bytes5(bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)))));
  }
  fallback() external   
  {
  }
  mapping(address => bool)   s0;
  bytes   s1;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  address   s2 = address(this);
  constructor(bytes memory i0)   {
    s1 = bytes("7f9dffffffffffffffffffffffff");
    s0[address(this)] = true;
    unchecked {
      address  l0 = s2;
      address  l1 = l0;
      assert(l1 == s2);
      {
        {
          {
            s1.pop();
            (bool l2) = payable(this).send(0);
          }
        }
        s2 = address(this);
        assert(s2 == address(this));
        address  l3 = s2;
        address  l4 = l3;
        assert(l4 == s2);
        address  l5 = s2;
        address  l6 = l5;
        assert(l6 == s2);
        bytes memory l7 = s1;
        bytes memory l8 = l7;
        assert(compareMemoryAndStorage(l8, s1));
        {
          address  l9 = s2;
          address  l10 = l9;
          assert(l10 == s2);
          bytes memory l11 = s1;
          bytes memory l12 = l11;
          assert(compareMemoryAndStorage(l12, s1));
          address  l13 = s2;
          address  l14 = l13;
          assert(l14 == s2);
          address  l15 = s2;
          address  l16 = l15;
          assert(l16 == s2);
          for(uint solinit0 = 0; solinit0 < (uint256(0) % 11); solinit0++)
          {
          }
        }
        (bool l17, bytes memory l18) = payable(this).call{value: 0}("");
      }
      { }
      bytes memory l19 = s1;
      bytes memory l20 = l19;
      assert(compareMemoryAndStorage(l20, s1));
    }
  }
}
pragma solidity >= 0.0.0;
library L0 {
  function f2(string memory i0) private   
  {
    function (function (int88[][6][6] memory, address payable, bool[] memory) internal  , bytes6, function (address, address payable, bytes18) external   returns (string memory)) internal   returns (function (address payable) internal   returns (int88, bool[] memory, int64), int224) l0;
    (i0) = (string("ffffffffffffffffffffffffffffffffffffffffffbb240706fc050c2c6a5c"));
    assert(keccak256(bytes(i0)) == keccak256(bytes(string("ffffffffffffffffffffffffffffffffffffffffffbb240706fc050c2c6a5c"))));
    bytes17 l1 = bytes17(0xffffffffffffffffffffffffffffffffff);
  }
  function f3(function (bytes6) external   returns (uint256, string memory) i0,address payable i1,bytes2 i2) internal    returns(bool o0,bool o1,function (address payable, int208, bool[] memory) external   returns (bool, int232) o2)
  {
    assert((payable(address(bytes20(address(0xb5b9ee707aD7291E789ca72489B86938255C63f7)))) > payable(address(0x0000000000000000000000000000000000000003))));
    function (bytes9, bool[10] memory, bool) internal   returns (bool) l0;
    bool l1 = true;
  }
}
using L0 for string;
contract C1 {
  using L0 for *;
  receive() external   payable
  {
    address payable l0 = payable(address(bytes20(address(0x0000000000000000000000000000000000000000))));
  }
  uint32[10]   s3 = [uint32(165112603), uint32(4294967295), uint32(4294967295), uint32(0), uint32(4294967295), uint32(4294967295), uint32(394355854), uint32(4294967295), uint32(0), uint32(4294967295)];

	function compareMemoryAndStorage(uint32[10] memory v1, uint32[10] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
}
// ----
// Warning 2072: (su0.sol:60-258): Unused local variable.
// Warning 2072: (su0.sol:264-342): Unused local variable.
// Warning 2072: (su0.sol:348-358): Unused local variable.
// Warning 5667: (su0.sol:749-764): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1001-1008): Unused local variable.
// Warning 2072: (su0.sol:1896-1904): Unused local variable.
// Warning 2072: (su0.sol:1906-1922): Unused local variable.
// Warning 2072: (su0.sol:2187-2469): Unused local variable.
// Warning 2072: (su0.sol:2690-2700): Unused local variable.
// Warning 5667: (su0.sol:2768-2832): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2833-2851): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2852-2861): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2883-2890): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2891-2898): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2899-2985): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:3152-3221): Unused local variable.
// Warning 2072: (su0.sol:3227-3234): Unused local variable.
// Warning 2072: (su0.sol:3341-3359): Unused local variable.
// Warning 2018: (su0.sol:2138-2753): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:2756-3246): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:3650-3900): Function state mutability can be restricted to view
