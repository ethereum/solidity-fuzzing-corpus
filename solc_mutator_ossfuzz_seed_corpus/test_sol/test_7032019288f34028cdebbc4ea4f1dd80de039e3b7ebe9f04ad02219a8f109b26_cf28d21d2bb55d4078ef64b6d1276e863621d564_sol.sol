==== Source:  ====

==== Source: su0.sol ====
function f0()     returns(bytes12 o0,function (uint216[][][][5][][] memory) external   returns (bool, address payable, uint192[] memory) o1)
{
  uint168 l0 = (uint104(0) | ((uint168(374144419156711147060143317175368453031918731001855) * uint168(211440847038844349309156451000906839957895626558689)) % uint168(15978630748210691423748866462885115796198844249294)));
  bytes17 l1 = bytes17(0x0000000000000000000000000000000000);
}
contract C0 {
  bool immutable  s0;
  uint56   s1;
  bool   s2 = true;
  constructor(bool i0,uint56 i1)   {
    s0 = (((uint136(0) % uint136(87112285931760246646623899502532662132735)) ^ (~(uint136(1312953840558759541081282421846646639686)))) > uint136(0));
    s1 *= ((uint56(72057594037927935) - ((uint56(72057594037927935) - uint56(36131835144726765)) & uint56(49036337132413577))) % uint56(72057594037927935));
    unchecked {
      {
        (bytes12 l0, function (uint216[][][][5][][] memory) external   returns (bool, address payable, uint192[] memory) l1) = f0();
        uint56  l2 = s1;
        uint56  l3 = l2;
        assert(l3 == s1);
        bool  l4 = s2;
        bool  l5 = l4;
        assert(l5 == s2);
        uint88(151911402511419686221476790);
      }
      if (((int64(437862024804439315) + int64(0)) <= (int64(-4492271042790611733) ^ int64(0))))
      {
        {
          uint56  l6 = s1;
          uint56  l7 = l6;
          assert(l7 == s1);
          uint56  l8 = s1;
          uint56  l9 = l8;
          assert(l9 == s1);
        }
        (bool l10, bytes memory l11) = address(this).call((true ? bytes("0813f08effff") : (false ? bytes("edae0000000000000000000000000000000000000000000000") : bytes("7cf8935a88bf3a455e27fe09360a6d35b50b2f22143a3ca45e0000000000000000000000000000000000000000"))));
      }
      else
      {
        bool  l12 = s0;
        bool  l13 = l12;
        assert(l13 == s0);
        revert(string("ffffffffffffffffff000000000000000000000000"));
      }
      revert(string.concat(string("ffffffffffffffffffffffffffffffffffffffffff"), string("000000000000ffffffffffffffffffffffffffffffffffffffff"), (false ? string("00000000000000000000000000000000fbace4b147630ba245b0362e34144ebd0f6816d31b3eb057f0d05e8db4dd") : string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"))));
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 {
  address payable  public s3;
  uint8   s4 = uint8(255);
  int256   s5;
  constructor(address payable i0,int256 i1) payable  {
    s3 = payable(address(this));
    s5 &= (((int256(0) ^ int256(0)) + i1) ** uint192(uint192(0)));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000ffffffffffffff"));
      int256  l2 = s5;
      int256  l3 = l2;
      assert(l3 == s5);
      int256  l4 = s5;
      int256  l5 = l4;
      assert(l5 == s5);
    }
  }
}
// ----
// Warning 5667: (su0.sol:26-36): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:37-139): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:145-155): Unused local variable.
// Warning 2072: (su0.sol:366-376): Unused local variable.
// Warning 6133: (su0.sol:1156-1191): Statement has no effect.
// Warning 5667: (su0.sol:513-520): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:521-530): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:876-886): Unused local variable.
// Warning 2072: (su0.sol:888-990): Unused local variable.
// Warning 2072: (su0.sol:1498-1506): Unused local variable.
// Warning 2072: (su0.sol:1508-1524): Unused local variable.
// Warning 5667: (su0.sol:2429-2447): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2593-2600): Unused local variable.
// Warning 2072: (su0.sol:2602-2617): Unused local variable.
// Warning 2018: (su0.sol:0-427): Function state mutability can be restricted to pure
