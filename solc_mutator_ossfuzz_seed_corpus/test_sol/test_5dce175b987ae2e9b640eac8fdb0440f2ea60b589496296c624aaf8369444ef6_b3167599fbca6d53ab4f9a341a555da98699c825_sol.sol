
==== Source: su0.sol ====
struct St0 {
  int192 el0;
  address el1;
  address payable el2;
  int176 el3;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  uint224 el0;
  mapping(address => bytes17) el1;
  int88 el2;
  bool el3;
}
contract C0 {
  event ev0(function (int176, string memory, int144) external   returns (bool, bytes32, bytes10) indexed ep0, bytes18  ep1, bool  ep2);
  bool   s0 = true;
}
contract C1 is C0 {
  address payable public constant cons0 = payable(0x575048FE2733d3D13C5C6449f2c8449Da60b01ab);
  bool   s1;
  St1   s2;
  uint128   s3 = uint128(22298110162012954883793355662727221533);
  bytes3   s4;
  constructor(bool i0,bytes3 i1) payable  {
    s1 = true;
    s4 &= bytes3(0xffffff);
    {
    }
  }
  function f0(bytes3 i0) external   payable  returns(int168 o0)  {
    o0 &= int16(9559);
    (s3) = ((uint128(262150955690376108209855026748825551517) % (uint128(0) | uint128(0))));
    assert(s3 == (uint128(262150955690376108209855026748825551517) % (uint128(0) | uint128(0))));
  }
  function f1(uint128 i0,uint128 i1,bytes3 i2) public      {
    (bool l0, bytes memory l1) = address(this).delegatecall(abi.encodeWithSignature("f0(bytes3)", bytes2(0xe3df)));
    s2.el0 /= uint224(13881709143012114266150292122699690548404971708254524150848919193946);
    if (i2 != bytes3(0x000000))
    {
    }
    for(uint solinit0 = 0; solinit0 < ((uint256((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) % (int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) & int256(-5398912791741561133907612747675824759994378827010458642583827052898341600428)))) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
    {
      continue;
    }
  }
  type T0 is bool;
}
// ====
// ----
