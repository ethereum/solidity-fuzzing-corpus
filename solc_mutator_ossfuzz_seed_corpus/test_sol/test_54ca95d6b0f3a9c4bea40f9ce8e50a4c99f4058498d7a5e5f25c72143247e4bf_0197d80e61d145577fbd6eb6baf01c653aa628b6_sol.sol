
==== Source: su0.sol ====
contract C0 {
  int200   s0;
  uint24  public s1;
  mapping(uint184 => uint152)   s2;
  constructor(int200 i0,uint24 i1)   {
    s0 &= (~(((int200(0) ^ ((int200(803469022129495137770981046170581301261101496891396417650687) ^ int200(398808008296887236687185605711092421270147101314826332773685)) - int200(0))) | int200(803469022129495137770981046170581301261101496891396417650687))));
    s1 *= uint24(16777215);
    s2[(((uint184(0) + ((uint184(0) | uint184(0)) - uint184(2027027356860641051609340945797740407876996589696233729))) & uint184(24519928653854221733733552434404946937899825954937634815)) | uint184(0))] *= (((~((uint152(((uint152(0) << uint72(uint72(1061818743174113610361))) / uint152(3564084281780013734512864649266478351689659626))) ** uint72(uint72(2927674221422706484660))))) | uint152(2568202257712929443217361127519833062122041785)) * uint152(0));
    {
      uint24  l0 = s1;
      uint24  l1 = l0;
      assert(l1 == s1);
      uint24  l2 = s1;
      uint24  l3 = l2;
      assert(l3 == s1);
      int200  l4 = s0;
      int200  l5 = l4;
      assert(l5 == s0);
      for(      address payable l6 = payable(address(this));
(uint168(0) <= (~(uint168(((false ? uint48(125928671425766) : uint48(147759547319731)) % uint48(281474976710655))))));
)
      {
      }
      int200  l7 = s0;
      int200  l8 = l7;
      assert(l8 == s0);
    }
  }
  function f0(int200 i0) public   payable returns(address payable o0)
  {
  }
  function f1(uint24 i0,bytes31 i1) public virtual  
  {
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
