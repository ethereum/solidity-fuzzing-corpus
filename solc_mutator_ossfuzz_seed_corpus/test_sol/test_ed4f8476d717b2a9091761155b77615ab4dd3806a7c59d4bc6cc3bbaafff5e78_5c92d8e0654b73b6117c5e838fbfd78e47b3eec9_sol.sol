==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()    
{
  function (function (bool, bytes memory) external  , bool) external   l0;
  {
    for(uint solinit0 = 0; solinit0 < (((((~(uint256((int256(-22070822896737055496415451573671099373183245607907187832940180771268919528857) | int256(-53579394812907300410150205732091008006693865755772606224009874236695540882770))))) << uint64(uint64(0))) | uint256(55557858378602405691335024036762409238658797772459182534703338966446561154270)) << uint56(uint56(0))) % 11); solinit0++)
    {
      int200 l1 = (((int200((((uint160(0) <= uint160(1461501637330902918203684832716283019655932542975)) ? int200(803469022129495137770981046170581301261101496891396417650687) : int200(0)) / int200(-761453750843157014765251191596322420984643772440341061175520))) - int200(0)) ** uint200(uint200(203119251571323772672554543981665752335855092543930006084519))) + int200(803469022129495137770981046170581301261101496891396417650687));
      return;
    }
    assert(false);
    address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    function () external   returns (int120, bytes1) l2;
    int80[][4][8] memory l3 = [[new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)], [new int80[](2), new int80[](2), new int80[](2), new int80[](2)]];
    function () internal   returns (int256, bytes memory, function () external   returns (bytes memory, string memory)) l4;
  }
  bool l5 = false;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bool[][5][4] el0;
  address el1;
}
contract C0 {
  address payable   s0 = payable(address(this));
  mapping(int112 => int88)  public s1;
  bytes12   s2 = bytes12(0xffffffffffffffffffffffff);
  int184   s3 = int184(0);
  constructor()   {
    s1[(int112(0) % ((int112(((int112(0) + int112(0)) / int112(0))) | int112(2596148429267413814265248164610047)) * int112(2379383487712638996705394445499491)))] |= ((int88(-11418236092790819714527747) * int88(((int112(0) + int112(2596148429267413814265248164610047)) ^ int112(0)))) - int88(154742504910672534362390527));
    unchecked {
      int184  l0 = s3;
      int184  l1 = l0;
      assert(l1 == s3);
      bytes12  l2 = s2;
      bytes12  l3 = l2;
      assert(l3 == s2);
      int184  l4 = s3;
      int184  l5 = l4;
      assert(l5 == s3);
    }
  }
  receive() external   payable
  {
    {
      revert(string("73f5d5e34ee3779e75ab3926adb62cf908c43a00025158e90dffff"));
    }
    { }
    address payable  l0 = s0;
    address payable  l1 = l0;
    assert(l1 == s0);
    (bool l2) = payable(this).send(0);
  }
}
// ----
// Warning 5740: (su0.sol:500-510): Unreachable code.
// Warning 5740: (su1.sol:970-1054): Unreachable code.
// Warning 5740: (su1.sol:1060-1093): Unreachable code.
// Warning 6133: (su0.sol:993-1062): Statement has no effect.
// Warning 2072: (su0.sol:48-119): Unused local variable.
// Warning 2072: (su0.sol:524-533): Unused local variable.
// Warning 2072: (su0.sol:1068-1118): Unused local variable.
// Warning 2072: (su0.sol:1124-1147): Unused local variable.
// Warning 2072: (su0.sol:1684-1802): Unused local variable.
// Warning 2072: (su0.sol:1810-1817): Unused local variable.
// Warning 2072: (su1.sol:1061-1068): Unused local variable.
// Warning 2018: (su0.sol:26-1828): Function state mutability can be restricted to pure
