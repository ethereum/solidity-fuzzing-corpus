==== Source:  ====

==== Source: su0.sol ====
function f0()    
{
  bool l0 = (int232(-2162751645907623101877719764211054214502899013524089270281569055179399) < ((((bytes7(0x90813b7b52ffbb) == bytes7(0x00000000000000)) ? payable(address(0x0000000000000000000000000000000000000003)) : payable(address(0x0000000000000000000000000000000000000005))) <= payable(address(0x0000000000000000000000000000000000000003))) ? int232(0) : int232(2344802396080310859411670622980584657538889018778343687091590593772158)));
  assembly
  {
    switch 14380238100378858453385833486049588387330593744123837767277297487106663672915
    case 0
    {
      calldatacopy(add(0x80, mod(l0, 1024)), l0, mod(l0, 1024))
    }
    let al0 := 0
  }
  uint208 l1 = uint208(uint240(((((uint240(0) % uint240(685912903556983052366879110352240958472371729941447533205735293503161794)) ^ uint240(575668883536705649634109058195905158834043929856095416038237117680667247)) + uint240(1766847064778384329583297500742918515827483896875618958121606201292619775)) / uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))));
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L0 {
  function f1(bool i0) public   
  {
  }
  modifier m0() 
  {
    _;
  }
  event ev0(uint144  ep0, uint72  ep1, bool  ep2);
}
struct St0 {
  uint152 el0;
  mapping(bytes20 => bytes7) el1;
  address el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  payable
  {
    do
    {
      require((((uint152(5708990770823839524233143877797980545530986495) - ((uint152(4014406338392239201749782237584571259206705446) << uint16(uint16(65535))) + uint152(5708990770823839524233143877797980545530986495))) ** uint24(uint24(5674953))) <= uint152(0)));
    }
    while (true);
    bool l0 = false;
    address[] memory l1 = new address[](5);
    bool l2 = false;
  }
  address payable   s0;
  address payable immutable  s1 = payable(address(this));
  int176   s2;
  bytes19   s3;
  constructor(address payable i0,int176 i1,bytes19 i2) payable  {
    s0 = (false ? payable(address(this)) : (((uint96(0) | uint96(79228162514264337593543950335)) == uint96(79228162514264337593543950335)) ? payable(address(this)) : payable(address(this))));
    s2 *= ((true ? int176(-40281500425494103634814498412389629467820880632014830) : ((int176(47890485652059026823698344598447161988085597568237567) ^ int176(47890485652059026823698344598447161988085597568237567)) * int176(0))) - int176(-34404025663048646778489281863558025623832925624205612));
    s3 ^= ((bytes19(0x00000000000000000000000000000000000000) | bytes19(0xd7d02b0dd4ad3fc91959bb364db8be3e1fb98c)) ^ bytes19(0x00000000000000000000000000000000000000));
    unchecked {
    }
  }
  using L0 for *;
}
// ----
// Warning 2072: (su0.sol:675-685): Unused local variable.
// Warning 2072: (su1.sol:606-613): Unused local variable.
// Warning 2072: (su1.sol:627-646): Unused local variable.
// Warning 2072: (su1.sol:671-678): Unused local variable.
// Warning 5667: (su1.sol:819-837): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:838-847): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:848-858): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:0-1065): Function state mutability can be restricted to pure
