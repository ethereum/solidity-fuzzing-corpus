
==== Source: su0.sol ====
contract C0 {
  bool public constant cons0 = true;
  type T0 is uint32;
  error er0(int128 ep0);
  struct St0 {
    bytes23 el0;
    bytes5[2] el1;
    int224 el2;
  }
  event ev0(string  ep0, bool indexed ep1, string indexed ep2, function (C0.St0 memory, bytes3[] memory, uint168) external   returns (int144)  ep3);
  C0.St0  public s0;
  error er1(bytes ep0);
  modifier m0() 
  {
    _;
    _;
    if (((int152(2854495385411919762116571938898990272765493247) ** uint104(((~(uint104(0))) & uint104(7482291299100804164191425052338)))) <= int152(0)))
    {
      _;
      if (true)
      {
      }
      else if (false)
      {
      }
    }
    else if (true)
    {
    }
    else
    {
    }
  }
  receive() external  m0() payable
  {
    while (false)
    {
    }
    (bool l0, bytes memory l1) = payable(this).call{value: 16692135933988003379}("");
    if (true)
    {
    }
    else if (true)
    {
    }
    else if (cons0)
    {
      if (true)
      {
      }
      else
      {
      }
    }
    (s0.el0) = (bytes23(0x853a4c4c54fcce377e6d52d6603869418e30dcf9fe3a78));
  }
}
error er2();
struct St1 {
  uint136 el0;
  string el1;
  mapping(address => int160) el2;
  bool el3;
}
int96 constant cons1 = (~((((int96(-13853143972200892857968451569) - (int96(5608733263795934171957695113) - int96(20496001551806218066529401595))) & int96(11446916507276725358549847482)) ^ int96(39614081257132168796771975167))));
pragma solidity >= 0.0.0;
function f1()     returns(C0.T0 o0)
{
  assembly
  {
    function af0() -> ao0, ao1, ao2
    {
      ao0 := calldataload(mod(ao2, calldatasize()))
      for 
      {
        let al0 := calldataload(mod(45213901545983763944782589956893497841106582240075371910307330190585382495224, calldatasize()))
      }
      79614262329018620686225138042902378534215340340650986259278267140127397100182
      {
      }
      {
        stop()
        switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          ao1 := ao0
        }
        case 0
        {
        }
        case 0
        {
          selfdestruct(or(ao2, 0))
        }
      }
      switch ao0
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        switch ao0
        case 0
        {
          pop(ao1)
        }
        default
        {
          switch ao0
          default
          {
            for 
            {
            }
            115792089237316195423570985008687907853269984665640564039457584007913129639935
            {
              switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
              default
              {
              }
              let al1, al2, al3 := af0()
            }
            {
              function af1(ai0, ai1, ai2, ai3) -> ao3, ao4
              {
                let al4 := 70796010305619483472294231594560736980086684635465355164121549684931680451491
              }
              revert(98303102436397013814235151669241689239616865063071723639385739375788664217903, ao0)
              ao0 := ao1
            }
          }
        }
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        let al5, al6, al7 := af0()
      }
    }
  }
}
// ====
// ----
