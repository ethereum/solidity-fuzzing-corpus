
==== Source: su0.sol ====
struct St0 {
  uint248 el0;
  mapping(int80 => int40) el1;
  bytes25 el2;
  bytes el3;
}
pragma solidity >= 0.0.0;
library L0 {
  function f0() private   
  {
  }
  function f1(bytes7 i0,bytes27 i1) private   
  {
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  
  {
    do
    {
      uint240[][][4] memory l0 = [new uint240[][](10), new uint240[][](10), new uint240[][](10), new uint240[][](10)];
      unchecked {
        l0[((((uint256(63669729698253057937559474041086403351742135162867503189759529559598633338859) + payable(address(this)).balance) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(0)) ** uint96(uint96(79228162514264337593543950335)))] = new uint240[][](10);
        assembly
        {
          switch 44178589059639036830896363227319258677953345329591596909169503655627625755255
          default
          {
          }
          returndatacopy(add(0x80, mod(l0, 1024)), l0, mod(l0, 1024))
        }
      }
      address l1 = address(this);
      (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffff000000000000000000000000000000000000000000"));
    }
    while (true);
    (bool l4, bytes memory l5) = address(this).call(((bytes17(0xd0ec5e195f417cf2f9049d7dc5e503a5ab) != (bytes17(0x0000000000000000000000000000000000) & (bytes17(0x0000000000000000000000000000000000) ^ bytes17(0x36daf75e53885a0488ec5ada9223c6d314)))) ? bytes("0aea18b42d7e3a6304000000000000000000000000000000000000000000000000") : bytes("cd5b00000000")));
  }
  uint224   s0 = uint224(26959946667150639794667015087019630673637144422540572481103610249215);
  address immutable  s1 = address(this);
  bool   s2 = false;
  bytes10 immutable  s3 = bytes10(0x4516941c2216f9238fe8);
}
// ====
// ----
