
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  uint48 el0;
  mapping(int120 => bool) el1;
  bool el2;
}
contract C0 {
  event ev0(bytes2  ep0);
  function f0(int240 i0) private      {
    return;
  }
  mapping(uint72 => uint64)   s0;
  constructor()   {
    s0[uint72(0)] += uint64(5549523376304747959);
    unchecked {
    }
  }
}
function f1(uint40 i0)     {
}
bytes5 constant cons0 = bytes5(0xffffffffff);

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
function f2()      returns(bytes23 o0){
  o0 ^= bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff);
}
contract C1 {
  error er0(bytes31 ep0);
  fallback() external   
  {
  }
  bool  public s1;
  int144   s2;
  constructor(bool i0,int144 i1)   {
    s1 = false;
    s2 = int72(((((-((int72(2361183241434822606847) + int72(0)))) - int72(1705196095622335023538)) ^ int72(2218813121023592595632)) / int72(2361183241434822606847)));
    unchecked {
      if (i1 > ((((-((~((~(int144(0))))))) - int144(0)) - int144(6160804506751665891396954674807959615431679)) * int144(11150372599265311570767859136324180752990207)))
      {
      }
    }
  }
  function f4(int144 i0,int144 i1) internal virtual    returns(bool o0,bool o1,uint168 o2)  {
    require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
    o2 ^= uint168(106029097280144826303930504474416607974840706856711);
    int144  l0 = s2;
    int144  l1 = l0;
    assert(l1 == s2);
  }
}
// ====
// ----
