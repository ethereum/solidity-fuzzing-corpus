==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  function (bool, bytes memory, int232) external   el0;
  address payable el1;
  bool el2;
  address el3;
}
pragma solidity >= 0.0.0;
library L0 {
  function f0() public    returns(bool o0,bytes20 o1)
  {
  }
  event ev0(bool  ep0, address  ep1, bytes19  ep2);
}
contract C0 {
  using L0 for *;
  function f1() external virtual   returns(function () external   returns (bool) o0,bool o1)
  {
    function (uint216, address payable, address payable) external   returns (int216, uint96[5][5][][][8][10] memory) l0;
    int232 l1 = (((int232(1715799393400658415599719336660711558493073040343995595918005704378585) % (int232(3450873173395281893717377931138512726225554486085193277581262111899647) % int232(-2736141102303830419807409770381944735608019709357048298187740336746720))) + int232(3450873173395281893717377931138512726225554486085193277581262111899647)) ^ int232(3450873173395281893717377931138512726225554486085193277581262111899647));
    address payable l2 = payable(address(this));
    unchecked {
      o1 = false;
      assert(o1 == false);
      assert(o0());
      function (bytes25, function (bool) external   returns (bool, address)) external   returns (address payable, bytes7) l3;
      (o1, o1) = (true, true);
      assert(o1 == true);
      assert(o1 == true);
    }
  }
  using L0 for *;
  St0   s0;

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}  bool[6]   s1;

	function compareMemoryAndStorage(bool[6] memory v1, bool[6] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  address   s2 = address(this);
  constructor(bool[6] memory i0)   {
    s1 = i0;
    {
      address  l0 = s2;
      address  l1 = l0;
      assert(l1 == s2);
      (s0.el3) = (address(this));
      assert(s0.el3 == address(this));
      bool[6] memory l2 = s1;
      bool[6] memory l3 = l2;
      assert(compareMemoryAndStorage(l3, s1));
      St0 memory l4 = s0;
      St0 memory l5 = l4;
      assert(compareMemoryAndStorage(l5, s0));
    }
  }
  receive() external virtual  payable
  {
    for(uint solinit0 = 0; solinit0 < (((uint256(77999631972923313072052579431361814090672249541462012299724164150849872629810) % uint256(40414064094454089234815695667409225868171026639214262991382046795738270908332)) * (uint256(39239102056608474093082464901512196534165371699283862832977895902197233599375) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) % 11); solinit0++)
    {
      int192 l0 = int192((int192((int192(0) / (((int192(1638759300156082829384522223544369126001264824492641942174) ^ int192(0)) ** uint104(uint104(9829905102445024123764430827921))) ** uint144(uint144(11570935956695262578050754433695603974646164))))) / int192(3138550867693340381917894711603833208051177722232017256447)));
      int32 l1 = (((int32(0) ^ int32(((int32(0) - int32(-1341283685)) / int32(0)))) ^ int32(2147483647)) ^ int32(853278265));
      function (bool, uint224) internal   l2;
    }
    address  l3 = s2;
    address  l4 = l3;
    assert(l4 == s2);
  }
}
// ----
// Warning 2072: (su0.sol:409-524): Unused local variable.
// Warning 2072: (su0.sol:530-539): Unused local variable.
// Warning 2072: (su0.sol:959-977): Unused local variable.
// Warning 2072: (su0.sol:1091-1209): Unused local variable.
// Warning 2072: (su0.sol:2813-2822): Unused local variable.
// Warning 2072: (su0.sol:3137-3145): Unused local variable.
// Warning 2072: (su0.sol:3263-3301): Unused local variable.
// Warning 2018: (su0.sol:1336-1628): Function state mutability can be restricted to view
// Warning 2018: (su0.sol:1646-1890): Function state mutability can be restricted to view
