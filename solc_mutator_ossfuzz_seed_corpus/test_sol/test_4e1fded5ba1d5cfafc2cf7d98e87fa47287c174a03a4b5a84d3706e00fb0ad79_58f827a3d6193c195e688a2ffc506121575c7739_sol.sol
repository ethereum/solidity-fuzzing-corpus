
==== Source: su0.sol ====
contract C0 {
  function f0(uint48 i0) public   payable   {
    if (i0 != (uint48(0) | uint48(281474976710655)))
    {
    }
    else
    {
    }
    if (i0 <= ((uint48(281474976710655) << uint72((((uint72(4722366482869645213695) - uint72(4722366482869645213695)) >> uint224(uint224(18618282499701353155490804082950809443534403707044187807628455446528))) * uint72(0)))) ** uint152(uint152(0))))
    {
      address l0 = address(this);
      if (i0 < ((uint32(4294967295) * ((uint32(131351176) | uint32(2343399556)) - uint32(4294967295))) ^ uint48(281474976710655)))
      {
      }
    }
  }
  receive() external virtual  payable
  {
    this.f0({i0: (uint48(281474976710655) + ((((uint48(281474976710655) % uint48(281474976710655)) + uint48(131653018905219)) * uint48(281474976710655)) ^ uint48(239618817869571)))});
  }
  event ev0(int248[]  ep0);
  function f2(int240 i0) public   payable  returns(bytes memory o0)  {
    do
    {
      if (i0 > ((int240(0) | int240(883423532389192164791648750371459257913741948437809479060803100646309887)) ** uint184((~((uint184(0) - uint184(21579077008812656460899870768538893239027479672905038954)))))))
      {
        if (i0 != (int240(((int240(-785598051783602226914308042761826437849492969475811750251290338170273795) * ((int240(334529539669588320038295226705763617633548204255404580561559414019535894) + int240(849190480168857564085050451087632199541115817812336042255008101433279615)) ^ int240(568044051737167251385888670131171908896390633104562459912231506732218730))) / int240(0))) | int240(883423532389192164791648750371459257913741948437809479060803100646309887)))
        {
          function (uint40, int16) internal   returns (uint248, bytes10, int168)[] storage l0;
        }
        continue;
      }
      break;
    }
    while ((int168(96392206909868136379514583047348934378539359801449) > (int168(0) * int168(-138988464102616121442586643403449983519665180046316))));
  }
  int184  public s0;
  uint96  public s1 = uint96(0);
  uint64   s2 = uint64(12508131734358839158);
  constructor(int184 i0) payable  {
    s0 ^= ((int184(0) | int184(0)) * ((int184(12259964326927110866866776217202473468949912977468817407) % int184(2734811733004624182408315792362987798910879699865698196)) ^ int184(4334334938216386100010395719289800054000077001879789745)));
    unchecked {
    }
  }
}
struct St0 {
  function (address, string memory, int80) external   el0;
}
pragma solidity >= 0.0.0;
contract C1 {
  bytes20   s3 = bytes20(address(0xB181Cc8A74DCBfE7b75970c52B96D191ACD4b81D));
  uint168   s4 = uint168(374144419156711147060143317175368453031918731001855);
  C0   s5 = C0(payable(address(this)));
  bytes  public s6 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffff92fced8247");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f3() external      {
    revert((true ? (false ? string.concat(string("This is a really long string that must ideally be random but is currently hard coded")) : string("This is a really long string that must ideally be random but is currently hard coded")) : string("This is a really long string that must ideally be random but is currently hard coded")));
  }
  function f4() external   payable   {
    (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  struct St1 {
    C0 el0;
  }
  type T0 is int224;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St2 {
  string el0;
  int8 el1;
  bytes8 el2;
  string el3;
}
struct St3 {
  St2 el0;
  int256 el1;
  int96 el2;
}
// ====
// ----
