==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() external virtual  payable  returns(int24 o0)  {
    return ((int24((int24(0) / ((-(int24(2486581))) % int24(0)))) ** uint144(uint144(16641173355392638281020710014047623827214639))));
  }
  address  public s0;
  int248  public s1;
  bool  public s2;
  address   s3 = address(this);
  constructor(address i0,int248 i1,bool i2) payable  {
    s0 = address(bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)));
    s1 ^= (((((int248(-84788359483418057611005913710704468043665873590960711371289266105641291384) & int248(-113399019498373296719316915783438171256905767696326441363018323591723213819)) ** uint160(uint160(1177551021756904701769294174259879543031907535038))) | int248(0)) * int248(-51123482795329586582656664691259555502391288065629992305328345929599688340)) & int248(46993747030752832279041238659482297117454523330356508710547244424272158416));
    s2 = true;
    unchecked {
    }
  }
  fallback() external   payable
  {
    address  l0 = s0;
    address  l1 = l0;
    assert(l1 == s0);
    s3 = address(this);
    assert(s3 == address(this));
    try this.f0() returns (int24 l2)
    {
      if (false)
      {
        if (true)
        {
          return;
        }
        delete s0;
        (bool l3, bytes memory l4) = address(this).call(abi.encodeWithSignature("f0()"));
      }
      if (((false ? (true ? (true ? payable(address(this)) : payable(address(this))) : payable(address(this))) : payable(address(this))) <= payable(address(this))))
      {
        (int24 l5) = this.f0();
      }
    }
    catch
    {
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94, M95,
  M96, M97, M98, M99, M100, M101, M102, M103,
  M104, M105, M106, M107, M108, M109, M110, M111,
  M112, M113, M114, M115, M116, M117, M118, M119,
  M120, M121, M122, M123, M124, M125
}

==== Source: su1.sol ====
struct St0 {
  function () external   returns (bytes memory, bool, bytes20) el0;
  string el1;
  function (uint240) external   returns (string memory, uint40, bytes6) el2;
}
pragma solidity >= 0.0.0;
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45
}
// ----
// Warning 3628: (su0.sol:26-1605): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 3149: (su0.sol:117-235): The result type of the exponentiation operation is equal to the type of the first operand (int24) ignoring the (larger) type of the second operand (uint144) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:351-361): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:362-371): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:372-379): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1145-1153): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1270-1277): Unused local variable.
// Warning 2072: (su0.sol:1279-1294): Unused local variable.
// Warning 2072: (su0.sol:1541-1549): Unused local variable.
