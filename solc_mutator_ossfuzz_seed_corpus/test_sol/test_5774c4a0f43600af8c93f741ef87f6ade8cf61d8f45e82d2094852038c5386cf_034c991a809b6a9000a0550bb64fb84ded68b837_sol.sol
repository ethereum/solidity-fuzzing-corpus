
==== Source: su0.sol ====
function f0(bool i0)     returns(int112 o0)
{
  do
  {
    {
      delete o0;
      bytes10 l0 = bytes10(0xffffffffffffffffffff);
      (o0, o0) = ((int112((((int112(0) ^ int112(0)) - int112(0)) / int112(0))) | int112(1447965357666723269135930063199899)), int88(27102705069779933089538788));
      assert(o0 == (int112((((int112(0) ^ int112(0)) - int112(0)) / int112(0))) | int112(1447965357666723269135930063199899)));
      assert(o0 == int88(27102705069779933089538788));
      bool[][][][][] memory l1 = (((uint128((uint128(31913304580748315830765703613142245560) / uint72(4722366482869645213695))) != uint128(0)) ? true : true) ? new bool[][][][][](5) : new bool[][][][][](5));
      function () internal   returns (bytes13, address, uint168) l2;
    }
    bool l3 = true;
    assembly
    {
      extcodecopy(62823790949178888334078207349617891904334269966773549319453983273014383365814, add(0x80, mod(mload(add(0x80, mod(i0, 2048))), 1024)), 89498411412899082801890178082454192396452182488791219269381849100674958466624, mod(0, 1024))
      calldatacopy(add(0x80, mod(timestamp(), 1024)), i0, mod(24550580586021835273163066129902613075476437163026929419116490493631025744904, 1024))
      extcodecopy(mload(add(0x80, mod(0, 2048))), add(0x80, mod(0, 1024)), mload(add(0x80, mod(mload(add(0x80, mod(i0, 2048))), 1024))), mod(i0, 1024))
      let al0 := i0
      switch i0
      case 0
      {
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      default
      {
      }
    }
  }
  while (false);
  (o0) = (int112(1408711066326853381210942108052389));
  assert(o0 == int112(1408711066326853381210942108052389));
}
pragma solidity >= 0.0.0;
// ====
// ----
