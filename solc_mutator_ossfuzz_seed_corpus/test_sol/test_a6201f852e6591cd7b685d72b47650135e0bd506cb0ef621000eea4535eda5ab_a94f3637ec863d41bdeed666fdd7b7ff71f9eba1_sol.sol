
==== Source: su0.sol ====
struct St0 {
  address payable el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
function f0()    
{
}
library L0 {
  event ev0();
}
library L1 {
  event ev1(address  ep0);
  event ev2(bool[]  ep0);
  function f1(bool i0,bool i1) internal   
  {
    int96 l0 = ((int96((int96(-15577569736226705870790003605) / int96(-10585351859011169003988719259))) - int96(-32204927377738106305688501589)) + int96(39614081257132168796771975167));
  }
}
contract C0 {
  using L1 for *;
  mapping(uint200 => bool)   s0;
  int208   s1 = int208(0);
  constructor() payable  {
    s0[uint200((uint200(966820890989784238383939551793820648121189825144669188135617) / ((uint200(582674498763412486310236895333801200698218999296058296102797) + uint200(304761981555442570727117753453597179609797012234341226917717)) + uint200(0))))] = (s0[((((uint200(991910392586335268964786862864943585123289183923280830413981) % uint200(1033633734510045675425706872542808162135139114541959868375239)) * uint200(0)) * uint200(1606938044258990275541962092341162602522202993782792835301375)) ** uint256(uint256(0)))] ? true : true);
    unchecked {
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
      }
    }
  }
  using L0 for *;
  using L0 for *;
  receive() external   payable
  {
    int208  l0 = s1;
    int208  l1 = l0;
    assert(l1 == s1);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
