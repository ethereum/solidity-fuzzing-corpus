
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(function (int72, function (bytes4, function (address payable) external   returns (int24, uint128)) external   returns (bytes11, function () external   returns (uint176, bytes20, bytes memory), address), address payable) external   returns (address) i0,uint16 i1) private   
  {
  }
  modifier m0() 
  {
    uint96 l0 = uint96(8543085055000611666126307020);
    bool l1 = false;
    (bool l2, bytes memory l3) = address(this).call(bytes(string("ffffffffffffffffffffffffffffffffffffffffffffffff000000")));
    assembly
    {
      sstore(l2, l2)
      let al0 := 0
      extcodecopy(l0, add(0x80, mod(l0, 1024)), 115792089237316195423570985008687907853269984665640564039457584007913129639935, mod(l1, 1024))
    }
    _;
  }
  bool[]   s0 = [true, true, false, false];

	function compareMemoryAndStorage(bool[] memory v1, bool[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bytes17 immutable  s1;
  uint152  public s2;
  constructor(bytes17 i0,uint152 i1) payable  {
    s1 = (~(bytes17(0x0000000000000000000000000000000000)));
    s2 -= uint152(2607199712822690075425155446985552230949259464);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call((false ? bytes.concat((bytes2(0x0000) & (bytes2(0x4535) & bytes2(0x0000))), bytes12(0x000000000000000000000000)) : bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000")));
      s2 |= (uint152(5708990770823839524233143877797980545530986495) >> uint32(uint32(0)));
    }
  }
}
// ====
// ----
