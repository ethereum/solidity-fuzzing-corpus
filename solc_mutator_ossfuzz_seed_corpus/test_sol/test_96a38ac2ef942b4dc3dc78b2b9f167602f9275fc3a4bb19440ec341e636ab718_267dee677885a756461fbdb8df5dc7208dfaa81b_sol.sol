
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  fallback() external   payable
  {
    int144 l0 = int144(11150372599265311570767859136324180752990207);
    unchecked {
      bool l1 = ((uint208(400067793020876861283970005642325834761681890758618500760086602) >> uint256((uint256(69951696984568797656495199345363270774723643966428484231206408264433716678293) >> uint200((uint200(1606938044258990275541962092341162602522202993782792835301375) - uint200(1492248816135283225810523896718926167023017598284947746877471)))))) < uint208(411376139330301510538742295639337626245683966408394965837152255));
      (l0, l1) = (int144(0), true);
      assert(l0 == int144(0));
      assert(l1 == true);
      bytes20 l2 = (bytes20(address(0x0000000000000000000000000000000000000000)) & ripemd160(bytes("ffffffffffffffffffffffffffffffffffffffffffffff551d42e3efb19eed9017ff2ffc96b6472849cc")));
      assembly
      {
        switch call(l1, 83396886091121403985458683340824371466490696396114588320579885731282275523384, 0, 4953146986637474214008278983270110656263435436695491173550449851574006246757, 111079685516748291877620659590669848488379161193315970469372290849200205895953, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        case 88631879804693774411871983660271455973425620330225679879549623692425831916927
        {
        }
        case 0
        {
          function af0() -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12, ao13, ao14, ao15, ao16
          {
          }
        }
        let al0 := l1
        let al1 := al0
      }
    }
  }
  mapping(uint112 => bytes4[])   s0;
  uint96  public s1;
  constructor(uint96 i0)   {
    s1 = uint96(63582234235448543636809442473);
    { }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
