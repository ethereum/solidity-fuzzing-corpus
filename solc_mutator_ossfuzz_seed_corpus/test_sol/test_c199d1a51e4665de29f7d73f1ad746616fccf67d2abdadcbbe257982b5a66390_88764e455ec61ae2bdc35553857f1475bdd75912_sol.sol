
==== Source: su0.sol ====
contract C0 {
  event ev0(bool indexed ep0);
  modifier m0() 
  {
    emit ev0(false);
    (bool l0) = payable(this).send(9686972230671714799);
    for(    address l1 = address(this);
;
)
    {
      (bool l2) = payable(this).send(7592266112837106467);
      bytes14 l3 = bytes14(0xffffffffffffffffffffffffffff);
      assembly
      {
      }
      _;
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79

  }
  error er0();
  function f0(int32 i0,bool i1,uint80 i2) public  m0()  returns(uint224 o0,address[1] memory o1)
  {
    for(    function (function (uint144, int208, function (function () external   returns (bool)) external  ) external   returns (uint112, bool), function (int176, bool) external   returns (uint88, uint168, bytes31), function (address payable, bytes15, uint248) external   returns (string memory, function () external   returns (function (bool) external   returns (int16, uint152, bytes14[] memory), uint64, int56)[] memory)) external   l0;
;
((((((uint184(0) + uint184(24519928653854221733733552434404946937899825954937634815)) ** uint32(uint32(4294967295))) % uint184(0)) + uint184(24519928653854221733733552434404946937899825954937634815)) ^ uint184(13959201133151211736394361068062232924494067632084545834)) ** uint104(uint104(16545313405325553665879924156972))))
    {
    }
  }
  type T0 is bool;
  uint112   s0 = uint112(3668693003757711950033501053425950);
  C0.T0   s1 = C0.T0.wrap(true);
  C0.T0  public s2;
  constructor(C0.T0 i0)   {
    s2 = C0.T0.wrap(false);
    unchecked {
    }
  }
  struct St0 {
    int64 el0;
    address el1;
    int32 el2;
  }
  bool public constant cons0 = false;
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 5030116975597548573}("");
    return;
    if (false)
    {
      (bool l2) = payable(this).send(3808443214868540570);
      emit ev0((!(true)));
    }
  }
  receive() external virtual m0() payable
  {
    revert er0();
    return;
  }
}
library L0 {
  function f3(bool[2] memory i0) external    returns(C0.EN0 o0)
  {
  }
  type T1 is address;
  modifier m1() 
  {
    _;
  }
  using L0 for *;
}
contract C1 {
  struct St1 {
    uint176 el0;
  }
  fallback() external virtual  
  {
  }
  int64 public constant cons1 = ((((((int64(0) | int64(2033796170790404003)) | int64(0)) * int64(0)) * int64(964340386016658620)) ^ int64(0)) % int64(0));
  type T2 is bytes31;
  modifier m2(bytes22[] memory i0) 
  {
    do
    {
      _;
    }
    while (true);
  }
  uint8[2]   s3;
  function (C0.T0, bytes17) external   returns (C0, C0.St0 memory)[]   s4;
  L0.T1   s5 = L0.T1.wrap(address(0x0000000000000000000000000000000000000005));
  constructor(uint8[2] memory i0,function (C0.T0, bytes17) external   returns (C0, C0.St0 memory)[] memory i1) payable  {
    s3 = i0;
    s4 = i1;
    unchecked {
      if (false)
      {
        s4.pop();
      }
    }
  }
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25
  }
  error er1(int136 ep0);
}
pragma solidity >= 0.0.0;
struct St2 {
  C0.EN0 el0;
  mapping(L0.T1 => mapping(address => uint192)) el1;
  C1.T2 el2;
  C0 el3;
}
type T3 is bool;
function f5(address payable i0,function () external   i1)     returns(uint168 o0,string memory o1)
{
  bytes memory l0 = "aeff35ba523ab4f6bf8abd77a5a63ca437db07b32aed208ba7a9fa";
}
// ====
// ----
