==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  address  public s0 = address(this);
  uint136   s1 = uint136(87112285931760246646623899502532662132735);
  uint16  public s2;
  uint248  public s3;
  constructor(uint16 i0,uint248 i1)   {
    s2 -= ((uint16((uint16(65535) / ((uint16(0) + uint16(65535)) ^ uint16(65535)))) ^ uint16(0)) >> uint104(uint104(19551494678357580590600928727819)));
    s3 /= uint248(237602614619888780893800509387701993213509323149051607101239746273321768873);
    unchecked {
      {
        uint16  l0 = s2;
        uint16  l1 = l0;
        assert(l1 == s2);
        (s0, s1) = (msg.sender, ((~(((uint136(((uint136(87112285931760246646623899502532662132735) % uint136(87112285931760246646623899502532662132735)) / uint136(0))) & uint136(0)) - uint136(0)))) ^ uint136(0)));
        assert(s0 == msg.sender);
        assert(s1 == ((~(((uint136(((uint136(87112285931760246646623899502532662132735) % uint136(87112285931760246646623899502532662132735)) / uint136(0))) & uint136(0)) - uint136(0)))) ^ uint136(0)));
      }
      (bool l2, bytes memory l3) = address(this).call(bytes(string("00000000000000000000000000000000002259373a16f355c9838d")));
      uint16  l4 = s2;
      uint16  l5 = l4;
      assert(l5 == s2);
      address  l6 = s0;
      address  l7 = l6;
      assert(l7 == s0);
      uint16  l8 = s2;
      uint16  l9 = l8;
      assert(l9 == s2);
    }
  }
}
library L0 {
  function f0(int16[] memory i0) public    returns(bytes13 o0)
  {
    unchecked {
      bool l0 = (int88(0) == (((-((int88(122328168913445846585703700) + int88(154742504910672534362390527)))) + int88(0)) + int88(90473706559005236292914777)));
      address payable l1 = payable(address(0x0000000000000000000000000000000000000001));
      int88 l2 = ((int88(154742504910672534362390527) & (int88(154742504910672534362390527) & (int88(0) % int88(0)))) - int88(0));
      o0 ^= bytes13(0xffffffffffffffffffffffffff);
      (o0, o0, i0[((((uint256((false ? int256(51710785745224047478332528543038259702838454252448908109723981501314431425467) : int256(0))) + uint256(0)) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(0)) * uint256(0))]) = (bytes13(0x00000000000000000000000000), (~(bytes13(0x00000000000000000000000000))), (int16((((-(int16(0))) | int16(uint16(58558))) / int16(0))) + int16(32767)));
      assert(o0 == bytes13(0x00000000000000000000000000));
      assert(o0 == (~(bytes13(0x00000000000000000000000000))));
      assert(i0[((((uint256((false ? int256(51710785745224047478332528543038259702838454252448908109723981501314431425467) : int256(0))) + uint256(0)) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(0)) * uint256(0))] == (int16((((-(int16(0))) | int16(uint16(58558))) / int16(0))) + int16(32767)));
    }
  }
  event ev0(int32  ep0, int232 indexed ep1);
}
using L0 for int16[];
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su1.sol:178-187): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:188-198): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1019-1026): Unused local variable.
// Warning 2072: (su1.sol:1028-1043): Unused local variable.
// Warning 2072: (su1.sol:1466-1473): Unused local variable.
// Warning 2072: (su1.sol:1627-1645): Unused local variable.
// Warning 2072: (su1.sol:1716-1724): Unused local variable.
// Warning 2018: (su1.sol:1379-2814): Function state mutability can be restricted to pure
