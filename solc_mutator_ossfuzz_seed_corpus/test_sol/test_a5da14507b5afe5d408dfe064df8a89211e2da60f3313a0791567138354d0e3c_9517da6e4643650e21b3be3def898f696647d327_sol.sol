
==== Source: su0.sol ====
library L0 {
  function f0() public    returns(uint160 o0,int160 o1)
  {
    bytes22 l0 = (~((bytes22(0xffffffffffffffffffffffffffffffffffffffffffff) ^ ((bytes22(0x00000000000000000000000000000000000000000000) & bytes22(0x97a82f58c4a25d4314015240aeae6c3935d1bf4db5f7)) ^ bytes22(0xffffffffffffffffffffffffffffffffffffffffffff)))));
    function (address[][9][8][4] memory) external   returns (int224, int136[1][] memory, uint96) l1;
  }
  function f1(uint40 i0,function (int168, uint200, uint184) external   returns (function () external  , int256) i1) public   
  {
  }
}
pragma solidity >= 0.0.0;
using L0 for uint40;
contract C0 {
  using L0 for *;
  using L0 for *;
  fallback() external virtual  
  {
    unchecked {
      bytes1 l0 = bytes1(0x00);
      uint80[] memory l1 = new uint80[](1);
      address payable[4][][10][4] memory l2 = [[new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1)], [new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1)], [new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1)], [new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1), new address payable[4][](1)]];
      (bool l3, bytes memory l4) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb192d2ecfbdcd4071774fa114a912c28f4dfceae7088e9e7a3ae54f48760df9f"));
      require(((int96(39614081257132168796771975167) != int96(0)) != true));
    }
  }
  using L0 for *;
  address   s0;
  address  public s1;
  constructor(address i0,address i1)   {
    s0 = address(this);
    s1 = ((bytes1(0xff) >= bytes1(0x00)) ? ecrecover(bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), uint8(255), bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), bytes32(0x0000000000000000000000000000000000000000000000000000000000000000)) : address(this));
    { }
  }
  modifier m0() 
  {
    address  l0 = s1;
    address  l1 = l0;
    assert(l1 == s1);
    (bool l2, bytes memory l3) = address(this).call(((payable(address(this)) >= payable(msg.sender)) ? bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff") : bytes("000000000000ffffff")));
    address  l4 = s0;
    address  l5 = l4;
    assert(l5 == s0);
    (bool l6, bytes memory l7) = address(this).call(bytes("ffffffffffffffffffffffffffffffffff00000000000000000000000000"));
    _;
  }
}
// ====
// ----
