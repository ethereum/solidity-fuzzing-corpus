
==== Source: su0.sol ====
library L0 {
  function f0(address payable i0) internal    returns(bool o0,bytes20 o1)
  {
    (o0) = ((false == true));
    assert(o0 == (false == true));
    for(;
true;
)
    {
    }
  }
  type T0 is bytes11;
  type T1 is int192;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  uint232   s0 = uint232(0);
  address payable   s1;
  int208   s2;
  constructor(address payable i0,int208 i1)   {
    s1 = payable(address(this));
    s2 += ((int208((int208((((int208(205688069665150755269371147819668813122841983204197482918576127) + int208(0)) | int208(-5451299798219803767771637214216362603332554415962991153970443)) / int208(205688069665150755269371147819668813122841983204197482918576127))) / int208(0))) + int208(131201176637954178707744060927977391899501061210539137688085602)) % int208(62764082765071948982424084466786816807180712131606853035972800));
    unchecked {
      int208  l0 = s2;
      int208  l1 = l0;
      assert(l1 == s2);
      int208  l2 = s2;
      int208  l3 = l2;
      assert(l3 == s2);
      (s2) = ((int208((-(int96((((int96(0) & int96(0)) ^ int96(39614081257132168796771975167)) / int96(39614081257132168796771975167)))))) * int208(0)));
      assert(s2 == (int208((-(int96((((int96(0) & int96(0)) ^ int96(39614081257132168796771975167)) / int96(39614081257132168796771975167)))))) * int208(0)));
      address payable  l4 = s1;
      address payable  l5 = l4;
      assert(l5 == s1);
      s1 = payable(address(this));
      assert(s1 == payable(address(this)));
    }
  }
  receive() external virtual  payable
  {
    address payable  l0 = s1;
    address payable  l1 = l0;
    assert(l1 == s1);
    address payable  l2 = s1;
    address payable  l3 = l2;
    assert(l3 == s1);
    assert(false);
  }
  fallback() external   
  {
    int208  l0 = s2;
    int208  l1 = l0;
    assert(l1 == s2);
  }
  function f3(int208 i0) external   payable returns(bool[][9] memory o0)
  {
    int208  l0 = s2;
    int208  l1 = l0;
    assert(l1 == s2);
    address payable  l2 = s1;
    address payable  l3 = l2;
    assert(l3 == s1);
    o0[uint256((((~(int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) - (int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) * int256(0))) & int256(-53761733038709282448747760390853878310289780695261376283928891052279341551141)))] = o0[((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256((uint256(0) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))))];
  }
}
library L1 {
  modifier m0(address payable i0,function (address payable, bytes19) internal   returns (address, uint40) i1) 
  {
    _;
  }
}
// ====
// ----
