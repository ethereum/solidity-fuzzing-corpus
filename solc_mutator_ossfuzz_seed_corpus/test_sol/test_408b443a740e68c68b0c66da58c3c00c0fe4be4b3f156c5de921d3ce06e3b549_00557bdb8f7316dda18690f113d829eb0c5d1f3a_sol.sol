
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bytes17 el0;
  uint240 el1;
}

==== Source: su1.sol ====
struct St1 {
  bool[8] el0;
}
struct St2 {
  bool el0;
  bool el1;
  uint184 el2;
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   payable
  {
    for(    address payable l0 = payable(address(this));
false;
)
    {
      (bool l1) = payable(this).send(17107090290304293865);
      for(      bytes18(0x000000000000000000000000000000000000);
((false ? true : ((false ? true : true) ? true : false)) ? false : true);
)
      {
        continue;
      }
      break;
    }
    if ((((int24(-2799576) - (-(int24(0)))) + int24(-4275232)) == int24(2030512)))
    {
      revert(string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")));
    }
    (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
  }
  event ev0(bytes16  ep0);
  bytes  public s0;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  constructor(bytes memory i0)   {
    s0 = bytes("ffffffffffffffffff0000000000000000000000000000000000000000");
    unchecked {
    }
  }
  receive() external virtual  payable
  {
  }
  event ev1(uint136  ep0);
  type T0 is bytes10;

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(bytes calldata i0,bytes calldata i1) external virtual  payable   {
    require(false, string(bytes("7853a795c8fb28272fd2bffa808bb0d5a7ca2135bef985ffffffffffff")));
    emit ev1(uint136(0));
  }
}
contract C1 {
  uint64 public constant cons0 = 18446744073709551615;
  receive() external virtual  payable
  {
    if (false)
    {
      if (true)
      {
        if ((true ? (uint200(524715534890774744724758074631610156437164675276187019017184) != ((uint200(982684580256994166983042395041160081869623294811732549834987) & uint200(1525084785583739256398832360182710811087720696976410159850345)) ** uint32(uint32(2581322998)))) : true))
        {
          bool l0 = false;
        }
        else
        {
          function (address payable, bytes memory, function () external   returns (C0)) external   returns (uint200, C0.T0, function (bool, C0.T0, bool) external   returns (bytes13)) l1;
          do
          {
            break;
          }
          while (true);
        }
      }
    }
    else
    {
    }
  }
  function f4(uint96 i0) external      {
  }
  bool  public s1;
  int160 immutable public s2;
  constructor(bool i0,int160 i1)   {
    s1 = true;
    s2 = (int160(-592486910412119852863779653165919806054687898806) + ((((int160(-603529622070293067548339312984388678012762381326) - int160(406961995479570407371614424833832349774497091571)) + int160(0)) + int160(0)) * int160(730750818665451459101842416358141509827966271487)));
    unchecked {
      if (i0)
      {
        (s1) = (false);
        assert(s1 == false);
        (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
      }
      else if (i1 <= ((int160((int160(0) / int160(0))) + int40(-357776561927)) * int160(235957349125727654655250857277327449774274012956)))
      {
        int160  l2 = s2;
        int160  l3 = l2;
        assert(l3 == s2);
      }
    }
  }
  error er0();
}
// ====
// ----
