
==== Source: su0.sol ====
contract C0 {
  event ev0(bytes2  ep0, address  ep1);
  fallback() external   
  {
    if ((bytes8(0xaf3870fc441fe78f) == bytes8(0xffffffffffffffff)))
    {
    }
    emit ev0(bytes2(bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff)), address(this));
  }

	function compareMemoryAndCalldata(bool[] memory v1, bool[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f1(bool[] calldata i0) external virtual    returns(int192 o0,bytes memory o1)  {
    emit ev0(bytes2(0x0000), address(this));
    for(uint solinit0 = 0; solinit0 < (((uint256(0) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) << uint136(((uint136(86361533513355657086191201657743162808467) % uint136(20661201228001723128216466313638694932156)) + uint136(49943365348555340198549751791981716957148)))) % 11); solinit0++)
    {
      continue;
    }
  }
  address payable immutable  s0;
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
      emit ev0(bytes2(0xffff), address(this));
    }
  }
  struct St0 {
    mapping(int112 => address) el0;
    int32 el1;
  }
  event ev1(function (uint208, function () external   returns (int152, bool)) external   returns (bytes memory) indexed ep0, address payable  ep1);
}
contract C1 {
  function f2(bool i0) public   payable  returns(bool o0,function (string memory, bool) external   returns (C0, bool) o1,address payable o2)  {
    payable(this).transfer(0);
  }
  mapping(int176 => string)   s1;
  constructor()   {
    s1[int176(0)] = string("This is a really long string that must ideally be random but is currently hard coded");
    unchecked {
      for(uint solinit1 = 0; solinit1 < ((uint256(0) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit1++)
      {
        break;
      }
    }
  }
  receive() external   payable
  {
    return;
  }
  fallback() external   
  {
  }
  struct St1 {
    C0 el0;
    bytes el1;
    bytes el2;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C2 {
  error er0(int192 ep0);
  event ev2(bytes1 indexed ep0);
  address   s2 = address(this);
  uint16  public s3;
  bool  public s4;
  mapping(bytes29 => bool)   s5;
  constructor(uint16 i0,bool i1)   {
    s3 -= uint16(uint144((((uint144(17901148116540539700553041576296972047094778) | (false ? uint144(12830974653492007245247227147284425872927691) : uint144(13004380393848982197291086937573226359229383))) ^ uint144(0)) / uint144(10838374156262178495424478106706217888546589))));
    s4 = true;
    s5[(bytes29(0x0000000000000000000000000000000000000000000000000000000000) ^ ((~((bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & bytes29(0x4604227708cb1d904d8fb6047ca52c51708f9eb4ab1d04d513c9fa930b)))) & bytes29(0x0000000000000000000000000000000000000000000000000000000000)))] = true;
    unchecked {
    }
  }
}
// ====
// ----
