==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0(address payable i0,bool i1) public    returns(function (bytes17, string memory, int80) external   returns (bool, int56) o0,int64 o1)
  {
  }
  bytes20  public s0 = bytes20(address(0x4999bA003A18C6e2D88aA2f89398bF5De53c0119));
  mapping(uint192 => bool)   s1;
  bool[5]   s2;

	function compareMemoryAndStorage(bool[5] memory v1, bool[5] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int224   s3 = int224(0);
  constructor(bool[5] memory i0)   {
    s2 = i0;
    s1[(uint192(6277101735386680763835789423207666416102355444464034512895) * ((((uint192(1619870940030527204727038510669717565424402643155251900687) ^ uint192(0)) >> uint168(uint168(0))) * uint192(354921749316094888152982070060027704849335115101569675521)) | uint192(0)))] = true;
    unchecked {
      (function (bytes17, string memory, int80) external   returns (bool, int56) l0, int64 l1) = this.f0(payable(address((~(((bytes20(address(0x83eEfA61A7C4d86cCB09839B445fa4cE047082c7)) ^ ripemd160(bytes("0000000000000000000000000000000000000000000000000000000000000000"))) ^ bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF))))))),s2[payable(address(ripemd160(bytes("af83503ba636d2d44bb284bfffffff")))).balance]);
      (s0, s2[i0.length], i0[(((uint256(39102184156706406403752439009894136154970491766583142669448672498005217225295) * (true ? payable(address(this)) : payable(address(this))).balance) >> uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]) = (bytes20(address(0x0000000000000000000000000000000000000000)), false, (((uint96(67898561029674789209233354409) | uint96((uint96(66332262571242566300122921590) / uint96(0)))) % uint96(0)) > uint96(0)));
      assert(s0 == bytes20(address(0x0000000000000000000000000000000000000000)));
      assert(s2[i0.length] == false);
      assert(i0[(((uint256(39102184156706406403752439009894136154970491766583142669448672498005217225295) * (true ? payable(address(this)) : payable(address(this))).balance) >> uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))] == (((uint96(67898561029674789209233354409) | uint96((uint96(66332262571242566300122921590) / uint96(0)))) % uint96(0)) > uint96(0)));
      delete s2[((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | i0.length)];
      delete s3;
    }
  }
}
library L0 {
  event ev0(function () external   returns (uint120)  ep0);
  bool public constant cons0 = false;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
error er0(bytes1 ep0, bool ep1);
library L1 {
  int136 public constant cons1 = 0;
  function f1(int80 i0) public   
  {
    function (bytes12, uint32) external   returns (int248, bool) l0;
    bool l1 = false;
    unchecked {
      while (true)
      {
      }
      function (bool, bytes27) external   returns (uint184, uint80) l2;
    }
  }
}
using L1 for int80;
pragma solidity >= 0.0.0;
// ----
// Warning 5805: (su0.sol:1022-1026): "this" used in constructor. Note that external functions of a contract cannot be called while it is being constructed.
// Warning 2072: (su0.sol:932-1008): Unused local variable.
// Warning 2072: (su0.sol:1010-1018): Unused local variable.
// Warning 5667: (su1.sol:96-104): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:124-187): Unused local variable.
// Warning 2072: (su1.sol:193-200): Unused local variable.
// Warning 2072: (su1.sol:267-331): Unused local variable.
// Warning 2018: (su0.sol:305-549): Function state mutability can be restricted to view
// Warning 2018: (su1.sol:84-342): Function state mutability can be restricted to pure
