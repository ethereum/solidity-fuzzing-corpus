
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    bytes2 l0 = bytes2(0x0000);
    (bool l1, bytes memory l2) = address(this).call(bytes("ffffffffffffffffffffff00000000000000000000"));
  }
  function f1(function (uint240, int56) external   returns (bytes2, address payable) i0) external virtual  
  {
    unchecked {
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffb5b96ec23716cfa113afe955dafab04e847f57"));
      uint136[5] memory l2 = [uint136(25224422064048307356986649955045081682088), uint136(0), uint136(0), uint136(87112285931760246646623899502532662132735), uint136(87112285931760246646623899502532662132735)];
      assembly
      {
        for 
        {
          stop()
        }
        l1
        {
        }
        {
          return(115792089237316195423570985008687907853269984665640564039457584007913129639935, 96987458350071634279030862495480825682780642670094398560858554109617155619388)
        }
      }
      function () external   l3;
    }
  }
  bytes21 immutable public s0 = bytes21(0x064ddc5db77ea549dc7f95190b0b5af7885bc7d0f1);
  bool  public s1;
  int88   s2;
  uint112   s3;
  constructor(bool i0,int88 i1,uint112 i2)   {
    s1 = false;
    s2 -= int88(((int208(205688069665150755269371147819668813122841983204197482918576127) + (int208(205688069665150755269371147819668813122841983204197482918576127) * int208(0))) | int208(-133413229310167826998176157211730246852864495676245848981411890)));
    s3 ^= uint112(0);
    unchecked {
      bytes21  l0 = s0;
      bytes21  l1 = l0;
      assert(l1 == s0);
      bool  l2 = s1;
      bool  l3 = l2;
      assert(l3 == s1);
      bytes21  l4 = s0;
      bytes21  l5 = l4;
      assert(l5 == s0);
      int88  l6 = s2;
      int88  l7 = l6;
      assert(l7 == s2);
      uint112  l8 = s3;
      uint112  l9 = l8;
      assert(l9 == s3);
      int88  l10 = s2;
      int88  l11 = l10;
      assert(l11 == s2);
      uint112  l12 = s3;
      uint112  l13 = l12;
      assert(l13 == s3);
      bool  l14 = s1;
      bool  l15 = l14;
      assert(l15 == s1);
      uint112  l16 = s3;
      uint112  l17 = l16;
      assert(l17 == s3);
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  bytes21   s4;
  address payable   s5;
  address payable   s6 = payable(address(this));
  address payable   s7 = payable(address(this));
  constructor(bool i0,int88 i1,uint112 i2,bytes21 i3,address payable i4)  C0(true, int88(0), (((uint112(5192296858534827628530496329220095) ^ (uint112(900378788251794511226159624260055) & uint112(5192296858534827628530496329220095))) % uint112(4374586426368240081796250043623018)) >> uint24(uint24(16406976))))
  {
    s1 = false;
    s2 ^= ((((int88((int200(803469022129495137770981046170581301261101496891396417650687) * int200(-257100821169916263212735384387302386884225043079094880120615))) * int88(154742504910672534362390527)) + int88(0)) % int88(0)) * int88(154742504910672534362390527));
    s3 >>= uint112(5192296858534827628530496329220095);
    s4 &= bytes21(((bytes32(bytes14(0xffffffffffffffffffffffffffff)) ^ bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)) & bytes32(0xaa1485bda41d975cb82dc5884d69564ce6d0fa134cbd20419153c4892261c498)));
    s5 = payable(address(this));
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000000000000000ffffffffffffffffffffffff"));
      uint112  l2 = s3;
      uint112  l3 = l2;
      assert(l3 == s3);
      bytes21  l4 = s4;
      bytes21  l5 = l4;
      assert(l5 == s4);
    }
  }
  function f1(function (uint240, int56) external   returns (bytes2, address payable) i0) external virtual override  
  {
    bytes21  l0 = s4;
    bytes21  l1 = l0;
    assert(l1 == s4);
    assert((false ? true : false));
  }
  fallback() external override  
  {
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
