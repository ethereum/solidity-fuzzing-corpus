
==== Source: su0.sol ====
contract C0 {
  function f0() external virtual  payable
  {
    {
    }
    (bool l0, bytes memory l1) = address(this).call((true ? abi.encode(new uint136[6][5][](6), int168(11580189868929461633442026732933874579206597993807), (uint152(2780780738171461442593463443201471957469947841) | uint152(0)), bytes18(0xffffffffffffffffffffffffffffffffffff)) : bytes("07b69d4e116eb1d667230b2b5ad0fe68b31ccfff987593601ae8f26f8ef27768dd0a1fb73f84c1069e8c7ebf07516266")));
  }
  address payable   s0;
  uint224   s1;
  int96 immutable public s2 = int96(0);
  address   s3 = address(this);
  constructor(address payable i0,uint224 i1) payable  {
    s0 = payable(address(bytes20(address(0x0d600895f320373F9D14C194E0C164Bf34780439))));
    s1 -= ((uint64(((int64(0) - int64(9223372036854775807)) & int64(9223372036854775807))) - uint224(20926492946559451392257380433285986266734852955912105796126769964239)) + uint224(26959946667150639794667015087019630673637144422540572481103610249215));
    unchecked {
      uint224  l0 = s1;
      uint224  l1 = l0;
      assert(l1 == s1);
      address payable  l2 = s0;
      address payable  l3 = l2;
      assert(l3 == s0);
      address  l4 = s3;
      address  l5 = l4;
      assert(l5 == s3);
      address  l6 = s3;
      address  l7 = l6;
      assert(l7 == s3);
      (s1) = (((uint224(26959946667150639794667015087019630673637144422540572481103610249215) << uint32((~(uint32(((uint32(4294967295) - uint32(4294967295)) / uint32(4294967295))))))) - uint224(26715044823108396085102452016167203543134039448062094799897704224944)));
      assert(s1 == ((uint224(26959946667150639794667015087019630673637144422540572481103610249215) << uint32((~(uint32(((uint32(4294967295) - uint32(4294967295)) / uint32(4294967295))))))) - uint224(26715044823108396085102452016167203543134039448062094799897704224944)));
      {
        int96  l8 = s2;
        int96  l9 = l8;
        assert(l9 == s2);
        (bool l10, bytes memory l11) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
        (bool l12, bytes memory l13) = address(this).call(bytes("ffffffffffffffffffffff0000000000000000000000000000000000000000000000000000"));
        uint224  l14 = s1;
        uint224  l15 = l14;
        assert(l15 == s1);
        bytes((false ? string("0000000000000000000000000000000000000000000000000000000000000000657e642059b430e0922508df30005254c41eff") : string("8e1b64dca75a222a99218843128c5475541d29787345f063705c3f9a3bf324396cb0cff3")));
      }
    }
  }
  function f1(address i0,uint224 i1) public    returns(function () external   o0)
  {
    uint224  l0 = s1;
    uint224  l1 = l0;
    assert(l1 == s1);
    try this.f0()
    {
      int96  l2 = s2;
      int96  l3 = l2;
      assert(l3 == s2);
      unchecked {
      }
    }
    catch
    {
      uint224  l4 = s1;
      uint224  l5 = l4;
      assert(l5 == s1);
    }
    catch Panic(uint256 l6)
    {
    }
  }
}
library L0 {
  function f2() public    returns(bool o0)
  {
    do
    {
      function (string memory) external   returns (string memory, address payable, bool) l0;
    }
    while (false);
  }
  function f3(string memory i0) external    returns(bool o0)
  {
    o0 = true;
    assert(o0 == true);
    bytes5 l0 = bytes5(0x5fd5c10ab6);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
