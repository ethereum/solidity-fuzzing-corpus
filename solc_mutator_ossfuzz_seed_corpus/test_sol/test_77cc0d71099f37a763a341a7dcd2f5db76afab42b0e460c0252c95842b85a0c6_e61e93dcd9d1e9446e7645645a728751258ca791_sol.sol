==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0(function (uint192, bool, address) external   returns (function () external   returns (bool, bytes9, bytes memory), uint24, int224) i0,bytes6 i1) external   payable returns(string memory o0)
  {
    string storage l0;
    address l1 = (true ? i0.address : address(this));
    address payable l2 = payable(address(this));
  }
  function f1(function (address payable, address, address[4] memory) external   returns (uint200, bool) i0) public virtual  payable
  {
    bool l0 = true;
  }
  struct St0 {
    bytes30 el0;
    int248 el1;
    function (uint40) external   returns (bytes3, bool, int208) el2;
    bool el3;
  }
  int72   s0;
  int168   s1;
  constructor(int72 i0,int168 i1)   {
    s0 += ((int72(((((int72(-1880496456585501021554) - int72(2361183241434822606847)) ^ int72(2361183241434822606847)) - int72(-1017747259829063755257)) / int72(0))) ^ int72(0)) | int72(2361183241434822606847));
    s1 = ((((((int168(-157868178482357384175100630028261060186559287250022) * int168(0)) % int168(187072209578355573530071658587684226515959365500927)) + int168(0)) * int168(0)) | int168(-59681974086097316112342736494527822727693503678552)) % int168(0));
    unchecked {
      int72  l0 = s0;
      int72  l1 = l0;
      assert(l1 == s0);
      (s0, s1) = ((-(int72(0))), int168(0));
      assert(s0 == (-(int72(0))));
      assert(s1 == int168(0));
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
type T0 is uint64;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



struct St1 {
  bytes el0;
  address payable el1;
  bytes el2;
}
// ----
// Warning 5667: (su0.sol:162-171): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:200-216): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:226-243): Unused local variable.
// Warning 2072: (su0.sol:249-259): Unused local variable.
// Warning 2072: (su0.sol:303-321): Unused local variable.
// Warning 5667: (su0.sol:366-458): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:492-499): Unused local variable.
// Warning 5667: (su0.sol:690-698): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:699-708): Unused function parameter. Remove or comment out the variable name to silence this warning.
