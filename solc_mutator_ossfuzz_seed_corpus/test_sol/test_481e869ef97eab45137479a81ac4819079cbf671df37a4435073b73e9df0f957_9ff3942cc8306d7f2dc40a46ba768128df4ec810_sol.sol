
==== Source: su0.sol ====
uint72 constant cons0 = 658966666299791157728;
function f0(bytes8 i0,address payable i1)      returns(function (int232, address, function (bytes3, int32) external   returns (function (uint168, int32, address) external  , bytes memory, bytes11)) external   returns (address payable, function (bool, int64, int56) external   returns (uint160, bool, bytes10), bool) o0){
}
pragma solidity >= 0.0.0;
function f1()     {
  for(;
;
)
  {
    continue;
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(address payable indexed ep0, bytes11  ep1);
  function f2(bytes30 i0,function () external   returns (string memory, bool, string memory) i1) public virtual  payable   {
    try i1() returns (string memory l0, bool l1, string memory l2)
    {
      if (true)
      {
      }
      if (i0 <= bytes30(0xc372f5da7ac0f5e5722d0f411122179ddf34e3ac1848be2bf482e8bdea09))
      {
        (string memory l3, bool l4, string memory l5) = i1();
      }
      else if ((uint40(1090318822578) < uint40(1099511627775)))
      {
        function (string memory, bool) internal   returns (bytes16, address payable, bytes26) l6;
        if (false)
        {
        }
        else
        {
          (string memory l7, bool l8, string memory l9) = i1();
        }
      }
    }
    catch
    {
      (bool l10, bytes memory l11) = address(this).call(abi.encodeCall(i1, ()));
      return;
    }
    catch Panic(uint256 l12)
    {
    }
  }
  bool  public s0;
  bytes27   s1 = bytes27(0x000000000000000000000000000000000000000000000000000000);
  constructor(bool i0)   {
    s0 = true;
    unchecked {
    }
  }
}
struct St0 {
  int128 el0;
  bool el1;
  address el2;
}
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
