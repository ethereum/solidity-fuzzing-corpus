
==== Source: su0.sol ====
contract C0 {
  error er0();
  receive() external   payable
  {
    address l0 = address(this);
    address l1 = address(this);
  }
  bool   s0 = false;
  struct St0 {
    uint104 el0;
    int32 el1;
    int128 el2;
  }
}
contract C1 {
  int232 immutable  s1;
  constructor(int232 i0)   {
    s1 = ((((bytes9(0x000000000000000000) >= bytes31(0xaae223f34e1da650fff7f9d7262db9e8b138ad4272716c96fb60337be02b51)) ? int232(1151674099156634104811618768751114681074149028513589172149288359566759) : int232(-180767137427721372903823433283790228882389417233333955259167307943120)) ^ int232(2172197642632112456343045978140758845852919591782055192772603687812852)) - int232(-876871348765236536246544309437896952332911251884369408284616786973127));
    unchecked {
      int232  l0 = s1;
      int232  l1 = l0;
      assert(l1 == s1);
      for(      C0 l2 = C0(payable(address(this)));
;
(uint128(0) ** uint168(uint168(374144419156711147060143317175368453031918731001855))))
      {
        assert((false ? ((-(int40(303873254608))) <= int40(0)) : false));
        address payable[][][] memory l3 = new address payable[][][](3);
      }
      revert C0.er0();
    }
  }
  receive() external virtual  payable
  {
    int232  l0 = s1;
    int232  l1 = l0;
    assert(l1 == s1);
    int232  l2 = s1;
    int232  l3 = l2;
    assert(l3 == s1);
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  bytes21 el0;
  mapping(address => mapping(int64 => address)) el1;
}
// ====
// ----
