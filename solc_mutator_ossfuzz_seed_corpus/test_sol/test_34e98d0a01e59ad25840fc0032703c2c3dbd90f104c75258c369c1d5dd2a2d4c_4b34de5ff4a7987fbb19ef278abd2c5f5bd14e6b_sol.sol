
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  type T0 is int8;
  bytes17 public constant cons0 = bytes17(0xffffffffffffffffffffffffffffffffff);
  error er0();
  bytes   s0 = bytes("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  bool   s1;
  constructor(bool i0)   {
    s1 = (false || true);
    unchecked {
    }
  }
  error er1();
  event ev0();
  modifier m0() virtual
  {
    _;
  }
  receive() external virtual m0() payable
  {
    assert(true);
  }
  modifier m1(bool i0) 
  {
    assembly
    {
      i0 := s1
    }
    emit ev0();
    (bool l0, bytes memory l1) = payable(this).call{value: 15200916001187763160}("");
    unchecked {
      for(      bytes5[] memory l2 = new bytes5[](1);
(true && ((((uint128(340282366920938463463374607431768211455) ^ uint128(340282366920938463463374607431768211455)) * uint128(340282366920938463463374607431768211455)) << uint144(uint144(0))) >= uint128(340282366920938463463374607431768211455)));
)
      {
        continue;
        break;
        if (false)
        {
          emit ev0();
          false;
          delete l2[1];
        }
      }
      do
      {
        {
          break;
          if (true)
          {
          }
          (bool l3) = payable(this).send(13727955671764698661);
          break;
          continue;
          (bool l4) = payable(this).send(13912355495591456829);
        }
        if ((uint176(0) >= ((~(uint176(0))) ** uint104((uint104(20282409603651670423947251286015) ^ uint104(20282409603651670423947251286015))))))
        {
        }
      }
      while (true);
    }
    _;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19
  }
}
// ====
// ----
