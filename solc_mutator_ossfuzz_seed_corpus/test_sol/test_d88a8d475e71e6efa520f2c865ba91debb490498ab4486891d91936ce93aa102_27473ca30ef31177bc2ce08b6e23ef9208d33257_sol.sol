==== Source:  ====

==== Source: su0.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35
}
error er0();
contract C0 {
  modifier m0() virtual
  {
    _;
  }
  function f0(int16 i0) external  m0()  returns(bool o0,address o1)
  {
  }
  struct St0 {
    bool el0;
    string el1;
  }
  enum EN1 {
    M0, M1, M2
  }
  fallback() external   payable
  {
    if (true)
    {
    }
    else if (false)
    {
    }
    else if ((C0.EN1(uint8(2)) == C0.EN1.M0))
    {
      string storage l0;
    }
  }
  int56   s0 = int56(11450570240542464);
  C0.St0   s1;
  address payable   s2;
  C0.St0   s3;
  constructor(address payable i0)   {
    s2 = payable(address(this));
    unchecked {
    }
  }
  receive() external virtual  payable
  {
    try this.f0({i0: (~((int16(0) & (int16(0) & (int16(23245) * int16(32767))))))}) returns (bool l0, address l1)
    {
    }
    catch
    {
      address l2 = address(this);
      (bool l3, address l4) = this.f0((~(int16(-17152))));
    }
    catch Error(string memory l5)
    {
      try this.f0(int16(0)) returns (bool l6, address l7)
      {
        if (((((bytes27(0xd901bc49d321abe2e58580a54c7c2a2f2d2ced199737720f8ebda3) != bytes27(0x20942d24ec903d03bd16241e31b1b443564c78ee6881feed91eaec)) || false) || true) && true))
        {
        }
        else if (false)
        {
          if (true)
          {
            if ((!(false)))
            {
            }
            else if ((((~((~((uint176(64343778968958217854471495329140622256992026474285145) * uint176(95780971304118053647396689196894323976171195136475135)))))) | uint176(0)) > uint176(68846249512372274074334533320611536632400036260709191)))
            {
            }
          }
          bool l8 = false;
        }
        else
        {
          s3.el0 = ((uint64(0) * (uint64(18446744073709551615) - uint64(3876853217094569344))) == uint64(17388580281064492805));
        }
        for(        bool l9 = (false ? false : false);
;
)
        {
        }
      }
      catch
      {
      }
      int80 l10 = ((int80(567925786697709154605962) * ((int80(604462909807314587353087) & int80(604462909807314587353087)) ** uint16(uint16(1996)))) + int80(0));
    }
  }
  type T0 is address;
  event ev0(uint72  ep0, C0.EN1 indexed ep1);
}
struct St1 {
  bytes el0;
  C0.EN1 el1;
  string el2;
  bytes el3;
}
function f3()     returns(C0.St0 memory o0)
{
  function (C0.T0) internal   returns (St1 memory, C0.St0 memory, C0.T0) l0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
error er1();
library L0 {
  event ev1();
  function f4(bytes14 i0,int120 i1) external    returns(bytes26 o0)
  {
    int64 l0 = (int64(0) | int64(-7639095378146549039));
  }
  address payable public constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
  error er2();
  modifier m1() 
  {
    emit L0.ev1();
    _;
  }
  uint112 public constant cons1 = ((((((uint112(5061962375303781316305588456317480) % uint112(0)) % uint112(0)) << uint64(uint64(10644389953117368780))) + uint112(3903257284954893948680136770295073)) - uint112(0)) % uint112(0));
  error er3(function () external   ep0, bytes22 ep1);
  event ev2(uint120  ep0, function (address payable, address, function () external  ) external   returns (uint104, address, uint24) indexed ep1, string  ep2);
}
struct St2 {
  uint48 el0;
  bool el1;
  int152 el2;
  uint176 el3;
}
pragma solidity >= 0.0.0;
bytes23 constant cons2 = (((((bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff) | bytes23(0xaba1b3a7c3a235ead869fb038579e0f2447d863c86f93f)) ^ bytes23(0xe2038de624e0c32e1ace4d1cab3b8bbb4bf8f43df1fe08)) & bytes23(0x258d3365c18add056cda7f59dff67e042e5207f248a646)) ^ bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff)) | bytes23(0x1ac10717d137615a814431bca8f8370b272ebe204453a1));
import "su0.sol";
function f5(uint8 i0)    
{
}
// ----
// Warning 2072: (su0.sol:567-584): Unused local variable.
// Warning 5667: (su0.sol:705-723): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:923-930): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:932-942): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:978-988): Unused local variable.
// Warning 2072: (su0.sol:1013-1020): Unused local variable.
// Warning 2072: (su0.sol:1022-1032): Unused local variable.
// Warning 5667: (su0.sol:1087-1103): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1148-1155): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1157-1167): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1794-1801): Unused local variable.
// Warning 2072: (su0.sol:2003-2010): Unused local variable.
// Warning 2072: (su0.sol:2104-2113): Unused local variable.
// Warning 5667: (su0.sol:2435-2451): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2457-2530): Unused local variable.
// Warning 5667: (su1.sol:55-65): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:66-75): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:97-107): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:117-125): Unused local variable.
// Warning 2018: (su0.sol:2409-2533): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:43-173): Function state mutability can be restricted to pure
