
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() external   payable  returns(bool o0,bool o1)  {
  }
  bool  public s0 = false;
  bool  public s1 = true;
  bool  public s2 = false;
  function f1(bool i0) internal virtual    returns(bytes memory o0,uint16 o1)  {
    if (i0)
    {
    }
    else if (i0)
    {
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
      if (i0)
      {
        o1 /= (((uint16(((false ? uint16(65535) : uint16(65535)) / uint16(65535))) << uint256(uint256(0))) & uint16(0)) - uint16(0));
        revert(string.concat(string(bytes("ffffffffffff000000000000")), string("This is a really long string that must ideally be random but is currently hard coded"), string(bytes("00000000000000000000000000000000000000000000000000000ba9b6"))));
      }
      return (bytes("128ab8ada405476dad2b642431a398e1026607615d20386fd5ac95f79321513914f568f6"), (uint16(0) + uint16(0)));
    }
    o0 = bytes("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert(keccak256(bytes(o0)) == keccak256(bytes(bytes("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"))));
    return (msg.data, ((uint16(38737) - uint16(38091)) - uint16((uint16(0) / uint16(65535)))));
  }
}
struct St0 {
  uint48 el0;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
int24 constant cons0 = 8388607;
// ====
// ----
