
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  int120   s0;
  constructor(int120 i0)   {
    s0 = (int120(-191505433252238173613301661613100048) & int120(0));
    {
      for(      0;
;
address(this))
      {
      }
    }
  }
  function f0() internal     returns(uint200 o0,bool o1)  {
    int120  l0 = s0;
    int120  l1 = l0;
    assert(l1 == s0);
    while ((address(bytes20(address(0xf05a1b9c918E6FcF76ba25a1a3D88166C3DF1c04))) <= address(this)))
    {
      continue;
    }
  }
  event ev0(address payable[1]  ep0);
  function f1() external     returns(address o0)  {
    if (true)
    {
      emit ev0([payable(address(0x0000000000000000000000000000000000000001))]);
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    }
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int208 el0;
  mapping(bytes14 => mapping(uint120 => uint248)) el1;
}
function f2()      returns(address payable o0,bool o1){
}
function f3()      returns(bytes14 o0,bool o1){
  uint160 l0 = uint160(1461501637330902918203684832716283019655932542975);
  if (true)
  {
    delete o1;
  }
  if (false)
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
// ====
// ----
