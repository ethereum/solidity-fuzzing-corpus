==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  fallback() external   
  {
    assembly
    {
    }
  }
  mapping(address => int184)   s0;
  int240   s1;
  mapping(uint200 => address)   s2;
  constructor(int240 i0)   {
    s1 &= (int240(0) & int240(-694051469862740056057509908726586640224950924510475275512955443418053123));
    s0[address(this)] += s0[address(this)];
    s2[(uint200(1606938044258990275541962092341162602522202993782792835301375) - uint200((((uint200(int200(803469022129495137770981046170581301261101496891396417650687)) ^ uint200(0)) - uint200(1280986848451939163209594134587048368966993369063314562190203)) / uint200(0))))] = address(this);
    {
      int240  l0 = s1;
      int240  l1 = l0;
      assert(l1 == s1);
      unchecked {
      }
      (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
      int240  l4 = s1;
      int240  l5 = l4;
      assert(l5 == s1);
      unchecked {
      }
      int240  l6 = s1;
      int240  l7 = l6;
      assert(l7 == s1);
    }
  }
}
library L0 {
  event ev0(function (bytes4) external   returns (function (bool, bytes20, uint184) external   returns (bytes32, uint216, int80), bytes16, function (bool, address payable) external   returns (uint136, function (uint256, int24, uint8) external   returns (function (bool) external   returns (address payable), bytes12, address payable)))  ep0);
  function f1() internal   
  {
    function (function (function (function (int160, bytes30, function (bytes19, int168, address) external   returns (uint200, function () external   returns (uint208, bytes10), bool)) external   returns (bytes20, bool)) external   returns (address payable, bool), function (bool, bytes31, bool) external   returns (address, bytes memory), int64[3][2][10][5] memory) external  ) internal   returns (bytes9, int232[5][1] memory) l0;
    bool l1 = false;
    assembly
    {
    }
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  using L0 for *;
  using L0 for *;
  using L0 for *;
  mapping(bytes25 => int224)  public s3;
  bool   s4;
  C0   s5 = C0(address(this));
  int240  public s6;
  constructor(int240 i0,bool i1,int240 i2) payable C0(int240(883423532389192164791648750371459257913741948437809479060803100646309887))
  {
    s1 &= int240(184541449856254585028996950870584207730514908541275924105336412012070447);
    s4 = true;
    s6 /= int240(-690404978769980899631796683228938893840802872114360986810091790026769512);
    s0[address(this)] ^= (int184(0) + int184(-2279440365907144092775711879149332937201251046717560895));
    s2[uint200(0)] = msg.sender;
    s3[bytes25(0x5c14d610379f79801544f9c599ce49ba15fc4d363d71a7d0bf)] = int224(13479973333575319897333507543509815336818572211270286240551805124607);
    unchecked {
      bool  l0 = s4;
      bool  l1 = l0;
      assert(l1 == s4);
      int240  l2 = s1;
      int240  l3 = l2;
      assert(l3 == s1);
    }
  }
  using L0 for *;
}
// ----
// Warning 5667: (su0.sol:172-181): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:739-746): Unused local variable.
// Warning 2072: (su0.sol:748-763): Unused local variable.
// Warning 2072: (su0.sol:1436-1861): Unused local variable.
// Warning 2072: (su0.sol:1867-1874): Unused local variable.
// Warning 5667: (su0.sol:2135-2144): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2145-2152): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2153-2162): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1402-1912): Function state mutability can be restricted to pure
