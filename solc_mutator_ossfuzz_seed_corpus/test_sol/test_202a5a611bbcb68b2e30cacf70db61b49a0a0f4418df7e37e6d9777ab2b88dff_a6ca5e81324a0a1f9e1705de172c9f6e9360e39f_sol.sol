==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  address payable el0;
  int80 el1;
  uint40 el2;
}
library L0 {
  function f0() external    returns(bool o0)
  {
    St0 memory l0 = (true ? St0(payable(address(0x0000000000000000000000000000000000000007)), int80(0), uint40(1099511627775)) : St0({el0: payable(address(0x0000000000000000000000000000000000000003)), el1: int80(202362846418529394007209), el2: uint40(1099511627775)}));
    bool l1 = true;
  }
  function f1(bool i0) external   
  {
    for(uint solinit0 = 0; solinit0 < ((uint256((((uint56(0) | uint96(0)) + uint256(0)) / uint256(0))) % uint256(0)) % 11); solinit0++)
    {
      St0 memory l0 = (true ? St0(payable(address(0x0000000000000000000000000000000000000007)), int80(-248133909130460387530183), uint40(516555303625)) : ((false ? true : true) ? St0(payable(address(0x0000000000000000000000000000000000000002)), int80(308424893386330889055853), uint40(583912239142)) : St0(payable(address(0x0000000000000000000000000000000000000008)), int80(236638000871711581155468), uint40(0))));
      function (St0 memory) external   returns (St0 memory, bool, uint128[7][][1][][10][] memory) l1;
    }
    (i0) = (((~(bytes3(0xffffff))) == bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    assert(i0 == ((~(bytes3(0xffffff))) == bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
  }
  event ev0(uint120  ep0, uint40  ep1);
}
using L0 for bool;
contract C0 {
  using L0 for *;
  using L0 for *;
  int200   s0;
  uint168 immutable public s1;
  mapping(int112 => uint232)  public s2;
  constructor(int200 i0,uint168 i1)   {
    s0 |= (i0 |= ((((int200(803469022129495137770981046170581301261101496891396417650687) + (int200(0) | int200(0))) - int200(803469022129495137770981046170581301261101496891396417650687)) ^ int200(803469022129495137770981046170581301261101496891396417650687)) ^ int200(0)));
    s1 = ((((uint168(207689509565953472965433529304463937047710930299481) + uint168(0)) ^ uint168(374144419156711147060143317175368453031918731001855)) - uint168(198158846520185637950798181629937757533754904928200)) % uint168(169735175240472495859822821341972861261162040835474));
    s2[(int112(2596148429267413814265248164610047) + ((int112(2414693109919056399670301707660524) + int112(2596148429267413814265248164610047)) ^ int112(-2010691790221444348742808867317520)))] = uint232(0);
    unchecked {
      int200  l0 = s0;
      int200  l1 = l0;
      assert(l1 == s0);
      emit L0.ev0((uint120(0) ** uint40(uint40((int40(549755813887) - (int40(-305820709235) | int40(0)))))), uint40(1062319116779));
      int200  l2 = s0;
      int200  l3 = l2;
      assert(l3 == s0);
    }
  }
  using L0 for *;
  using L0 for *;
}
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su1.sol:114-121): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:131-144): Unused local variable.
// Warning 2072: (su1.sol:401-408): Unused local variable.
// Warning 2072: (su1.sol:608-621): Unused local variable.
// Warning 2072: (su1.sol:1023-1117): Unused local variable.
// Warning 5667: (su1.sol:1574-1584): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:80-420): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:423-1351): Function state mutability can be restricted to pure
