==== Source:  ====

==== Source: su0.sol ====
library L0 {
  event ev0();
  function f0(uint224 i0,bytes16 i1) internal    returns(function (int88, function () external   returns (bytes21, address payable, address payable)) external   returns (int136) o0,address payable o1,int48 o2)
  {
    bool l0 = false;
    int24 l1 = int24((int8(-114) / int24(((int24(8388607) ^ int24(0)) / int24(0)))));
  }
  event ev1();
}
contract C0 {
  using L0 for *;
  int112  public s0;
  constructor(int112 i0)   {
    s0 &= int112(0);
    unchecked {
      int112  l0 = s0;
      int112  l1 = l0;
      assert(l1 == s0);
      int112  l2 = s0;
      int112  l3 = l2;
      assert(l3 == s0);
      int112  l4 = s0;
      int112  l5 = l4;
      assert(l5 == s0);
      int112  l6 = s0;
      int112  l7 = l6;
      assert(l7 == s0);
      if (false)
      {
      }
      else
      {
      }
    }
  }
  receive() external   payable
  {
  }
  modifier m0() virtual
  {
    assert(false);
    _;
    for(    (~(((~(int160(730750818665451459101842416358141509827966271487))) + int160(0))));
true;
payable(address(this)))
    {
      bytes10 l0 = ((((((~(int96(0))) ** uint168(uint168(374144419156711147060143317175368453031918731001855))) ^ int96(-918309932353180359292821441)) + int96(0)) <= int96(15334618069733271995540586862)) ? bytes10(0xffffffffffffffffffff) : bytes10(0xffffffffffffffffffff));
      _;
      string memory l1 = string("000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff");
      int168 l2 = int168(187072209578355573530071658587684226515959365500927);
    }
    int112  l3 = s0;
    int112  l4 = l3;
    assert(l4 == s0);
    unchecked {
    }
  }
  using L0 for *;
}
using L0 for uint224;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  int216 el0;
  function (int168) external   returns (int8[2][5][9][6][1][8] memory, function (address payable) external   returns (function (int32, uint216) external   returns (bool, uint88)), bool) el1;
  bytes3 el2;
}
pragma solidity >= 0.0.0;
// ----
// Warning 3149: (su0.sol:1086-1172): The result type of the exponentiation operation is equal to the type of the first operand (int96) ignoring the (larger) type of the second operand (uint168) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:42-52): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:53-63): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:85-208): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:209-227): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:228-236): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:246-253): Unused local variable.
// Warning 2072: (su0.sol:267-275): Unused local variable.
// Warning 5667: (su0.sol:437-446): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:944-1024): Statement has no effect.
// Warning 2018: (su0.sol:30-352): Function state mutability can be restricted to pure
