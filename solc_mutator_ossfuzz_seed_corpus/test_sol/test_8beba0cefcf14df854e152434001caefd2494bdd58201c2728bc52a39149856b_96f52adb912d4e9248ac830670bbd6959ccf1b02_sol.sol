
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
  }
  struct St0 {
    address el0;
    function (uint176, bool[10][][][7] memory, uint112) external   returns (function (int72) external   returns (int256), bytes1) el1;
    int32 el2;
  }
  address   s0 = address(this);
  C0.St0   s1;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}}

==== Source: su1.sol ====
struct St1 {
  address el0;
  int56 el1;
  bool el2;
}
pragma solidity >= 0.0.0;
library L0 {
  event ev0(function (bool) external   returns (address, string memory)  ep0, bool  ep1, int56  ep2);
  function f1(address i0) public    returns(bool o0,bytes29 o1)
  {
    uint200 l0 = (uint200(((uint200((uint200(0) / (uint200(0) ^ uint200(1606938044258990275541962092341162602522202993782792835301375)))) & uint200(0)) / uint200(0))) - uint200(1507910149736262420698798308989834908980738214766390521301285));
    uint192[1] memory l1 = [uint192(6277101735386680763835789423207666416102355444464034512895)];
  }
}
// ====
// ----
