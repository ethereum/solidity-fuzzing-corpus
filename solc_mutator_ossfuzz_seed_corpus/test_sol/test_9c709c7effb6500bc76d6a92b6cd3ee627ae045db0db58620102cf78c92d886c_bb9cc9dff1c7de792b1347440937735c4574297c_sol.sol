
==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
    if (false)
    {
    }
    for(uint solinit0 = 0; solinit0 < ((uint256((uint256(0) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) | uint256(104610717320945946289449840108097139876092768567427318471236954934667252308399)) % 11); solinit0++)
    {
    }
    payable(this).transfer(0);
    return;
  }
  error er0(int120[] ep0);
  function f1(bool i0,function (uint120) external   returns (bytes6, uint120) i1) private     returns(bytes10 o0,bytes29 o1)  {
    return (bytes10(0xffffffffffffffffffff), bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
  }
  address payable[10]  public s0;

	function compareMemoryAndStorage(address payable[10] memory v1, address payable[10] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  int152   s1;
  constructor(address payable[10] memory i0,int152 i1)   {
    s0 = i0;
    s1 %= ((int152(2636855355158139923502273786368019356450935180) - ((int152(uint152(0)) | int152(1789321561201092297059254936193268648898807440)) * int152(-1469546629256390999649377772488145512358972399))) - int152(2854495385411919762116571938898990272765493247));
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
uint80 constant cons0 = 0;
pragma solidity >= 0.0.0;
struct St0 {
  uint48 el0;
}
struct St1 {
  function (address payable, function () external   returns (int32[] memory, address, bytes memory)) external   returns (uint64, function () external  ) el0;
  address el1;
  bytes13 el2;
  int40 el3;
}
error er1(bool ep0);
// ====
// ----
