
==== Source: su0.sol ====
function f0(address i0)     {
  revert((hex"ffffffffffffffffffffffffffff" f1 /*suffix expr*/ ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded")));
}
pragma solidity >= 0.0.0;
function f1(bytes14 i0) pure suffix  returns(bool o0)
{
  o0 = (((int120(0) >= ((int120(0) | int120(0)) % int120(664613997892457936451903530140172287))) ? false : true) == true);
  assert(o0 == (((int120(0) >= ((int120(0) | int120(0)) % int120(664613997892457936451903530140172287))) ? false : true) == true));
  for(uint solinit0 = 0; solinit0 < ((uint256(uint184(24519928653854221733733552434404946937899825954937634815)) % (uint128((uint128(259121869720903343512811973948367633726) / uint128(112519230557916780439694499047383743622))) ^ uint128(135441219168763527690377380706797906008))) % 11); solinit0++)
  {
    continue;
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
bytes27 constant cons0 = bytes27(0x000000000000000000000000000000000000000000000000000000);
struct St0 {
  bytes el0;
  address payable el1;
}
// ====
// ----
