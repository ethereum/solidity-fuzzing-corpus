
==== Source: su0.sol ====
library L0 {
  event ev0(int64[][]  ep0);
  function f0(bytes memory i0) external    returns(bytes16 o0)
  {
  }
}
library L1 {
  function f1(string memory i0,function (bool, function () external   returns (bytes2), bool) external   returns (uint128) i1) external   
  {
    {
    }
  }
  error er0(bool ep0);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L2 {
  function f2(uint72 i0) public    returns(bool o0,function () external   returns (address payable, int248, bytes10) o1)
  {
    (((~(bytes24(0xafe8eb18a3b68f6ebb29d031dabe2601eff06fdb2a3aac17))) & (bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff) & bytes24(0x000000000000000000000000000000000000000000000000))) ^ bytes24(0x463be3c009074341cd24ad664de6669e8b69b25055aaf2c3));
    uint64 l0 = ((bytes4(0x00000000) == bytes4(0x00000000)) ? uint64(0) : uint64(18446744073709551615));
    uint64[][9][3][][][10] memory l1 = [new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8), new uint64[][9][3][][](8)];
  }
}
using L2 for uint72;
pragma solidity >= 0.0.0;
library L3 {
  function f3(address i0,address payable i1) external    returns(function (address payable, uint56, uint136) external   o0)
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000007));
    int128 l1 = (~(int128(170141183460469231731687303715884105727)));
    bool l2 = false;
  }
}
// ====
// ----
