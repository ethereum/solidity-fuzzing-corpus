
==== Source: su0.sol ====
contract C0 {
  modifier m0(bytes8 i0) 
  {
    {
      _;
      if (true)
      {
        if (true)
        {
        }
        else if (false)
        {
          if (false)
          {
            i0 |= bytes8(0x0000000000000000);
          }
          else
          {
          }
        }
        else
        {
        }
      }
      else
      {
      }
      if (false)
      {
      }
      else if (false)
      {
        if ((((uint64(15083428354430551892) ^ (uint64(5951617894406724610) ** uint176(uint176(73213390669756231780715784367084737306977641876936322)))) ^ uint64(11721547703898910819)) > uint64(18446744073709551615)))
        {
          _;
          _;
          (bool l0, bytes memory l1) = address(this).call("00000000000000000000000000000000ffffffffffff");
        }
      }
      (bool l2, bytes memory l3) = address(this).call("00000000000000000000000000000000000000000000000000ffffff");
      _;
      (bool l4, bytes memory l5) = address(this).call(bytes("c13174d4871f8bfe42947737d3d42d58ffffffffffffffffffffffffffffffffffffff"));
    }
  }
  error er0(address ep0);
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25
  }
  function f0(uint32[] calldata i0) public  m0(bytes8(0x0000000000000000)) m0(bytes8(0x0000000000000000))  returns(bool o0,bool o1,bytes11 o2)
  {
    do
    {
      return (false, false, bytes11(0x0000000000000000000000));
      continue;
      break;
    }
    while (false);
  }
  bool  public s0;
  bool immutable  s1 = true;
  constructor(bool i0)   {
    s0 = true;
    unchecked {
    }
  }
}
bytes6 constant cons0 = bytes6(bytes4(0xffffffff));
function f1(bytes memory i0,address payable i1)    
{
}
struct St0 {
  bool el0;
  bool[] el1;
  C0.EN0 el2;
  uint168 el3;
}
error er1(uint72 ep0);
pragma solidity >= 0.0.0;
// ====
// ----
