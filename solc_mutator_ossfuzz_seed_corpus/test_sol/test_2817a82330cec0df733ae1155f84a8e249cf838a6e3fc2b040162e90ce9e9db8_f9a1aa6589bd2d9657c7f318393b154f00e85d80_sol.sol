
==== Source: su0.sol ====
type T0 is int64;
pragma solidity >= 0.0.0;
function f0(int8 i0,T0[] memory i1)     returns(T0[1] memory o0)
{
}
library L0 {
  error er0();
  event ev0(bytes  ep0, address payable  ep1);
  event ev1(int224  ep0);
  function f1() public    returns(bytes21 o0)
  {
    if (true)
    {
      (T0[1] memory l0) = f0({i0: int8((int8(10) / (int8(-89) ** uint88((uint88(176273386960597090011448817) >> uint248(uint248(0))))))), i1: new T0[](2)});
    }
    if (true)
    {
    }
  }
  T0 public constant cons0 = T0.wrap(int64(9223372036854775807));
  using L0 for *;
  modifier m0() 
  {
    _;
  }
  error er1();
  type T1 is address payable;
  function f2(address payable i0,function (bool, address payable) external   returns (int248, uint32) i1) external  m0() 
  {
    try i1(true,payable(address(0x0000000000000000000000000000000000000007))) returns (int248 l0, uint32 l1)
    {
    }
    catch
    {
    }
    while (false)
    {
      revert er0();
      if ((false && true))
      {
        try i1(true,payable(address(0x0000000000000000000000000000000000000001))) returns (int248 l2, uint32 l3)
        {
          break;
          break;
          while (false)
          {
          }
        }
        catch
        {
          try i1((false || false),payable(address(0x0000000000000000000000000000000000000005))) returns (int248 l4, uint32 l5)
          {
            unchecked {
            }
            true;
          }
          catch
          {
          }
        }
      }
      else
      {
        continue;
      }
      continue;
    }
  }
  modifier m1(L0.T1 i0) 
  {
    for(;
;
bytes9(0xf51e95f2da4c93c613))
    {
      if ((uint8(0) <= (~((uint8(((uint8(199) - uint8(255)) / uint8(255))) >> uint8(uint8(0)))))))
      {
        _;
      }
      else if ((((~(((int72(0) & int72(283163284309927239295)) ^ int72(722019204714575157126)))) < int72(2361183241434822606847)) && true))
      {
        bytes12 l0 = bytes12(0x000000000000000000000000);
      }
      _;
      if ((false != false))
      {
        revert er1();
      }
      else
      {
      }
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44
}
using L0 for uint;
// ====
// ----
