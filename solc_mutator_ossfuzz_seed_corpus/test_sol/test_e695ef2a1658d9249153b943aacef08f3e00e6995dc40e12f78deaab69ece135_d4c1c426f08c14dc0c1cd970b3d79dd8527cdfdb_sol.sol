
==== Source: su0.sol ====
library L0 {
  type T0 is bool;
}
pragma solidity >= 0.0.0;
contract C0 {
  using L0 for *;
  fallback() external   
  {
    for(    int40 l0 = ((int40(549755813887) & (((int40(-280355249795) ^ int40(549755813887)) ^ int40(0)) ^ int40(154335862168))) * int40(0));
;
)
    {
      require(false);
      delete l0;
    }
  }
  uint120   s0 = uint120(0);
  address payable   s1;
  int88   s2;
  uint144   s3;
  constructor(address payable i0,int88 i1,uint144 i2) payable  {
    s1 = payable(address(this));
    s2 /= (int88(-49613227491498622572525710) * (int88(154742504910672534362390527) & int88(154742504910672534362390527)));
    s3 ^= (true ? ((uint144(0) * (uint144(0) ^ uint144(0))) << uint24(uint24(16777215))) : uint144(0));
    {
      unchecked {
        require((bytes10(0x00000000000000000000) < (false ? bytes24(0x000000000000000000000000000000000000000000000000) : bytes24(0x000000000000000000000000000000000000000000000000))), (true ? string("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") : string("000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffff")));
        (bool l0, bytes memory l1) = address(this).call(abi.encodePacked(int112(int112(0)), L0.T0(L0.T0.wrap(false)), bool(false)));
      }
    }
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
