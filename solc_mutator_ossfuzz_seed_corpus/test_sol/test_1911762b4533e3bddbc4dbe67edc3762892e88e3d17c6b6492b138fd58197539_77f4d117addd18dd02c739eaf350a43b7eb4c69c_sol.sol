
==== Source: su0.sol ====
contract C0 {
  function f0(function (function (address) external   returns (int240, bool[] memory), bool, function (bytes25, bool) external  ) external   returns (bytes17) i0) public      {
  }
  address payable  public s0 = payable(address(this));
  uint200  public s1;
  mapping(uint72 => bytes32[])   s2;
  constructor(uint200 i0)   {
    s1 *= ((uint200(((((uint200(1202051374264223050022989525016324215317210778206820049732180) + uint200(1591902692246827985502730898151409753696732693142664865385940)) - uint200(1606938044258990275541962092341162602522202993782792835301375)) << uint88(uint88(283709682739482743744672424))) / uint200(1606938044258990275541962092341162602522202993782792835301375))) ** uint192(uint192(6277101735386680763835789423207666416102355444464034512895))) % uint200(1606938044258990275541962092341162602522202993782792835301375));
    unchecked {
    }
  }
  struct St0 {
    uint16 el0;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
contract C1 is C0 {
  event ev0(string  ep0) anonymous;
  type T0 is address payable;
  C1.T0  public s3 = C1.T0.wrap(payable(address(0x0000000000000000000000000000000000000003)));
  bool   s4;
  mapping(bytes26 => uint248)   s5;
  constructor(uint200 i0,bool i1) payable C0(uint200(1606938044258990275541962092341162602522202993782792835301375))
  {
    s1 %= uint200(0);
    s4 = (true ? (uint40(0) > (uint16(11933) << uint64(uint64(18446744073709551615)))) : false);
    s5[bytes26(0x0000000000000000000000000000000000000000000000000000)] <<= uint248(452312848583266388373324160190187140051835877600158453279131187530910662655);
    {
    }
  }
  error er0(bytes18 ep0, C1.T0 ep1);
}
struct St1 {
  bytes27 el0;
  address payable el1;
  address payable el2;
}
// ====
// ----
