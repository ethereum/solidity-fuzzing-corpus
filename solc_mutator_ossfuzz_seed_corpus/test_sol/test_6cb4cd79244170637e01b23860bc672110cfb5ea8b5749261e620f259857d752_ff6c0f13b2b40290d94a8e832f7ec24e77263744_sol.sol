
==== Source: su0.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35
}
library L0 {
  event ev0();
  function f0() internal    returns(function (address, uint128, address payable) external   returns (bool) o0)
  {
  }
  using L0 for *;
  bytes16 public constant cons0 = ((((((bytes9(0x82aab021af1172cb66) == bytes9(0x37ea709a9905044357)) ? bytes16(0xf6e3bd211a23e5b2e71f6d308b6949a7) : bytes16(0xea2862e37eec1979fd75d1b59c171b0c)) & bytes16(0x8e2b3e9dd102cbea0e276578cd9c66f3)) | bytes16(0x00000000000000000000000000000000)) | bytes16(0x38b1257e8e67cf33381c53740867c934)) | bytes16(0x00000000000000000000000000000000));
  uint136 public constant cons1 = ((uint136(((((uint136(67966927655758556927090281295124562626456) ^ uint136(0)) & uint136(87112285931760246646623899502532662132735)) % uint136(87112285931760246646623899502532662132735)) / uint136(68330521964604045081579797900278803538163))) | uint136(87112285931760246646623899502532662132735)) ** uint16(uint16(65535)));
  modifier m0() 
  {
    assembly
    {
      {
        let al0 := cons0
        {
        }
      }
    }
    _;
  }
  error er0();
}
using L0 for uint;
uint112 constant cons2 = ((((~((~((uint112(0) - uint112(1448039301081178241894571815207584)))))) & uint112(0)) << uint216(uint216(49708255955020655671333134899250222243711727002670808930136614534))) ^ uint112(5192296858534827628530496329220095));
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
type T0 is bool;
error er1(bytes ep0, int32 ep1);
pragma solidity >= 0.0.0;
function f1(uint120 i0)     returns(function () external   returns (bytes9) o0,uint56 o1,uint168[1] memory o2)
{
  for(  address l0 = address(0x0000000000000000000000000000000000000002);
;
)
  {
    unchecked {
      do
      {
        revert er1("0000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffff", int32(0));
      }
      while ((false || false));
      return (o0, (((uint56(72057594037927935) | uint56((uint56(72057594037927935) / uint56(72057594037927935)))) >> uint248(uint248(48171736586692285202340136731250457397720418263149245701412154192861504878))) % uint56(6407334231848173)), [uint168(112096254752940551577458318097760760077367624326181)]);
      break;
      if ((int48(140737488355327) > int48(140737488355327)))
      {
        o2[0] &= uint168(99406769128511377891295060506026277169890752251087);
        {
          return (o0, (uint56(0) * (((uint56(0) * uint56(48228976237611561)) << uint24(uint24(9014081))) ^ uint56(72057594037927935))), [uint168(0)]);
          return (o0, uint56(4832711875603702), [uint168(0)]);
          do
          {
            (o2[0], o2[0]) = ((~(((((uint168(197420614499947926532422279874441095570545110879263) << uint64(uint64(10319115272597846765))) >> uint16(uint16(54363))) >> uint32(uint32(3957801243))) - uint168(374144419156711147060143317175368453031918731001855)))), (((uint168(374144419156711147060143317175368453031918731001855) | ((uint168(290582642348904954794599288554186681858369270298489) ** uint240(uint240(279617999565533470736679179958056540445441538837798867634679472729495592))) ^ uint168(374144419156711147060143317175368453031918731001855))) | uint168(374144419156711147060143317175368453031918731001855)) + uint168(107113830630751508760575758934297675093704254474129)));
            o2[0] >>= uint168(255945989636425977095623801043112209249995359967618);
            continue;
            return (o0, uint56(72057594037927935), [uint168(0)]);
          }
          while (false);
          break;
        }
        continue;
      }
      continue;
    }
    return (o0, (uint56(56015113681071250) & uint56(53265361399690663)), [uint168(0)]);
    continue;
  }
}
// ====
// ----
