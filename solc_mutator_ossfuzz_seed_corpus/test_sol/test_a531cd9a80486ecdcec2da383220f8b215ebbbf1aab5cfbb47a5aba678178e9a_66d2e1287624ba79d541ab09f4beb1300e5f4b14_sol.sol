
==== Source: su0.sol ====
library L0 {
  function f0(address payable i0,bool i1) internal    returns(bytes27 o0)
  {
  }
  function f1(int64[8][8] memory i0) internal   
  {
    uint152 l0 = (uint152((uint152(5708990770823839524233143877797980545530986495) / (uint152(((uint152(0) * uint152(5374551343908846570891578567780179309596905923)) / uint152(5708990770823839524233143877797980545530986495))) ** uint240(uint240(0))))) ^ uint152(0));
  }
}
using L0 for address payable;
pragma solidity >= 0.0.0;
using L0 for address payable;
using L0 for address payable;

==== Source: su1.sol ====
contract C0 {
  fallback() external   
  {
    address payable l0 = payable(address(this));
    int200 l1 = int200(-288114664681119533470478477004737261151902751572627036724115);
    (l0, l1) = (payable(address(this)), (int200((int200(-408870265195227822805503410336385644228993657592628636431920) / (((int232(0) < int232(2076225681146255701474070014875602964166538478236568010561117319973106)) ? int200(0) : int200(0)) + int200(-780701008279521663899062103585808755222865112650145472161700)))) % int200(803469022129495137770981046170581301261101496891396417650687)));
    assert(l0 == payable(address(this)));
    assert(l1 == (int200((int200(-408870265195227822805503410336385644228993657592628636431920) / (((int232(0) < int232(2076225681146255701474070014875602964166538478236568010561117319973106)) ? int200(0) : int200(0)) + int200(-780701008279521663899062103585808755222865112650145472161700)))) % int200(803469022129495137770981046170581301261101496891396417650687)));
    (bool l2, bytes memory l3) = address(this).call(bytes(string("000000000000000000000000000000000000000000000000000000000000")));
  }

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f3(string calldata i0,function (bytes6) external   returns (bytes12) i1) external virtual   returns(bool[] memory o0)
  {
    address payable[] storage l0;
    string memory l1 = i0;
    assert(compareMemoryAndCalldata(l1, i0));
    function (bool) external   returns (uint128, uint192) l3;
    string memory l4 = i0;
    assert(compareMemoryAndCalldata(l4, i0));
  }
  uint88  public s0 = uint88(0);
}
pragma solidity >= 0.0.0;
library L1 {
  function f4(bytes24[][][5] memory i0) public    returns(uint256 o0)
  {
  }
}
// ====
// ----
