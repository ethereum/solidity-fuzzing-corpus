
==== Source: su0.sol ====
library L0 {
  modifier m0(bytes16 i0) 
  {
    _;
    uint160[6][][][9][] memory l0 = new uint160[6][][][9][](2);
    _;
  }
  function f0(bytes11 i0) public  m0(bytes16(0xffffffffffffffffffffffffffffffff)) m0(bytes16(0x2603ad1fa02e879ab5cb608b351f5143))  returns(uint144 o0,int240 o1)
  {
    int176 l0 = (int176(-27975301582691894446311259673637859881600293003758685) + int176(0));
    bytes28 l1 = bytes28(bytes22(0x592769fb608021ac48c20b717649fb9ab21d7a92900f));
  }
  function f1(address i0) public  m0(bytes16(0x969df507c5e2fa25642a2b515ffe15f4))  returns(function (string memory, int160) external   returns (function (address payable) external   returns (bool, int152, bytes18), uint144) o0)
  {
    (uint144 l0, int240 l1) = f0({i0: bytes11(bytes14(0xffffffffffffffffffffffffffff))});
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffff00"));
    bool l2 = false;
    bytes memory l3 = bytes("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  }
  int24   s0 = int24(0);
  mapping(int96 => address)   s1;
  bytes26   s2;
  constructor(bytes26 i0) payable  {
    s2 |= bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff);
    s1[int96(39614081257132168796771975167)] = address(this);
    unchecked {
    }
  }
  using L0 for *;
  struct St0 {
    address payable el0;
    function (uint24) external   returns (bool) el1;
    address[2][] el2;
  }
}
// ====
// ----
