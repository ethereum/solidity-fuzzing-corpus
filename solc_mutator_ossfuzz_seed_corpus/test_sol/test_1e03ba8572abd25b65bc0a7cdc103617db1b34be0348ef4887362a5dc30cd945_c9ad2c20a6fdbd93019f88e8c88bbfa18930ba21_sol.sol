==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0() public   
  {
    bool l0 = true;
    address payable l1 = payable(address(0x0000000000000000000000000000000000000001));
    unchecked {
      uint208 l2 = ((uint208(411376139330301510538742295639337626245683966408394965837152255) ^ uint208(((true ? uint208(0) : uint208(0)) / uint208(271525025090624893278768002092660871957132214263165798366778113)))) & uint208(123802732358553448675607200967558784092249662966102520253272248));
    }
  }
  function f1() external    returns(int128 o0,function (int208, uint72) external   returns (bytes memory, bool) o1)
  {
    return (((int16(((int16((int16(32767) / int16(32767))) | int16(0)) / int16(32767))) ^ int16(-7667)) | int16(14693)), o1);
  }
}
contract C0 {
  function f2() external virtual  
  {
    address payable l0 = payable(address(this));
    function (int64[5][][8][5][3][] memory) external   returns (function () external  ) l1;
    uint232 l2 = (uint232(((~(int232(0))) | int232(3450873173395281893717377931138512726225554486085193277581262111899647))) % uint232(649235863236621781313499853501262757569770412717023174440873729152287));
    address[9][] storage l3;
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  address  public s0;
  bool   s1 = false;
  bytes5  public s2;
  mapping(int96 => address)   s3;
  constructor(address i0,bytes5 i1)   {
    s0 = address(bytes20(address(0x0000000000000000000000000000000000000000)));
    s2 ^= (~(bytes5(0x3482015f33)));
    s3[int96(39614081257132168796771975167)] = address(this);
    unchecked {
      {
        (bool l0, bytes memory l1) = address(this).delegatecall(abi.encodeWithSignature("f2()"));
        {
        }
      }
      for(;
false;
int112(996098009995176538558377313568148))
      {
      }
      bool  l2 = s1;
      bool  l3 = l2;
      assert(l3 == s1);
      bytes5  l4 = s2;
      bytes5  l5 = l4;
      assert(l5 == s2);
      { }
    }
  }
  fallback() external   payable
  {
    bool  l0 = s1;
    bool  l1 = l0;
    assert(l1 == s1);
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:721-2012): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 2072: (su0.sol:47-54): Unused local variable.
// Warning 2072: (su0.sol:67-85): Unused local variable.
// Warning 2072: (su0.sol:172-182): Unused local variable.
// Warning 2072: (su0.sol:778-796): Unused local variable.
// Warning 2072: (su0.sol:827-913): Unused local variable.
// Warning 2072: (su0.sol:919-929): Unused local variable.
// Warning 2072: (su0.sol:1127-1150): Unused local variable.
// Warning 6133: (su0.sol:1696-1737): Statement has no effect.
// Warning 5667: (su0.sol:1322-1332): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1333-1342): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1560-1567): Unused local variable.
// Warning 2072: (su0.sol:1569-1584): Unused local variable.
// Warning 2018: (su0.sol:15-468): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:471-718): Function state mutability can be restricted to pure
