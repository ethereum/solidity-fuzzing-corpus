
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  mapping(bool => address) el0;
  function (bool, address) external   returns (bytes12, int32) el1;
}
library L0 {
  function f0() public   
  {
    if ((bytes12(0xffffffffffffffffffffffff) < bytes12(0x25fbb4d7fd08e989375e1a0b)))
    {
    }
    else if (true)
    {
      do
      {
        for(;
true;
)
        {
          break;
        }
      }
      while (false);
    }
    if (false)
    {
    }
  }
  event ev0();
  bytes12 public constant cons0 = bytes12(0x000000000000000000000000);
  modifier m0() 
  {
    for(    function () external   l0;
false;
)
    {
      try l0()
      {
        function (bool) internal   returns (address, bytes9, address) l1;
        _;
      }
      catch
      {
      }
    }
    do
    {
      _;
      continue;
      for(      int248(((int248(0) & ((int248(0) & int248(81553889967179653605543092188323088335662638010617928244162295990724299785)) & int248(140116348485214700159957992941682363910476019761534940754656877249449751307))) / int248(16726176337418876248940671042215663824665983804738128747811719050787214050)));
;
)
      {
        for(        bytes27[] memory l2 = new bytes27[](2);
true;
(((int224((int224(0) / (int224(0) * int224(13479973333575319897333507543509815336818572211270286240551805124607)))) % int224(-6251257100625142542751548118563086333329749508314742680021384164870)) | int224(0)) ^ int224(13479973333575319897333507543509815336818572211270286240551805124607)))
        {
          _;
          break;
          if (true)
          {
          }
          _;
          (l2[0]) = (l2[0]);
        }
        assembly
        {
        }
      }
    }
    while (true);
  }
  modifier m1() 
  {
    _;
    emit ev0();
    int240 l0 = int240(883423532389192164791648750371459257913741948437809479060803100646309887);
    assert((false && true));
  }
  modifier m2() 
  {
    if (true)
    {
      _;
    }
    else if (false)
    {
    }
    for(    bytes16 l0 = bytes16(0x769374a1a36dc9d19043c09a6d1b547c);
;
)
    {
      break;
      if (false)
      {
        emit ev0();
        break;
      }
      else
      {
        (l0) = (bytes16(0x00000000000000000000000000000000));
      }
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54
  }
}
// ====
// ----
