==== Source:  ====

==== Source: su0.sol ====
library L0 {
  error er0(bool ep0, bool ep1);
  event ev0(bool  ep0, uint232  ep1, bytes18  ep2);
  bytes22 public constant cons0 = ((int56(0) == (((int56(0) + int56(0)) & int56(-33777161701446532)) - int56(36028797018963967))) ? bytes22(0xffffffffffffffffffffffffffffffffffffffffffff) : bytes22(0x5b2e2b3bed5b5c534dd20fbe8778941dd02c18cc6489));
}
function f0()     returns(bool o0,bool o1)
{
  (o1) = (false);
  if (((((((uint104(20282409603651670423947251286015) % uint104(0)) % uint104(20282409603651670423947251286015)) >> uint104(uint104(0))) & uint104(17354116804794238368654831393416)) & uint104(363824970061718453737983626612)) < uint104(0)))
  {
  }
  else
  {
  }
  if (false)
  {
  }
  else if ((false || false))
  {
    (bool l0, bool l1) = f0();
    assert(true);
  }
  else if (false)
  {
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
error er1();
contract C0 {
  modifier m0() 
  {
    _;
  }
  address payable immutable public s0;
  string  public s1;
  int208   s2;
  bytes1[]  public s3;
  constructor(address payable i0,string memory i1,int208 i2,bytes1[] memory i3)   {
    s0 = payable(address(this));
    s1 = i1;
    s2 |= ((int208(205688069665150755269371147819668813122841983204197482918576127) & ((int208((int208(0) / int208(94484439936421108578477152709949361763733254735039273319233993))) & int208(85422484224003764440224346987403224241064615646463313713824112)) * int208(205688069665150755269371147819668813122841983204197482918576127))) & int208(205688069665150755269371147819668813122841983204197482918576127));
    s3 = i3;
    unchecked {
      do
      {
        {
          break;
          s3 = [bytes1(0xff), bytes1(0x47)];
          break;
        }
        uint24 l0 = ((uint24(16777215) + ((uint24(2914129) + uint24(16777215)) ^ uint24(0))) ^ uint24(12936778));
        if ((bytes18(0xffffffffffffffffffffffffffffffffffff) <= bytes18(0xffffffffffffffffffffffffffffffffffff)))
        {
          if ((!((true || true))))
          {
            i3[0] &= bytes1(0x00);
          }
          continue;
          s3.push(bytes1(0xc3));
        }
      }
      while ((true || true));
    }
  }
  function f1(uint224 i0) external   payable
  {
  }
  function f2() external virtual  payable returns(int120 o0)
  {
  }
  bytes4 public constant cons1 = ((bytes4(0x00000000) & (((bytes4(0x18cf4416) | bytes4(0x00000000)) & bytes4(0x00000000)) & bytes4(0xffffffff))) ^ bytes4(0x9c3cacc4));
  type T0 is address;
  struct St0 {
    bytes23 el0;
    C0.T0 el1;
  }
  function f3() public  m0() payable returns(bytes memory o0)
  {
  }
}
function f4()     returns(int216 o0)
{
  revert er1();
}
// ----
// Warning 5740: (su1.sol:803-853): Unreachable code.
// Warning 5740: (su1.sol:873-1259): Unreachable code.
// Warning 5740: (su1.sol:1281-1295): Unreachable code.
// Warning 5667: (su0.sol:374-381): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:733-740): Unused local variable.
// Warning 2072: (su0.sol:742-749): Unused local variable.
// Warning 5667: (su1.sol:197-215): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:233-242): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:873-882): Unused local variable.
// Warning 5667: (su1.sol:1769-1778): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:1743-1799): Function state mutability can be restricted to pure
