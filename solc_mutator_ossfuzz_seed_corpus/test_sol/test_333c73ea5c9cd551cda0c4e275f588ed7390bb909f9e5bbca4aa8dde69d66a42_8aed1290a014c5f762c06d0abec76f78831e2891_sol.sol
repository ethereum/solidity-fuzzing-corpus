
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(bool i0) external     returns(address[4] memory o0,address payable[8] memory o1)  {
    (o0) = ([address(0x0000000000000000000000000000000000000008), address(0x0000000000000000000000000000000000000002), address(0x0000000000000000000000000000000000000006), address(0x0000000000000000000000000000000000000001)]);
    delete o1[(uint256(0) ^ ((~(uint256(0))) ** uint256(uint256(0))))];
  }
  receive() external   payable
  {
    require((bytes3(0x000000) != bytes3(0xe3308c)), string("This is a really long string that must ideally be random but is currently hard coded"));
    (bool l0) = payable(this).send(0);
  }
  int232   s0 = int232(1325369043277569824444939055683640475952035256639769004817315299422966);
  struct St0 {
    bool el0;
    bytes26 el1;
    bytes11 el2;
    bytes el3;
  }
  struct St1 {
    address el0;
  }
}
contract C1 {
  uint160 public constant cons0 = 0;
  event ev0();
  bool immutable public s1 = false;
  event ev1(int208 indexed ep0);
  struct St2 {
    address payable el0;
    C0 el1;
    bytes15 el2;
    uint32 el3;
  }
}

==== Source: su1.sol ====
contract C2 {
  bool   s2 = false;
  uint200 immutable  s3 = uint200(342314724454198280113499290383818299405066546922010174127414);
  receive() external   payable
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
  }
  function f3() private     returns(bool o0)  {
    while (false)
    {
      o0 = false;
      assert(o0 == false);
    }
  }
  type T0 is uint24;
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
