==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0() internal   
  {
    int216 l0 = ((int216(0) % int192((int184(12259964326927110866866776217202473468949912977468817407) ** uint120(uint120(1329227995784915872903807060280344575))))) + int216(0));
  }
  event ev0(function (int24) external   returns (bytes25, address payable)  ep0);
}
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
  }
  fallback() external   
  {
    for(    uint184 l0 = (((uint184(12238102134688761496913542998038437323688783535225870195) + (~(uint168(270776881869479274661423872489897693505329549249966)))) % uint184(24519928653854221733733552434404946937899825954937634815)) + uint184(0));
false;
)
    {
      function (bytes29[6][][3][] memory) external   l1;
      bytes32[][][][2] memory l2 = ((true ? false : false) ? [new bytes32[][][](3), new bytes32[][][](3)] : [new bytes32[][][](3), new bytes32[][][](3)]);
      address payable l3 = payable(address(this));
    }
    (bool l4, bytes memory l5) = payable(this).call{value: 13604479083240346513}("");
  }
  using L0 for *;
  bytes24  public s0;
  constructor(bytes24 i0)   {
    s0 ^= (false ? bytes24((bytes31(0x385bdca86faaa115b4288771ef87f0f2b6531faebc5204e99f659c53bf86d3) ^ (~(bytes31(0x266a7da558688518f18dbf91d48a911846cd95276d25652632b8f3ada18378))))) : bytes24(0x000000000000000000000000000000000000000000000000));
    unchecked {
      bytes24  l0 = s0;
      bytes24  l1 = l0;
      assert(l1 == s0);
    }
  }
  using L0 for *;
  error er0();
}
contract C1 {
  using L0 for *;
  using L0 for *;
  uint176  public s1 = uint176(0);
  bool   s2;
  bytes6  public s3 = bytes6(0xffffffffffff);
  int176   s4;
  constructor(bool i0,int176 i1)   {
    s2 = ((int248(0) + int248(-187405405984914259589486191706091654462232764419495049660705077692586629639)) <= (int248(89042843973661128485879273328169849006233715794940616415101451838138938264) & int248(0)));
    s4 |= int176(0);
    unchecked {
      for(      0;
;
C0(payable(address(this))))
      {
      }
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
      require((payable(address(this)) <= (true ? payable(address(this)) : payable(address(this)))));
      bytes6  l2 = s3;
      bytes6  l3 = l2;
      assert(l3 == s3);
      bytes6  l4 = s3;
      bytes6  l5 = l4;
      assert(l5 == s3);
      revert C0.er0();
    }
  }
}
// ----
// Warning 2072: (su0.sol:49-58): Unused local variable.
// Warning 2072: (su0.sol:432-442): Unused local variable.
// Warning 2072: (su0.sol:688-737): Unused local variable.
// Warning 2072: (su0.sol:745-771): Unused local variable.
// Warning 2072: (su0.sol:900-918): Unused local variable.
// Warning 2072: (su0.sol:956-963): Unused local variable.
// Warning 2072: (su0.sol:965-980): Unused local variable.
// Warning 5667: (su0.sol:1095-1105): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:1953-1954): Statement has no effect.
// Warning 5667: (su0.sol:1666-1673): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1674-1683): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:15-227): Function state mutability can be restricted to pure
