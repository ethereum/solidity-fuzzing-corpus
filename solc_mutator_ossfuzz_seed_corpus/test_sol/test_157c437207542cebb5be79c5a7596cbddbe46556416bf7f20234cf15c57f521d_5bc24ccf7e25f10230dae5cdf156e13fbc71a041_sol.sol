
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  modifier m0() 
  {
    _;
  }
  function f0() internal  m0()  returns(int120[][][][4][][6] memory o0,bytes17 o1)
  {
    bytes18 l0 = (bytes14(bytes20(address(0x0000000000000000000000000000000000000000))) & bytes18(0xffffffffffffffffffffffffffffffffffff));
    o0[(uint256((uint176(0) >> uint200(uint200(((~(uint200(0))) / uint200(317949580165313027261763122775924638342519293586814830291485)))))) % uint256(77971080524942668056782874916584744584954927377606938558807591614721432201657))] = ((true ? true : true) ? o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] : new int120[][][][4][](9));
    bool l1 = true;
  }
  function f1() external  m0()  returns(bytes23 o0,function (bool, bytes22, bytes5) external   returns (int152) o1)
  {
    bytes15(0x54a00a8ca4324f8639f84d3afade35);
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  bytes4  public s0 = bytes4(0x64b1eb6c);
  uint8  public s1 = uint8(167);
  bool   s2;
  constructor(bool i0)   {
    s2 = true;
    unchecked {
    }
  }
  receive() external   payable
  {
    bool  l0 = s2;
    bool  l1 = l0;
    assert(l1 == s2);
    bool  l2 = s2;
    bool  l3 = l2;
    assert(l3 == s2);
  }
  struct St0 {
    uint8 el0;
    bytes29 el1;
    int40[][6][5][][7][10] el2;
  }
  struct St1 {
    uint64 el0;
    bytes22 el1;
    bool el2;
  }
}
// ====
// ----
