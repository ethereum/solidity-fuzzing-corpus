
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
    bytes9[3][] storage l0;
  }
  int96   s0 = int96(-37265855360031023842159993886);
  int144   s1;
  mapping(bytes5 => int120)   s2;
  int256 immutable public s3 = int256(0);
  constructor(int144 i0) payable  {
    s1 %= (int144(-9068393546526733425160162402292908434452887) % (-(((int144(int120(664613997892457936451903530140172287)) - int144(0)) + int144(-5015027445864990738124944434156962495058609)))));
    s2[bytes5(0x0000000000)] = ((((~(int120(76503244772006977397471912733295299))) ^ (int120(0) - int120(0))) ^ int120(299740163568251409969677370404752949)) + int120(0));
    unchecked {
      {
        int144  l0 = s1;
        int144  l1 = l0;
        assert(l1 == s1);
        int144  l2 = s1;
        int144  l3 = l2;
        assert(l3 == s1);
        int256  l4 = s3;
        int256  l5 = l4;
        assert(l5 == s3);
        s0 += (((int96(21617253437656700287913674015) - ((int96(39614081257132168796771975167) & int96(39614081257132168796771975167)) + int96(0))) | int96(39614081257132168796771975167)) ^ int96(720117806852560711959330791));
        int96  l6 = s0;
        int96  l7 = l6;
        assert(l7 == s0);
      }
    }
  }
}
library L0 {
  function f1() public    returns(bool o0,string memory o1)
  {
  }
  event ev0(uint104  ep0);
  function f2(bool i0,bytes17 i1,function (bool, function () external   returns (int16[][] memory)) external   returns (bool) i2) public    returns(bytes7 o0,uint152 o1)
  {
    bool l0 = true;
  }
}
using L0 for bool;
contract C1 {
  bytes26  public s4 = bytes26(0x551ac9d43cc48998e573a00d330fa318579f589e5008ad8fe107);
  int256  public s5 = int256(0);
  using L0 for *;
  using L0 for *;
}
// ====
// ----
