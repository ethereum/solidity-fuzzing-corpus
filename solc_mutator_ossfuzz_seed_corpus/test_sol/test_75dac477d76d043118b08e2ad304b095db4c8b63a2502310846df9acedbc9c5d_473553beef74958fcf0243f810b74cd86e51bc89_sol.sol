
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
    uint232 l0 = uint232(139077041490188652923736738633669579797090990967069253882272128948416);
  }
  fallback() external   
  {
    bool l0 = false;
    bool l1 = false;
    (l1) = (false);
    assert(l1 == false);
    assembly
    {
      l1 := mload(add(0x80, mod(l1, 2048)))
      l0 := calldataload(mod(extcodesize(1890383561545017770186114233748636902486120350915583564802382721060115955270), calldatasize()))
      function af0(ai0, ai1, ai2, ai3, ai4, ai5, ai6, ai7, ai8, ai9, ai10, ai11, ai12, ai13) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9
      {
        let al0 := ai0
        let al1 := 0
        calldatacopy(add(0x80, mod(0, 1024)), addmod(ai8, 335525131005208760099056221656489486417460394430248186765707840306556245107, 115792089237316195423570985008687907853269984665640564039457584007913129639935), mod(0, 1024))
        switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
        case 0
        {
          function af1(ai14, ai15, ai16, ai17, ai18, ai19, ai20, ai21, ai22, ai23, ai24, ai25, ai26, ai27, ai28, ai29, ai30) -> ao10, ao11, ao12, ao13, ao14, ao15
          {
            codecopy(add(0x80, mod(55603301233649777296474233012663029056157618571176844081194235056345240854465, 1024)), ai28, mod(ai28, 1024))
            let al2 := calldataload(mod(0, calldatasize()))
          }
        }
      }
    }
  }
  bytes8  public s0 = bytes8(0xffffffffffffffff);
  uint72   s1 = uint72(4250071741701165453994);
}
// ====
// ----
