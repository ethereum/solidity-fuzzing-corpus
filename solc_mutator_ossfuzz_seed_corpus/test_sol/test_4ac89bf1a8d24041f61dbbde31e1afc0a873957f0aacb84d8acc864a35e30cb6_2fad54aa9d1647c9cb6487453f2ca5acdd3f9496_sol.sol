
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0(address i0,uint8 i1,function () external   returns (int144, int8) i2) public   
  {
  }
  event ev0(function (address, address, bool) external   returns (int88, bool, bytes8)  ep0, bytes27  ep1, address payable  ep2, bytes25  ep3);
}

==== Source: su1.sol ====
contract C0 {
  bytes25  public s0;
  bytes5  public s1;
  bytes28  public s2 = bytes28(0x87b91d5fc72d007b78c1d148e0e146797ad4f2902b8b183094db558b);
  constructor(bytes25 i0,bytes5 i1) payable  {
    s0 = bytes25(0x3211e49e08051048540e60d9fb61cdd97c0cca38eb1b63bafd);
    s1 = (bytes5(0x83179de22d) | bytes5(0xffffffffff));
    {
      bytes25  l0 = s0;
      bytes25  l1 = l0;
      assert(l1 == s0);
      (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffff"));
      s2 |= ((((~(bytes18(0xffffffffffffffffffffffffffffffffffff))) | bytes18(0xf438c58567058e5398e0d9406a3e32c709ba)) | bytes18(0xffffffffffffffffffffffffffffffffffff)) & bytes28(0x00000000000000000000000000000000000000000000000000000000));
    }
  }
  event ev1(uint32 indexed ep0, uint208  ep1);
}
pragma solidity >= 0.0.0;
bytes9 constant cons0 = bytes9(0xffffffffffffffffff);
contract C1 is C0 {
  receive() external virtual  payable
  {
    bytes28  l0 = s2;
    bytes28  l1 = l0;
    assert(l1 == s2);
    require((true ? true : false));
    bytes5  l2 = s1;
    bytes5  l3 = l2;
    assert(l3 == s1);
    bytes28  l4 = s2;
    bytes28  l5 = l4;
    assert(l5 == s2);
  }
  bool   s3;
  constructor(bytes25 i0,bytes5 i1,bool i2)  C0(bytes25(0x98c4710e6c48c98ef7da31bb11f4de86e6f86c2a84c5510800), bytes5(bytes16(0xffffffffffffffffffffffffffffffff)))
  {
    s0 = bytes25(0xdc8be455c25cb00b8825e3e7c86fb161fe9cce54c6a28d62e7);
    s1 &= bytes5(0xffffffffff);
    s3 = true;
    unchecked {
      bool  l0 = s3;
      bool  l1 = l0;
      assert(l1 == s3);
    }
  }
}
// ====
// ----
