==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0(string memory i0,function (bytes10, bool) external   returns (bytes11) i1,uint184[] memory i2) public   
  {
  }
  modifier m0(int104 i0,int248 i1) 
  {
    assembly
    {
      return(i0, i1)
    }
    _;
  }
  using L0 for *;
  function f1(function (function () external  [2] memory, address[] memory, bytes memory) internal   i0,bool i1) private    returns(function (function (bytes30, bytes9) external   returns (bytes28), address, int248) external   returns (bytes8, bytes23, function (address payable) internal   returns (bool, address)[] memory) o0)
  {
  }
  function f2(function () internal   returns (function (bytes32, address) internal   returns (uint88, bool)) i0,address payable i1) public  m0(((~(int104((int104(0) / int104(6180597753450014580168852326718))))) * int8(19)),(int248((int248(-26895643654704663424446604901407243642583561688689687001249711140994797232) / (int248(-61095992595541444082919636955572165635831042483193378500899114786522034621) * int248(226156424291633194186662080095093570025917938800079226639565593765455331327)))) & int248(0))) 
  {
  }
  error er0();
  bool public constant cons0 = ((uint176((uint176((uint32(4294967295) / uint176(95780971304118053647396689196894323976171195136475135))) / uint176(75818551324454888855221931553051248652672732984635557))) * uint176(95780971304118053647396689196894323976171195136475135)) != uint176(0));
  error er1(bytes30[1] ep0);
  event ev0(function (bytes7, uint40) external   returns (int200, bytes[][2] memory, int136)  ep0);
}
using L0 for uint;
pragma solidity >= 0.0.0;
using L0 for uint;
using L0 for uint;
// ----
// TypeError 2582: (su0.sol:508-578): Internal type cannot be used for external function type.
