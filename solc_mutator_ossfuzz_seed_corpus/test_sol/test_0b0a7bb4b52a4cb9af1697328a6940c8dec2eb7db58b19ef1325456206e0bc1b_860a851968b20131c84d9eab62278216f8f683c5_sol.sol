
==== Source: su0.sol ====
struct St0 {
  mapping(bool => bool) el0;
  int232 el1;
  int72 el2;
  int208 el3;
}
type T0 is address payable;
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
type T1 is int152;
import "su0.sol";
pragma solidity >= 0.0.0;
uint192 constant cons0 = ((((uint192(((uint192(843798758885895943210872607010576919919294642889406287359) | uint192(4770565609700679887661713175401403361520761453031715512701)) / uint192(6277101735386680763835789423207666416102355444464034512895))) - uint192(6277101735386680763835789423207666416102355444464034512895)) ^ uint192(401825965564289556576246878776927212668595506517170420511)) >> uint24(uint24(15348935))) * uint192(6277101735386680763835789423207666416102355444464034512895));
contract C0 {
  error er0(int128 ep0, bytes21 ep1);
  bool[2]  public s0 = [true, false];
  int224   s1 = int224(10561819813254040883446686103431429884527481663739980454045689859615);
  T1 immutable public s2 = T1.wrap(int152(0));
  bytes18 public constant cons1 = bytes18(0x440cbda91664d5b94e36d2103e7ac70fec9e);
  struct St1 {
    function (uint40[] memory, T0) external   el0;
    uint144 el1;
    bytes14 el2;
    uint40 el3;
  }
}
function f0()    
{
}
error er1();
// ====
// ----
