
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  modifier m0(string memory i0) virtual
  {
    bytes28 l0 = bytes28(0xc141884daf0f315e6820805704edeea9acb34e3a447519c4c9914dca);
    require(true, string("00000000000000000000000000000000b9e3df556e8795"));
    _;
    uint128 l1 = (uint128(311442771418100859835243846699387936139) + uint128(0));
    function () internal   l2;
  }
  fallback() external  m0(string.concat((false ? string.concat(string.concat(string("428125de880fa5d23f1927a283ae23e017843fe2dacabb7a44a865b03d82f6")), string("ffffffffffffffffffffffffffffffffffffffff0000000000000000000000000000000000"), string("e129e66a1a251ff55c7e9dbc3b74d5c9772eb54d14"), string("ffffffffff0000000000000000000000000000000000000000000000000000000000000000")) : string("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")), string("ffffffffffffffffff0000000000000000000000000000000000000000000000000000000000000000"))) payable
  {
    assembly
    {
      switch calldataload(mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, calldatasize()))
      case 0
      {
        {
        }
      }
      let al0 := 0
    }
    function (bool) external   l0;
    payable(this).transfer(0);
  }
  bytes32   s0;
  constructor(bytes32 i0)   {
    s0 |= bytes32(0x068b5020bfedfae993962db353506b0ff41b72288e6bda26b57fbddf7cc693b9);
    unchecked {
      bytes32  l0 = s0;
      bytes32  l1 = l0;
      assert(l1 == s0);
      bytes32  l2 = s0;
      bytes32  l3 = l2;
      assert(l3 == s0);
      (bool l4) = payable(this).send(9257163148184772302);
      bytes32  l5 = s0;
      bytes32  l6 = l5;
      assert(l6 == s0);
    }
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  bytes27   s1 = bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  mapping(bool => mapping(bytes18 => mapping(bytes11 => bytes10)))   s2;
  bytes11   s3 = bytes11(0x0000000000000000000000);
  constructor()   {
    {
      bytes11  l0 = s3;
      bytes11  l1 = l0;
      assert(l1 == s3);
    }
  }
  int208 public constant cons0 = 0;
  struct St0 {
    address payable el0;
    int32 el1;
    uint72 el2;
    bool el3;
  }
}
// ====
// ----
