
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  struct St0 {
    address payable el0;
    int208 el1;
    address el2;
  }
  type T0 is bytes16;
  error er0(function () external   ep0, int56 ep1);
  address payable  public s0 = payable(address(this));
  mapping(int32 => C0.T0)[5]  public s1;
  bytes3  public s2 = bytes3(0x000000);
  bool  public s3 = false;
  error er1(bytes8 ep0, bytes ep1);
  struct St1 {
    C0.T0 el0;
    uint120 el1;
    int176 el2;
  }
}
contract C1 {
  struct St2 {
    function (uint112) external   returns (bytes2, address, function () external   returns (uint120, int32)) el0;
    bytes3 el1;
    uint232 el2;
  }
  fallback() external virtual  payable
  {
    return;
  }
  int64   s4;
  C0.T0  public s5;
  C0.T0  public s6 = C0.T0.wrap(bytes16(0x00000000000000000000000000000000));
  int216   s7;
  constructor(int64 i0,C0.T0 i1,int216 i2)   {
    s4 = (((int64(0) & int64(0)) % (int64(7575970118843925651) - int64(-101378628700700007))) | int64(9223372036854775807));
    s5 = C0.T0.wrap(bytes16(0xffffffffffffffffffffffffffffffff));
    s7 %= (int216(10865716548857493658483588195648480760684145755626836358256087143) | ((((true ? int216(0) : int216(-24786806102805747547702460217504533948347245714857935716607086552)) | int216(52656145834278593348959013841835216159447547700274555627155488767)) % int216(-34339747622154564779340287824431613958868684764684628742065020818)) - int216(-20551659001561115497463840718404062978198708010469924410308615967)));
    unchecked {
    }
  }
  type T1 is address payable;
  type T2 is int208;
}

==== Source: su1.sol ====
contract C2 {
  event ev0(bool  ep0, int200 indexed ep1);
  type T3 is bool;
  function f1(function () external   i0,uint176 i1,bool i2) public     returns(uint120 o0)  {
    return (uint120(1329227995784915872903807060280344575));
  }
  int248   s8;
  bool   s9;
  int200   s10;
  bool  public s11;
  constructor(int248 i0,bool i1,int200 i2,bool i3)   {
    s8 -= int248(-120504317159968283938143449810842017322074127276741232213645823619692524374);
    s9 = (uint208(0) <= uint208(411376139330301510538742295639337626245683966408394965837152255));
    s10 *= int200(-238960237127752401728179031367092640112545527992842093700631);
    s11 = false;
    {
    }
  }
  error er2();
}
function f2(uint24 i0)    pure suffix returns(bytes8 o0){
  if (i0 < (uint24(16154469) >> uint112(((false f3 /*suffix expr*/ & uint80(0)) >> uint64(uint64(0))))))
  {
    if (i0 >= uint24(15271845))
    {
      if (i0 == (~((uint24(16777215) % uint24((uint24((uint24(int24(8388607)) / uint24(12794719))) / uint24(16777215)))))))
      {
      }
      if (i0 <= (((uint24(12450163) ** uint224(uint224(((uint224(26959946667150639794667015087019630673637144422540572481103610249215) >> uint200(uint200(0))) / uint224(0))))) - uint24(0)) ^ uint24(0)))
      {
        return ((bytes8(0xffffffffffffffff) | bytes8(0x0000000000000000)));
      }
      else
      {
        require(false, string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")));
      }
    }
  }
}
import "su0.sol";
struct St3 {
  address el0;
  function (address payable[4][] memory, bool) external   returns (bytes5, int24, bool) el1;
}
pragma solidity >= 0.0.0;
function f3(bool i0) pure suffix  returns(uint80 o0)
{
}
// ====
// ----
