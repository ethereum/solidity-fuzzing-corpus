
==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
    bytes23 l0 = (~(bytes23(0xd83fcb434bde0dc853b171c387e50dfd3bbd106775f91f)));
    (bool l1) = payable(this).send(14811686060214456291);
  }
  function f1() external   payable
  {
    unchecked {
      payable(this).transfer(0);
      assembly
      {
        function af0(ai0) -> ao0, ao1, ao2, ao3, ao4
        {
          sstore(12610783515981932856253595788869295668432813488880087137659250494166088307970, ai0)
          let al0, al1, al2, al3, al4 := af0(115792089237316195423570985008687907853269984665640564039457584007913129639935)
        }
        switch 37178640769319004135090354234997180688223890627749782107652016097464913368938
        case 0
        {
        }
        case 84892644834387138004339523354437602199458486715500913983040650221588451715644
        {
          let al5 := 0
          al5 := 0
        }
      }
      function (address, function (int144, address, address payable) external   returns (address, address, int40)) internal   returns (uint168, bool, int160) l0;
    }
  }
  fallback() external virtual  
  {
  }
  bytes18   s0;
  uint224  public s1 = uint224(8107369542313090491341977628073785361764339010537882826354129463680);
  bool immutable  s2;
  constructor(bytes18 i0,bool i1)   {
    s0 = i0;
    s2 = ((bytes17((i0 |= bytes18(0x000000000000000000000000000000000000))) ^ bytes21(0x000000000000000000000000000000000000000000)) >= bytes21(0x000000000000000000000000000000000000000000));
    {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
