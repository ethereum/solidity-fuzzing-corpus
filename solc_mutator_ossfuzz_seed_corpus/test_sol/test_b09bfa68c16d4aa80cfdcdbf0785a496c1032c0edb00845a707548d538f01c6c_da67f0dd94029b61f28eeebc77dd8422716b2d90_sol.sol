==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  event ev0(uint168  ep0, bool indexed ep1) anonymous;
  fallback() external   
  {
    uint80 l0 = ((((((uint80(1208925819614629174706175) % uint80(0)) % uint80(10598495013239508018484)) ** uint208(uint208(43631472407068046226823763788879755638930619344057104976872922))) >> uint104(uint104(0))) ** uint208(uint208(103280541522087229220930163878928793068769886929589561957905372))) + uint80(0));
  }
  modifier m0(bool i0) virtual
  {
    _;
    (bool l0, bytes memory l1) = payable(this).call{value: 5387094502174562155}("");
  }
  error er0();
  modifier m1() virtual
  {
    _;
  }
  modifier m2(int96 i0,address payable[2] memory i1) 
  {
    _;
  }
  receive() external  m0((((((uint256(101799479485941785489176465848702415678460250011396886065760954022418890627387) * uint256(47779036319102627437472313638883512422805540119026570662475346527318720027078)) ** uint32(uint32(100090312))) + uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ** uint168(uint168(0))) > uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) payable
  {
  }
  error er1(uint128 ep0, bytes10 ep1);
  bool   s0 = true;
  bytes20   s1 = bytes20(address(0x0000000000000000000000000000000000000000));
  address   s2 = address(this);
  type T0 is uint128;
  struct St0 {
    bytes6 el0;
    mapping(bytes14 => bytes7) el1;
    address el2;
  }
  modifier m3() 
  {
    _;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56
  }
  address public constant cons0 = 0xB36C1ecA95679f691d05F5c2964Bbf72B892834e;
}
pragma solidity >= 0.0.0;
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22
}
address payable constant cons1 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
type T1 is address payable;
struct St1 {
  bytes12 el0;
  address el1;
  uint120 el2;
  int32 el3;
}
error er2(bool ep0);

==== Source: su1.sol ====
import "su0.sol";
C0.T0 constant cons2 = C0.T0.wrap(uint128(221613195467240867536991124368198336818));
function f2(int120 i0,function (address payable) external   i1)     returns(bytes memory o0)
{
  if (false)
  {
    (o0) = ("b3c428eb4f8e3b9dbc3e7aa716e5000000000000000000000000000000000000");
  }
}
pragma solidity >= 0.0.0;
type T2 is address payable;
// ----
// Warning 3149: (su0.sol:118-285): The result type of the exponentiation operation is equal to the type of the first operand (uint80) ignoring the (larger) type of the second operand (uint208) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:116-395): The result type of the exponentiation operation is equal to the type of the first operand (uint80) ignoring the (larger) type of the second operand (uint208) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 2072: (su0.sol:102-111): Unused local variable.
// Warning 5667: (su1.sol:115-124): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:125-165): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:103-301): Function state mutability can be restricted to pure
