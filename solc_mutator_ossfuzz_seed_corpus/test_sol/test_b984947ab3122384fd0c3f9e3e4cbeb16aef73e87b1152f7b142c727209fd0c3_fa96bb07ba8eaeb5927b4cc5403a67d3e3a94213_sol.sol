
==== Source: su0.sol ====
contract C0 {
  modifier m0() 
  {
    assert(true);
    (bool l0, bytes memory l1) = address(this).call((false ? bytes("000000000000000000000000000000000000000000000000000000000000000000000000") : bytes("5783891dc33ec26d5d")));
    int8 l2 = (-(int8(0)));
    _;
  }
  bool  public s0;
  constructor(bool i0)   {
    s0 = (payable(address(this)) != payable(address(this)));
    unchecked {
      bool  l0 = s0;
      bool  l1 = l0;
      assert(l1 == s0);
    }
  }
}
pragma solidity >= 0.0.0;
library L0 {
  function f0(function () external   i0,bytes31 i1) external   
  {
    bytes3[10][][6] memory l0 = [new bytes3[10][](4), new bytes3[10][](4), new bytes3[10][](4), new bytes3[10][](4), new bytes3[10][](4), new bytes3[10][](4)];
    address l1 = address(0x0000000000000000000000000000000000000004);
  }
  function f1(int16 i0) external    returns(bool o0,function () external   returns (bytes4, address payable) o1)
  {
    address payable l0 = (false ? (false ? payable(address(0x0000000000000000000000000000000000000004)) : payable(address(0x0000000000000000000000000000000000000004))) : payable(address(0x0000000000000000000000000000000000000004)));
    function () internal   returns (address payable) l1;
  }
}
contract C1 {
  C0  public s1;
  C0   s2;
  int40   s3 = int40(0);
  int184  public s4 = int184(12259964326927110866866776217202473468949912977468817407);
  constructor(C0 i0,C0 i1) payable  {
    s1 = C0(address(i0));
    s2 = C0(address(this));
    unchecked {
      C0  l0 = s2;
      C0  l1 = l0;
      assert(l1 == s2);
      {
        C0  l2 = s1;
        C0  l3 = l2;
        assert(l3 == s1);
      }
      {
        C0  l4 = s2;
        C0  l5 = l4;
        assert(l5 == s2);
        s3 %= (false ? (-(int40(0))) : ((int40(-83615761271) + int40(-235258152855)) ^ int40(-424863252776)));
      }
    }
  }
  using L0 for *;
  using L0 for *;
  using L0 for *;
  using L0 for *;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
