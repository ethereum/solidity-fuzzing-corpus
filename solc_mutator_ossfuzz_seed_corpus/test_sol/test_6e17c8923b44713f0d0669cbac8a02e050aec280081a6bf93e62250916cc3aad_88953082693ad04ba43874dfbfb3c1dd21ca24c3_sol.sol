
==== Source: su0.sol ====
contract C0 {
  bool   s0;
  constructor(bool i0)   {
    s0 = ((bytes1(0xff) == bytes21(0x000000000000000000000000000000000000000000)) ? true : false);
    {
    }
  }
  fallback() external   
  {
    assembly
    {
      switch s0.slot
      case 61365199608997176039478264778418068478298276742920774486640870024708829311478
      {
        pop(38578374054716183417339930117327644132504424021263584446320020140623130610305)
      }
      case 0
      {
        {
        }
      }
      switch s0.slot
      case 94661549973359865242081909694107409807544548882429954563919187524197781794233
      {
        let al0 := extcodehash(0)
      }
      case 34179323209586646514485715521000502755390860854806585805520861074207211800061
      {
        for 
        {
        }
        call(mload(add(0x80, mod(0, 2048))), 41436203561086694863118027181065392898868262859107312611241209468750834633290, 97854360119377540269760659618607757916040201215789313172968763442467774938821, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 56490964873765165713859251303075935271735455947460627474515844711476226943419, 58236457986343197364980950739727635116662791807222205773446548822655924418, 73884709948650721886008630305096005818790559039022812786571473092492342832287)
        {
        }
        {
          break
        }
        {
          extcodecopy(s0.slot, add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)), s0.offset, mod(0, 1024))
          if mload(add(0x80, mod(115792089237316195423570985008687907853269984665640564039457584007913129639935, 1024)))
          {
            function af0() -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8, ao9, ao10, ao11, ao12
            {
            }
            sstore(0, 44175290493843673857370900474501901279098817510911353440212933457827268358213)
            returndatacopy(add(0x80, mod(s0.offset, 1024)), 65889512230145584449837738748781989094669625619348704812353964637878710780581, mod(calldataload(mod(0, calldatasize())), 1024))
          }
        }
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        sstore(sub(0, 28269393046508079463098807736840357672876763197141260049352587326038633461872), 115792089237316195423570985008687907853269984665640564039457584007913129639935)
        stop()
      }
    }
    bool  l0 = s0;
    bool  l1 = l0;
    assert(l1 == s0);
    bool  l2 = s0;
    bool  l3 = l2;
    assert(l3 == s0);
    bool  l4 = s0;
    bool  l5 = l4;
    assert(l5 == s0);
    bool  l6 = s0;
    bool  l7 = l6;
    assert(l7 == s0);
  }
}
struct St0 {
  function (address payable, function () external   returns (bool, address payable), bytes17) external   returns (int48, address) el0;
  function () external   returns (bytes memory) el1;
  int136 el2;
  bool[] el3;
}
pragma solidity >= 0.0.0;
library L0 {
  function f1(string memory i0) external   
  {
  }
  type T0 is address;
  error er0();
}
using L0 for string;
library L1 {
  error er1();
}
// ====
// ----
