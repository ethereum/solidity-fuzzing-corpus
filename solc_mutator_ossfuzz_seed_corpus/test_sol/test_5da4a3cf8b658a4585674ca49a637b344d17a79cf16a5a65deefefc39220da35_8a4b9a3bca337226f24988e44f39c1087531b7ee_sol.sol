
==== Source: su0.sol ====
function f0(int64 i0,int256 i1)    
{
  do
  {
  }
  while (true);
  assembly
  {
  }
  function (bytes6, bytes7[][][9][3][3][] memory, bool) external   returns (bytes30) l0;
  try l0(((((uint72(0) + (uint72(0) >> uint176(uint176(95780971304118053647396689196894323976171195136475135)))) & uint72(4722366482869645213695)) < uint72(4278771493811438025101)) ? bytes6(0xffffffffffff) : bytes6(0x4e179b17675c)),new bytes7[][][9][3][3][](4),true) returns (bytes30 l1)
  {
    uint224[] memory l2 = new uint224[](5);
  }
  catch
  {
    bool l3 = ((bytes2(0x0000) | ((bytes2(0xffff) | bytes2(0xffff)) ^ bytes2(0x0000))) <= bytes2(0x0000));
    bytes14 l4 = bytes14(0x270d34181e7fb4a842aa8327465b);
  }
  catch Error(string memory l5)
  {
    int240[] memory l6 = new int240[](1);
  }
  catch Panic(uint256 l7)
  {
  }
}
contract C0 {
  struct St0 {
    int208 el0;
    bool el1;
  }
  bool   s0;
  constructor(bool i0)   {
    s0 = false;
    unchecked {
      f0((int32(-1858977696) * int32(1151621237)),((false ? int256(int184(9318603398228559121467022646698785925037895704708127023)) : (int256(-33069935152734852565046621636133856659923468875948549937985608798810836366202) - int256(-3478358519340901094433582987912680020553535509575505948733168409823495718441))) | int256(0)));
    }
  }
}
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



// ====
// ----
