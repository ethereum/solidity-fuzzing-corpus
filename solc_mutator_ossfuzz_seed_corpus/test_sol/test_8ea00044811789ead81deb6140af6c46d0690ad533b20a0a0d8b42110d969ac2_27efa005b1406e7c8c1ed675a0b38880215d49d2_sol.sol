==== Source:  ====

==== Source: su0.sol ====
library L0 {
  error er0();
  uint160 public constant cons0 = uint160(0);
  modifier m0(int168 i0) 
  {
    _;
    (i0) = (int168(0));
  }
  function f0(bytes3 i0) private  m0((int168(0) ** uint120(((((uint120(0) << uint136(uint136(51421940935981872580109260505416906349004))) << uint128(uint128(228120011045478887805063328639766743381))) * uint120(0)) ^ uint120(0)))))  returns(address payable o0,bytes19 o1)
  {
    assert(false);
    assembly
    {
      stop()
      for 
      {
      }
      o1
      {
        function af0(ai0, ai1) -> ao0, ao1, ao2
        {
        }
      }
      {
        continue
      }
      {
        if calldataload(mod(0, calldatasize()))
        {
          let al0 := delegatecall(cons0, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 57574556951053449134929188489433487555276125870743197516272581019798926270547, 0, 8320899324831196145334764903501970755214974022484265815295620283270205388611, 63218317207653754244642915348613235098631488667089079734546041574619669143243)
        }
        if 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
        }
      }
      switch o0
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        let al1 := 0
        let al2 := 43523708746691100630871188302933949427843329935319480923267812253179095425061
        let al3 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      }
      case 57575468387716892983093943343369939968440368404299243694639584624486024883517
      {
        for 
        {
        }
        115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
          function af1(ai2, ai3, ai4, ai5) -> ao3, ao4, ao5
          {
          }
          i0 := 84766236096376851810802780263634443946437739097001031110566669861704408401576
        }
        {
          return(mload(mod(o0, 2048)), mod(mload(mod(0, 2048)), 46931749212679576487574705855832802060751808842749948151114291329515789607614))
        }
        i0 := 83714034455262403387218529656349099598668341547620821591107517097037569547943
      }
    }
  }
  event ev0(function () external    ep0, address payable  ep1, bytes20  ep2);
  error er1(bytes ep0);
  using L0 for *;
  function f1(uint176 i0,int120 i1,int112 i2) private  m0(int168(0))  returns(uint64 o0)
  {
  }
  type T0 is bool;
}
function f2(bytes17 i0,L0.T0 i1)    
{
  for(;
true;
bytes7(0xe385a895a48c9f))
  {
    if (false)
    {
      break;
    }
    else
    {
      revert L0.er0();
    }
  }
  0;
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94, M95,
  M96, M97, M98, M99, M100, M101, M102, M103,
  M104, M105, M106, M107, M108, M109, M110, M111,
  M112, M113, M114, M115, M116, M117, M118, M119,
  M120, M121, M122, M123, M124, M125, M126, M127,
  M128, M129, M130, M131, M132, M133, M134, M135,
  M136, M137, M138, M139, M140, M141, M142, M143,
  M144, M145, M146, M147, M148, M149, M150, M151,
  M152, M153, M154, M155, M156, M157, M158, M159,
  M160, M161, M162, M163, M164, M165, M166, M167,
  M168, M169, M170, M171, M172, M173, M174, M175,
  M176, M177, M178, M179, M180, M181, M182, M183,
  M184, M185
}
pragma solidity >= 0.0.0;
using L0 for uint;
type T1 is uint176;
// ----
// Warning 3149: (su0.sol:202-275): The result type of the shift operation is equal to the type of the first operand (uint120) ignoring the (larger) type of the second operand (uint136) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:201-337): The result type of the shift operation is equal to the type of the first operand (uint120) ignoring the (larger) type of the second operand (uint128) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// TypeError 7615: (su0.sol:718-723): Only direct number constants and references to such constants are supported by inline assembly.
