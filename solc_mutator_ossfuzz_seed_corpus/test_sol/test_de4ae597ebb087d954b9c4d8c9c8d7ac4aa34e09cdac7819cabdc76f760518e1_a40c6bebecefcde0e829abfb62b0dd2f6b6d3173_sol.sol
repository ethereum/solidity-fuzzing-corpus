
==== Source: su0.sol ====
contract C0 {
  bool  public s0 = true;
  int120   s1 = int120(664613997892457936451903530140172287);
  bytes2   s2;
  uint152   s3 = uint152(5708990770823839524233143877797980545530986495);
  constructor(bytes2 i0)   {
    s2 = ((((uint192(510151629952518697585250081720456014849499213814158199436) + (uint192(6277101735386680763835789423207666416102355444464034512895) ^ uint192(3979451538019421438376177073665847903821362830478162719492))) + uint192(0)) < uint192(6277101735386680763835789423207666416102355444464034512895)) ? bytes2(0xffff) : bytes2(0xffff));
    {
    }
  }
  struct St0 {
    bytes el0;
  }
  int152 public constant cons0 = 2854495385411919762116571938898990272765493247;
  event ev0(bool  ep0, function (int96) external   returns (bytes31, function () external  )  ep1, int16  ep2);
  function f0(int120 i0,bytes2 i1) public virtual  payable  returns(uint208 o0)  {
    return (uint208(0));
  }
}
struct St1 {
  int144 el0;
  mapping(bool => bool) el1;
  C0.St0 el2;
}
pragma solidity >= 0.0.0;
type T0 is bytes30;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,

eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }





function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }




==== Source: su1.sol ====
contract C1 {
  mapping(uint8 => uint216)   s4;
  constructor()   {
    s4[uint8(130)] >>= uint216(89166673403871006099519644181997454573792301293654240911910975101);
    unchecked {
    }
  }
  fallback() external virtual  
  {
    for(;
;
true)
    {
    }
  }
  receive() external   payable
  {
    (bool l0) = payable(this).send(5286818734120154978);
  }
  struct St2 {
    int80 el0;
  }
}
function f3()     {
  if (true)
  {
    if (true)
    {
      if (false)
      {
      }
      else
      {
        if (false)
        {
        }
        else
        {
          if ((bytes12(0xffffffffffffffffffffffff) < bytes12(0x000000000000000000000000)))
          {
          }
          else if ((((uint80(0) - (uint40(0) % uint80(1208925819614629174706175))) > uint80(0)) ? true : false))
          {
            if (true)
            {
            }
            else if (true)
            {
            }
          }
        }
      }
    }
  }
  else if (((uint64(18446744073709551615) - uint256(108791245150332290307104148398700707108245649319793524257538339003688237173867)) >= (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))))
  {
  }
}
contract C2 {
  error er0();
  error er1(bool ep0);
  uint24   s5 = uint24(0);
  C1.St2   s6 = C1.St2(int80(-100174155303603276442677));

	function compareMemoryAndStorage(C1.St2 memory v1, C1.St2 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  int16   s7 = int16(4516);
  function f4() public virtual    returns(bool o0,C1.St2 memory o1)  {
    return (false, C1.St2(int80(-106700860156179116319580)));
  }
  struct St3 {
    uint160 el0;
    bool el1;
    string el2;
    address payable el3;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
