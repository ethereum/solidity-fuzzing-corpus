==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
    function (bool, uint80, bool[4][10] memory) external   returns (bool, address, address payable) l0;
    try l0(true,uint80(uint64(18446744073709551615)),[[false, true, true, true], [false, true, true, false], [true, false, false, false], [true, true, true, true], [true, true, false, false], [false, true, true, true], [true, true, false, true], [false, true, false, false], [false, true, true, true], [false, false, false, false]]) returns (bool l1, address l2, address payable l3)
    {
      payable(this).transfer(0);
    }
    catch
    {
      int184 l4 = int184(12259964326927110866866776217202473468949912977468817407);
      payable(this).transfer(0);
    }
    catch Error(string memory l5)
    {
      for(uint solinit0 = 0; solinit0 < ((uint256(0) ^ uint256(0)) % 11); solinit0++)
      {
      }
    }
    catch Panic(uint256 l6)
    {
      bytes31 l7 = bytes31(0x00000000000000000000000000000000000000000000000000000000000000);
      assert(false);
    }
  }
  int40   s0 = int40(549755813887);
  int136  public s1;
  address   s2 = address(this);
  constructor(int136 i0) payable  {
    s1 = (~(int136((int136(38292518592802863722201010737268747794423) / int136(43556142965880123323311949751266331066367)))));
    unchecked {
      address  l0 = s2;
      address  l1 = l0;
      assert(l1 == s2);
    }
  }
  function f1(address i0,int136 i1) public virtual  payable
  {
    int136  l0 = s1;
    int136  l1 = l0;
    assert(l1 == s1);
    int136  l2 = s1;
    int136  l3 = l2;
    assert(l3 == s1);
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  int256 el0;
  uint200 el1;
  mapping(int152 => int160) el2;
  address el3;
}

==== Source: su1.sol ====
function f2(address i0,bool i1)    
{
  int208 l0 = int208(((((int208(-78972472424589905081933981834237499674528701305931839893073570) ** uint184(uint184(24519928653854221733733552434404946937899825954937634815))) ** uint64(uint64(18446744073709551615))) | int208(0)) / int208(205688069665150755269371147819668813122841983204197482918576127)));
}
pragma solidity >= 0.0.0;
// ----
// Warning 5667: (su0.sol:502-509): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:511-521): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:523-541): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:610-619): Unused local variable.
// Warning 5667: (su0.sol:743-759): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:891-901): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:915-925): Unused local variable.
// Warning 5667: (su0.sol:1137-1146): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1398-1408): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1409-1418): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:12-22): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:23-30): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:40-49): Unused local variable.
// Warning 2018: (su1.sol:0-346): Function state mutability can be restricted to pure
