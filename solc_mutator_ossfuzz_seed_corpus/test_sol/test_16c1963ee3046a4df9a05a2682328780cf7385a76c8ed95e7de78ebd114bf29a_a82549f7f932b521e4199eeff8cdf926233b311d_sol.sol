
==== Source: su0.sol ====
contract C0 {
  modifier m0(function (bool) internal   i0) 
  {
    unchecked {
    }
    _;
  }
  event ev0(string indexed ep0, int56  ep1);
  fallback() external virtual  
  {
  }
  uint24 public constant cons0 = (uint24(16777215) >> uint200(((uint200(((uint200(1606938044258990275541962092341162602522202993782792835301375) ** uint224(uint224(8626990882039956617758233698089372421126909208256566324352693116317))) / uint200(0))) ^ uint200(1606938044258990275541962092341162602522202993782792835301375)) >> uint64(uint64(0)))));
  mapping(bool => address)   s0;
  bytes9   s1 = bytes9(0xffffffffffffffffff);
  constructor()   {
    s0[(true || false)] = address(this);
    { }
  }
  enum EN0 {
    M0, M1, M2
  }
  function f1(string calldata i0) external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call("046f33a3f16b2411165b0fc41ccd5816cd54726235ba44e691516aa9f0de0f3f3e1993c4d7e80e236156611b6d824fdb9576");
  }
  function f2() public virtual  
  {
    {
      if (true)
      {
      }
      else
      {
        address(this);
      }
    }
  }
}
type T0 is bytes11;
enum EN1 {
  M0, M1, M2, M3, M4
}
C0.EN0 constant cons1 = C0.EN0.M1;
library L0 {
  function f3() external   
  {
  }
  using L0 for *;
  type T1 is bytes15;
  event ev1(int248  ep0, T0  ep1, bytes3  ep2);
  modifier m1(bool i0,uint192 i1) 
  {
    int160 l0 = int160(0);
    _;
  }
  event ev2() anonymous;
  error er0(address ep0, bool ep1);
}
contract C1 is C0 {
  function f4(address i0,C0 i1) external   payable returns(address payable o0)
  {
    (s1) = (bytes9(0xbb2b8365d2c121ba50));
    emit ev0(string("cd02156b1eee9ea2847d6080b0bc7b17d457c10000000000000000000000000000000000000000000000000000000000"), int56(36028797018963967));
  }
  type T2 is bytes25;
  using L0 for *;
  function f5() public   payable returns(function (C0.EN0) external   returns (C0.EN0) o0,bytes19 o1)
  {
    return (o0, bytes19(0xffffffffffffffffffffffffffffffffffffff));
    revert L0.er0(address(this), (EN1.M0 >= EN1.M1));
  }
  T0 public constant cons2 = T0.wrap(bytes11(0x0000000000000000000000));
  address   s2;
  uint224  public s3;
  bytes7   s4 = bytes7(0x3d2e0a9e7cbf6e);
  constructor(address i0,uint224 i1)   {
    s2 = address(this);
    s3 %= (uint224(0) >> uint248((uint248((uint248(((uint248(68985629628545690206669826743080711059802796549552618802867436891990599935) ** uint8(uint8(0))) / uint248(43302762232438062673787725898961640372856894743182876092081640231220344314))) / uint248(310937596102644972159697139230074381083095955894191834251265923579767394741))) % uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))));
    s0[(!(true))] = address(this);
    unchecked {
    }
  }
  event ev3(C1.T2  ep0, bytes29[2]  ep1, bool  ep2, int232  ep3);
  error er1();
  function f1(string calldata i0) external override  
  {
  }
  function f2() public override  
  {
    {
      function () external   l0;
      unchecked {
        return;
        return;
        assembly
        {
          function af0()
          {
          }
          let al0 := s2.offset
        }
      }
    }
    (bool l1, bytes memory l2) = address(this).call("ffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000");
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
