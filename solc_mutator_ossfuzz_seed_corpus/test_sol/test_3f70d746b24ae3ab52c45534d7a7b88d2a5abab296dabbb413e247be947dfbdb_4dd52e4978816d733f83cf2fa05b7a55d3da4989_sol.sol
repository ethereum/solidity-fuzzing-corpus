==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
bool constant cons0 = false;
contract C0 {
  receive() external   payable
  {
    bytes memory l0 = bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  }
  fallback() external   payable
  {
    address payable l0 = payable(address(this));
  }
  function f2(address i0) public virtual  payable
  {
    for(uint solinit0 = 0; solinit0 < (address(this).balance % 11); solinit0++)
    {
      string memory l0 = string("000000000000000000000000000000ffffffffffffffffffffff");
      address l1 = address(this);
      (i0) = (address(this));
      assert(i0 == address(this));
      function (bool) internal   returns (int48) l2;
    }
    unchecked {
      bool l3 = true;
      (bool l4) = payable(this).send(9448815650313432526);
    }
  }
  int56[9]   s0 = [int56(28854078063729847), int56(0), int56(5108276697460273), int56(0), int56(-28234994318326799), int56(0), int56(0), int56(0), int56(0)];

	function compareMemoryAndStorage(int56[9] memory v1, int56[9] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bytes25   s1 = bytes25(0x00000000000000000000000000000000000000000000000000);
  bytes16   s2;
  address payable   s3;
  constructor(bytes16 i0,address payable i1)   {
    s2 = bytes16(0x00000000000000000000000000000000);
    s3 = (false ? payable(address(this)) : (false ? payable(address(this)) : payable(address(this))));
    {
      int56[9] memory l0 = s0;
      int56[9] memory l1 = l0;
      assert(compareMemoryAndStorage(l1, s0));
      delete s1;
      bytes25  l2 = s1;
      bytes25  l3 = l2;
      assert(l3 == s1);
      (l0[(uint256(60515082239881401403540328225148904009675594077495707524365932843019720729476) & uint256(0))], s0) = (((int48(0) * ((int56(0) | int56(0)) % int56(10683926696642382))) + int56(36028797018963967)), [int56(-26273212974975262), int56(28606901704646787), int56(2325643997066845), int56(36028797018963967), int56(-5840087693133200), int56(36028797018963967), int56(0), int56(-19925977897968316), int56(36028797018963967)]);
      assert(l0[(uint256(60515082239881401403540328225148904009675594077495707524365932843019720729476) & uint256(0))] == ((int48(0) * ((int56(0) | int56(0)) % int56(10683926696642382))) + int56(36028797018963967)));
    }
  }
}
pragma solidity >= 0.0.0;
// ----
// Warning 2072: (su1.sol:82-97): Unused local variable.
// Warning 2072: (su1.sol:257-275): Unused local variable.
// Warning 2072: (su1.sol:452-468): Unused local variable.
// Warning 2072: (su1.sol:541-551): Unused local variable.
// Warning 2072: (su1.sol:640-685): Unused local variable.
// Warning 2072: (su1.sol:715-722): Unused local variable.
// Warning 2072: (su1.sol:738-745): Unused local variable.
// Warning 5667: (su1.sol:1341-1351): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1352-1370): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:960-1206): Function state mutability can be restricted to view
