
==== Source: su0.sol ====
int104 constant cons0 = int104(8763023084259744671715605495118);
contract C0 {
  struct St0 {
    bool el0;
    address payable[] el1;
    uint120[] el2;
  }
  modifier m0(function (uint224, int152) internal   returns (bool) i0) 
  {
    _;
  }
  function f0(bytes28 i0) public    returns(uint200[] memory o0)
  {
  }
  modifier m1() virtual
  {
    bool l0 = true;
    _;
    _;
  }
  event ev0(C0.St0 indexed ep0, bool  ep1) anonymous;
  event ev1(function (bytes17[] memory) external   returns (function (bool) external   returns (string memory), address, bytes25)  ep0);
  type T0 is int192;
  mapping(bool => int88)  public s0;
  address payable immutable  s1;
  bool  public s2;
  C0.St0   s3;
  constructor(address payable i0,bool i1) payable  {
    s1 = payable(address(this));
    s2 = (true && true);
    s0[(!(true))] -= ((int88(0) + int88(154742504910672534362390527)) & (int88(-54953227461376887774079072) & int88(-88375390114756345762621298)));
    unchecked {
      assert((i1 = false));
      if (s3.el0)
      {
      }
      else
      {
      }
      emit ev0(C0.St0(false, new address payable[](2), new uint120[](1)), (!((bytes8(0x83c9918cb4ba2f00) == bytes8(0xffffffffffffffff)))));
    }
  }
}
pragma solidity >= 0.0.0;
type T1 is bytes2;
struct St1 {
  function (int64) external   returns (function (function (address payable) external   returns (address payable), address payable) external   returns (bytes memory), bytes27) el0;
  uint256 el1;
  mapping(bool => C0.St0) el2;
}
error er0();
// ====
// ----
