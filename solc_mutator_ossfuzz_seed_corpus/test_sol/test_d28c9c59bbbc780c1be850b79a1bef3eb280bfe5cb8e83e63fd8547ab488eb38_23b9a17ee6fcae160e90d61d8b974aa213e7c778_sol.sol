==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0(function (bool) external   returns (bool) i0,uint80 i1) external    returns(int232[2][][][10][] memory o0,uint128 o1)
  {
    o1 &= uint128(56876906747594068042482358437842292337);
    return ((true ? new int232[2][][][10][](10) : new int232[2][][][10][](10)), uint128(340282366920938463463374607431768211455));
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   payable
  {
    unchecked {
      uint112 l0 = ((uint112(2399189118262646980243016732450374) | (uint112(5192296858534827628530496329220095) + uint112(int112(2596148429267413814265248164610047)))) ** uint24(uint24(3458910)));
      uint208 l1 = uint208(0);
      bool l2 = true;
      (bool l3, bytes memory l4) = payable(this).call{value: 0}("");
    }
    revert(string("00000000000000000000d2ccaf1d8ff24b720dc28a48"));
  }
  using L0 for *;
  bool   s0 = false;
  uint152  public s1 = uint152(5708990770823839524233143877797980545530986495);
  using L0 for *;
}

==== Source: su1.sol ====
contract C1 {
  uint160   s2;
  constructor(uint160 i0)   {
    s2 += ((uint160(0) << uint24(((uint24(16777215) << uint216(uint216(33198006303863281652584744159843134309215456624121370370764983269))) ^ uint24(0)))) + uint160(0));
    unchecked {
      uint160  l0 = s2;
      uint160  l1 = l0;
      assert(l1 == s2);
      (bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff) | bytes27(0x000000000000000000000000000000000000000000000000000000));
      uint160  l2 = s2;
      uint160  l3 = l2;
      assert(l3 == s2);
      uint160  l4 = s2;
      uint160  l5 = l4;
      assert(l5 == s2);
      uint160  l6 = s2;
      uint160  l7 = l6;
      assert(l7 == s2);
    }
  }
  fallback() external   
  {
    uint160  l0 = s2;
    uint160  l1 = l0;
    assert(l1 == s2);
  }
}
pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
  mapping(address => int128[5][][9]) el1;
  int184 el2;
  function (uint216) external   returns (string memory) el3;
}
// ----
// Warning 3628: (su0.sol:371-972): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 3149: (su1.sol:95-198): The result type of the shift operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint216) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:27-71): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:72-81): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:443-453): Unused local variable.
// Warning 2072: (su0.sol:640-650): Unused local variable.
// Warning 2072: (su0.sol:671-678): Unused local variable.
// Warning 2072: (su0.sol:694-701): Unused local variable.
// Warning 2072: (su0.sol:703-718): Unused local variable.
// Warning 6133: (su1.sol:324-459): Statement has no effect.
// Warning 5667: (su1.sol:44-54): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:15-342): Function state mutability can be restricted to pure
