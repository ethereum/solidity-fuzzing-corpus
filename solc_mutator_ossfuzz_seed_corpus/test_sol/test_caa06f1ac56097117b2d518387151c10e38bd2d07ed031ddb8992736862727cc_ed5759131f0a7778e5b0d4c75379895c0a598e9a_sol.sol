
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  error er0(bytes22 ep0);
  modifier m0() 
  {
    bytes26 l0 = bytes26(bytes22(0xe0543489ac928813e02c5b4b5cda97603a558240cb36));
    _;
  }
}

==== Source: su1.sol ====
contract C0 {
  address payable immutable  s0 = payable(address(this));
  mapping(bytes18 => address)   s1;
  constructor()   {
    s1[((~((~((true ? bytes18(0x09e47da2c968037b354d16e4e5500bc5c59b) : bytes18(0x000000000000000000000000000000000000)))))) ^ bytes18(0xa4d4398df58dc130754b42ec7f9f18f408b2))] = ((true ? ((true ? bytes8(0x4f027c0bbea9a2a6) : bytes8(0x0000000000000000)) >= bytes25(0xa86439285c5a02b5a06d713981aed4cb07607c080361ee5050)) : true) ? address(this) : address(this));
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffff00000000000000000000000000000000000000000000"));
      (bool l2, bytes memory l3) = address(this).call(bytes("b873bbe614c07940f54d61d662ffffffffff"));
    }
  }
  function f0() private    returns(int224 o0,address payable o1)
  {
    while (false)
    {
      bytes storage l0;
    }
    address payable  l1 = s0;
    address payable  l2 = l1;
    assert(l2 == s0);
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
