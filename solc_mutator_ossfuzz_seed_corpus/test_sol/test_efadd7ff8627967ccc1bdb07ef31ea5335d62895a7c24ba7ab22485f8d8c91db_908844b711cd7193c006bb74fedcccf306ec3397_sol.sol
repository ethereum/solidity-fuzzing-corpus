
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  address   s0 = address(this);
  bool   s1;
  int256   s2 = int256(55724457558705288472737636751098928625058107536154047823421852996792183946444);
  constructor(bool i0) payable  {
    s1 = true;
    unchecked {
    }
  }
  struct St0 {
    bytes el0;
    int120 el1;
    uint208 el2;
    uint200 el3;
  }
  struct St1 {
    uint16 el0;
    bytes26 el1;
    address el2;
  }
  function f0(address i0,bool i1) public     returns(bytes6 o0)  {
    o0 &= (bytes6(0x000000000000) | (~((bytes6(0xffffffffffff) | bytes6(0x67d52975de76)))));
    (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffff5bf5cf1384909ea170efdbbdbb67904004bb758a15ed"));
  }
  function f1() public virtual     {
    0;
    if (false)
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000"));
    }
    else if (false)
    {
      if ((bytes25(0x91e99d4dc077a4f10b9195b700a6ae6c0146c6fa51a9a62174) >= bytes25(0xc9005f766ec702494ca7a77ccaf65fabf4b531bebd962c042d)))
      {
        return;
      }
    }
    return;
  }
}
contract C1 {
  function f2() public   payable  returns(uint112[] memory o0,int216 o1,address payable o2)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("bfbd001fe2d9db5736aba18b6b0e9a04f466b427d273c330545f04e464876c54c2a6d60621"));
    return (new uint112[](10), (int216(-47095475585884562450571527778107548144677689966706953512685688070) | int216(-17728527540354307738346193634236619095344638783879893086534161341)), payable(address(this)));
  }
  int208 public constant cons0 = 205688069665150755269371147819668813122841983204197482918576127;
  bytes17   s3 = bytes17(0x3df797ee65e0986c2dd20e2fdcaf9f881c);
  int96  public s4;
  C0.St1  public s5 = C0.St1(uint16(65535), bytes26(0x0000000000000000000000000000000000000000000000000000), address(0x0000000000000000000000000000000000000004));

	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

	return true;
	}  constructor(int96 i0)   {
    s4 &= int96(39614081257132168796771975167);
    unchecked {
    }
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St2 {
  address el0;
}
// ====
// ----
