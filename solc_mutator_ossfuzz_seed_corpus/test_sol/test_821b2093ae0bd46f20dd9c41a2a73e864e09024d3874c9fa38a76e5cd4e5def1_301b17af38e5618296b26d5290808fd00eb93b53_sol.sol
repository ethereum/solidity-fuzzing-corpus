
==== Source: su0.sol ====
contract C0 {
  receive() external virtual  payable
  {
    int224 l0 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
    int256 l1 = ((int256(0) * (int256(0) ^ (int256(0) ^ int256(0)))) | int256(57896044618658097711785492504343953926634992332820282019728792003956564819967));
  }
  int104   s0 = int104(0);
  uint88[][][][][9][]   s1;

	function compareMemoryAndStorage(uint88[][][][][9][] memory v1, uint88[][][][][9][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[][][][][9] memory v1, uint88[][][][][9] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[][][][] memory v1, uint88[][][][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[][][] memory v1, uint88[][][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[][] memory v1, uint88[][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(uint88[] memory v1, uint88[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  address   s2 = address(this);
  constructor(uint88[][][][][9][] memory i0)   {
    s1 = i0;
    unchecked {
      (i0[((uint256(78951706944937868091701040352784945424315706560944928786030085921850919907415) + (((false ? uint256(0) : uint256(0)) ^ uint256(0)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))]) = ((true ? [new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9)] : [new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9), new uint88[][][][](9)]));
      uint88[][][][][9][] memory l0 = s1;
      uint88[][][][][9][] memory l1 = l0;
      assert(compareMemoryAndStorage(l1, s1));
      s1.pop();
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  receive() external   payable
  {
    function () internal   returns (uint216[][10] memory, bool[][2][1] memory) l0;
    address[9][] memory l1 = new address[9][](3);
  }
  struct St0 {
    uint168 el0;
    uint96[][][][][][4] el1;
    bool[5] el2;
  }
  address payable   s3 = payable(address(this));
  address  public s4 = address(this);
  bool  public s5 = true;
}
// ====
// ----
