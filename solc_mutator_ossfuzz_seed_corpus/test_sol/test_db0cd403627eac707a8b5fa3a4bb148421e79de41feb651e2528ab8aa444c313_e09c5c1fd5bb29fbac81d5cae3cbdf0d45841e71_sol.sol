
==== Source: su0.sol ====
contract C0 {
  bytes20   s0 = bytes20(address(0xebF34fb875A9dF68Fb108555A87305D42A55A01c));
  bool   s1 = false;
  uint128  public s2 = uint128(70721037072321580324398573587070749291);
  mapping(int88 => address)   s3;
  constructor() payable  {
    s3[((false ? ((-(int88(154742504910672534362390527))) & int88(0)) : int88(0)) % int88(151336220116040570902252158))] = address(this);
    {
      uint128  l0 = s2;
      uint128  l1 = l0;
      assert(l1 == s2);
      bool  l2 = s1;
      bool  l3 = l2;
      assert(l3 == s1);
      uint128  l4 = s2;
      uint128  l5 = l4;
      assert(l5 == s2);
      unchecked {
        bytes20  l6 = s0;
        bytes20  l7 = l6;
        assert(l7 == s0);
        assert(((uint24(12629344) & ((uint24(4055343) ** uint256(uint256(0))) ^ uint24(16777215))) != uint24(10130529)));
        bytes20  l8 = s0;
        bytes20  l9 = l8;
        assert(l9 == s0);
        if (true)
        {
          for(          (false ? false : false);
;
int40(int152(2854495385411919762116571938898990272765493247)))
          {
            (s0) = (bytes20(address(0x0000000000000000000000000000000000000000)));
            assert(s0 == bytes20(address(0x0000000000000000000000000000000000000000)));
          }
        }
        bytes20  l10 = s0;
        bytes20  l11 = l10;
        assert(l11 == s0);
        (bool l12, bytes memory l13) = address(this).call(bytes("ffffa95e7ffa18562a836102fe64d7b51857466ba913125dca32"));
      }
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
library L0 {
  error er0();
}
// ====
// ----
