
==== Source: su0.sol ====
contract C0 {
  int176   s0;
  uint104   s1;
  constructor(int176 i0,uint104 i1)   {
    s0 |= ((int176(47890485652059026823698344598447161988085597568237567) & (~(int176(0)))) ^ int176(47890485652059026823698344598447161988085597568237567));
    s1 -= ((uint104(0) - ((uint104(20282409603651670423947251286015) + uint104(20282409603651670423947251286015)) << uint40(uint40(1099511627775)))) >> uint248(uint248(0)));
    {
      int176  l0 = s0;
      int176  l1 = l0;
      assert(l1 == s0);
      for(uint solinit0 = 0; solinit0 < ((uint256(79911112607388350770814882675542761259063556016133634224962906441316525761846) - (uint256(0) ^ ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) & uint256(94988012806051823913311296863559169577493659835359579353675932937053671091280)) ^ uint256(85260854474701658800105904742807754584580883537650849304081570577991029584271)))) % 11); solinit0++)
      {
      }
      uint104  l2 = s1;
      uint104  l3 = l2;
      assert(l3 == s1);
    }
  }
}
pragma solidity >= 0.0.0;
library L0 {
  function f0() external    returns(address o0)
  {
    bool l0 = true;
  }
}
contract C1 is C0 {
  using L0 for *;
  using L0 for *;
  address immutable public s2;
  constructor(int176 i0,uint104 i1,address i2) payable C0(int176(((false ? int176(0) : ((int176(-41871988426477509634055105352798559314669949677213417) | int176(0)) % int176(0))) / int176(0))), (uint104(18345222133618662755427288414752) | (~(uint104(6716335796179981770215771875657)))))
  {
    s0 += int176(44717041276314847747072262143558171674358960005577129);
    s1 ^= uint104(0);
    s2 = address(this);
    unchecked {
      address  l0 = s2;
      address  l1 = l0;
      assert(l1 == s2);
    }
  }
  using L0 for *;
}
// ====
// ----
