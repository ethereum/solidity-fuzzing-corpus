==== Source:  ====

==== Source: su0.sol ====
type T0 is int88;
contract C0 {
  uint40  public s0 = uint40(1099511627775);
  error er0();
  function f0() external    returns(T0 o0)
  {
  }
  event ev0(bytes28  ep0, bytes[]  ep1);
  type T1 is bool;
  event ev1(bool[1]  ep0, address payable  ep1) anonymous;
  function f1(C0.T1 i0) external virtual   returns(bytes20 o0)
  {
    emit ev0(bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff), new bytes[](1));
  }
  function f2() public virtual  
  {
    emit ev0(bytes28(0x00000000000000000000000000000000000000000000000000000000), new bytes[](2));
    do
    {
    }
    while (false);
    emit ev0(bytes28(0x00000000000000000000000000000000000000000000000000000000), new bytes[](1));
  }
  receive() external   payable
  {
  }
  modifier m0(function () internal   returns (string memory, T0) i0) virtual
  {
    delete s0;
    _;
    while ((true ? (int128(0) > ((int128(0) * int128(-120607147825982849888747846198743677026)) | int128(30067437205873747161935567384212968613))) : true))
    {
      T0 l0 = T0.wrap(int88(154742504910672534362390527));
    }
    for(    address payable l1 = payable(address(this));
;
bytes22(0xffffffffffffffffffffffffffffffffffffffffffff))
    {
      try this.f1({i0: C0.T1.wrap(true)}) returns (bytes20 l2)
      {
        payable(this).transfer(9248395277406620903);
        s0 >>= (((uint40(1099511627775) & uint40(1099511627775)) >> uint128((uint128(340282366920938463463374607431768211455) << uint24(uint24(0))))) << uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)));
      }
      catch
      {
      }
      catch Error(string memory l3)
      {
        (bool l4) = payable(this).send(17678334640365020412);
        unchecked {
          while ((bytes13(0x00000000000000000000000000) < bytes13(0x00000000000000000000000000)))
          {
            break;
          }
          break;
          emit ev1([true], payable(address(bytes20(address(0x0000000000000000000000000000000000000000)))));
        }
      }
      catch Panic(uint256 l5)
      {
        for(;
;
)
        {
          continue;
        }
      }
      _;
      emit ev0(bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff), new bytes[](1));
      (s0) = (uint40(389102587775));
    }
    (s0) = (((((((uint40(609374384801) + uint40(0)) >> uint224(uint224(10473180534595376300274186248553905794057771672551436695636112673220))) * uint40(0)) >> uint88(uint88(0))) ** uint152(uint152(5708990770823839524233143877797980545530986495))) >> uint160(uint160(53672916421921662154788793552746802496755252096))));
    _;
  }
}
function f4(bytes27 i0)    
{
}
error er1(function (bool[] memory) external   returns (uint160, bool) ep0);
contract C1 {
  modifier m1() virtual
  {
    _;
  }
  event ev2(function (bytes26) external   returns (bytes memory, C0.T1, C0.T1) indexed ep0, address  ep1);
  struct St0 {
    bytes20 el0;
  }
  bool  public s1;
  uint64[1]   s2 = [uint64(0)];
  C0.T1   s3;
  constructor(bool i0,C0.T1 i1)   {
    s1 = ((bytes21(0x000000000000000000000000000000000000000000) >= bytes21(0xe6eb29e3f5d690a8291d8816cb6fd5201b5079f207)) || false);
    s3 = C0.T1.wrap(true);
    unchecked {
      if (true)
      {
      }
    }
  }
  modifier m2() virtual
  {
    if (false)
    {
      _;
    }
    else if ((true || (int136(43556142965880123323311949751266331066367) >= int136(43556142965880123323311949751266331066367))))
    {
    }
  }
  event ev3();
  error er2(bytes ep0);
}
pragma solidity >= 0.0.0;
struct St1 {
  C0.T1 el0;
  function (bytes20[2] memory) external   returns (T0) el1;
  bool el2;
}
// ----
// Warning 3149: (su0.sol:1340-1570): The result type of the shift operation is equal to the type of the first operand (uint40) ignoring the (larger) type of the second operand (uint248) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su0.sol:2290-2521): The result type of the exponentiation operation is equal to the type of the first operand (uint40) ignoring the (larger) type of the second operand (uint152) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5667: (su0.sol:276-284): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:313-323): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:1137-1192): Statement has no effect.
// Warning 5667: (su0.sol:2991-2998): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2999-3007): Unused function parameter. Remove or comment out the variable name to silence this warning.
