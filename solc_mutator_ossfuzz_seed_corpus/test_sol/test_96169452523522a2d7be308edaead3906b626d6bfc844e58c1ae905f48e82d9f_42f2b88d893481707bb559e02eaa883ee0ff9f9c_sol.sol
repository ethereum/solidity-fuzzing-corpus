
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  function (function (bytes memory, bool) external   returns (bool)) external   returns (string memory, address payable) el0;
  bool el1;
}

==== Source: su1.sol ====
contract C0 {
  event ev0();
  function f0() public virtual    returns(bytes memory o0)  {
  }
  event ev1(int184  ep0);
  bytes29   s0 = bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
}
contract C1 is C0 {
  mapping(address => address)[8][]   s1;
  fallback() external   
  {
    s1.pop();
    return;
  }
  event ev2();
  function f0() public virtual override   returns(bytes memory o0)
  {
    while (false)
    {
      break;
    }
    while (true)
    {
      emit ev0();
      continue;
    }
    emit ev1(((((int184(-10922733894843811477881246729630280835435370407344271999) | (int184(0) + int184(0))) ^ int184(3548319269573042815117425269987991744088574377999841168)) - int184(537695112867361178540855217683460019570079484329174974)) & int184(1462650462242749956101213320468365981729044889992142554)));
    if (((~(bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))) == (bytes31(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) & bytes31(0x2ac0c64310f2f92cdf85c0522699470787008d6d08478c969eb3a49bfedca5))))
    {
      s1.push();
      s1.pop();
      (bool l0, bytes memory l1) = address(this).call(bytes(string("This is a really long string that must ideally be random but is currently hard coded")));
    }
    else
    {
      require(false, string("This is a really long string that must ideally be random but is currently hard coded"));
      return (bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    }
  }
}
function f3()     {
}
pragma solidity >= 0.0.0;
// ====
// ----
