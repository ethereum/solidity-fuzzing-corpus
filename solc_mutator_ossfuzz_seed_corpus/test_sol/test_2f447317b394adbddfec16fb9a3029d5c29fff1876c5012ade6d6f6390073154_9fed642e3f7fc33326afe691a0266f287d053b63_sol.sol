
==== Source: su0.sol ====
contract C0 {
  uint208   s0;
  int224 immutable  s1;
  bool   s2 = true;
  constructor(uint208 i0,int224 i1) payable  {
    s0 ^= ((((((uint208(142140552676430989139406566432882925436908246011074906833714101) | uint208(0)) >> uint136(uint136(87112285931760246646623899502532662132735))) & uint208(411376139330301510538742295639337626245683966408394965837152255)) % uint208(411376139330301510538742295639337626245683966408394965837152255)) << uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) - uint208(95435099804088766935564592110674597861723370832195200741678275));
    s1 = ((int224(9652161252616952443065452862288287951462120466755161064125806451977) + (int224(8604776214042093698011941526131679153888265012904374945337182629129) ^ int224(uint224(26959946667150639794667015087019630673637144422540572481103610249215)))) ^ int224(13479973333575319897333507543509815336818572211270286240551805124607));
    {
      int224  l0 = s1;
      int224  l1 = l0;
      assert(l1 == s1);
      uint208  l2 = s0;
      uint208  l3 = l2;
      assert(l3 == s0);
      assert((address(this) < address(this)));
      unchecked {
        bool  l4 = s2;
        bool  l5 = l4;
        assert(l5 == s2);
        uint208  l6 = s0;
        uint208  l7 = l6;
        assert(l7 == s0);
        (bool l8, bytes memory l9) = address(this).call(bytes("000000000000000000000000000000000000000000000000000000000000000000"));
      }
    }
  }
}
pragma solidity >= 0.0.0;
function f0(uint248 i0,bool i1)     returns(address o0)
{
  uint72 l0 = ((uint64(18446744073709551615) << uint144(uint144(794341213937618200298177800600555289023751))) - uint72(0));
  string memory l1 = string("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ====
// ----
