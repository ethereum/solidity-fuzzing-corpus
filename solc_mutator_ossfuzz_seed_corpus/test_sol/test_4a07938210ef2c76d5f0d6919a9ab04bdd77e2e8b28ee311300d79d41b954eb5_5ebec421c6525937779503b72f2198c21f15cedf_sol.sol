
==== Source: su0.sol ====
contract C0 {
  event ev0(function (uint40, string memory, address payable) external   returns (uint200, address, uint128[] memory) indexed ep0);
  mapping(bytes19 => bytes2)  public s0;
  address  public s1 = address(this);
  constructor()   {
    s0[(bytes19(0x00000000000000000000000000000000000000) ^ bytes19(0x00000000000000000000000000000000000000))] &= bytes2(0x0000);
    {
      (s1) = (address(this));
      assert(s1 == address(this));
      address  l0 = s1;
      address  l1 = l0;
      assert(l1 == s1);
      address  l2 = s1;
      address  l3 = l2;
      assert(l3 == s1);
    }
  }
  receive() external   payable
  {
  }
}
library L0 {
  function f1() internal    returns(bytes32 o0,string memory o1)
  {
    bytes memory l0 = bytes("01e9f0");
    function (bytes3, bytes29, int256) internal   l1;
  }
  modifier m0() 
  {
    int128 l0 = (-((int128(-83388076351139613522894636537988615202) | ((int64(0) != int64(0)) ? int128(0) : int128(0)))));
    assembly
    {
    }
    int40[7][3] memory l1 = [[int40(-236157505795), int40(0), int40(0), int40(-452908314570), int40(535379409411), int40(549755813887), int40(-547173683376)], [int40(0), int40(549755813887), int40(549755813887), int40(374509271045), int40(219088465324), int40(549755813887), int40(0)], [int40(0), int40(-481245298494), int40(0), int40(0), int40(549755813887), int40(549755813887), int40(-137837315138)]];
    address l2 = address(0x0000000000000000000000000000000000000004);
    _;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
