
==== Source: su0.sol ====
struct St0 {
  function (bytes22, bytes memory) external   returns (function (int88[][3] memory, uint240, function (int88, uint24, uint224[6][5][10] memory) external   returns (bytes13)) external   returns (address, int88, bytes26)) el0;
  address payable el1;
  int48 el2;
  address payable el3;
}
contract C0 {
  receive() external virtual  payable
  {
    for(    function (bytes23, uint184) external   returns (bytes memory, bool) l0;
false;
)
    {
    }
    uint16 l1 = (uint16(0) << uint104(uint104(11738703633630547694413933166037)));
    bytes memory l2 = bytes("0000000000000000000000000000005e1d1c719bd2d4a8707aaf03963497193ef7");
  }

	function compareMemoryAndCalldata(int224[2][4] memory v1, int224[2][4] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndCalldata(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndCalldata(int224[2] memory v1, int224[2] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f1(uint232 i0,int224[2][4] calldata i1,address payable i2) external    returns(int224 o0)
  {
    address l0 = address(this);
    int224[2][4] memory l1 = i1;
    assert(compareMemoryAndCalldata(l1, i1));
    address l3 = (false ? address(this) : address(bytes20(address(0x0000000000000000000000000000000000000000))));
    int224[2][4] memory l4 = i1;
    assert(compareMemoryAndCalldata(l4, i1));
  }
  address   s0 = address(this);
  St0  public s1;

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

		if (v1.el2 != v2.el2)
			return false;

		if (v1.el3 != v2.el3)
			return false;

	return true;
	}}
pragma solidity >= 0.0.0;
// ====
// ----
