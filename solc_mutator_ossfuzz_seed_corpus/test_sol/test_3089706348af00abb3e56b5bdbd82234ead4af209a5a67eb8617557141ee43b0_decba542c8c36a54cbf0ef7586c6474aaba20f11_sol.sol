==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  mapping(int184 => mapping(int256 => address))  public s0;
  mapping(address => int136)   s1;
  constructor() payable  {
    s1[((bytes18(0xd65ee6589699a94ab47143530ad06e86eb1d) == bytes18(0x276f6f74f1095fe21e744e86d896abf86b1e)) ? address(this) : address(this))] -= ((int136(0) ^ ((~(s1[address(this)])) - int136(0))) + int136(0));
    {
    }
  }
}
contract C1 is C0 {
  function f0() external virtual   returns(address[] memory o0,bytes32 o1)
  {
    unchecked {
      o0[uint256(0)] = msg.sender;
      assert(o0[uint256(0)] == msg.sender);
    }
    o0[uint256((uint192(0) + uint192(6277101735386680763835789423207666416102355444464034512895)))] = address(this);
    assert(o0[uint256((uint192(0) + uint192(6277101735386680763835789423207666416102355444464034512895)))] == address(this));
  }
  bytes28 immutable public s2;
  mapping(address => C0)   s3;
  bytes1   s4;
  bool   s5;
  constructor(bytes28 i0,bytes1 i1,bool i2)   {
    s2 = bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    s4 |= bytes1((~(bytes7(0xffffffffffffff))));
    s5 = true;
    s1[msg.sender] ^= ((int136(27162104621626947986377814319620899155027) | int136(39067666322631951824999452242970832552904)) ** uint8((uint8(215) * uint8(255))));
    s3[address(this)] = C0(address(this));
    unchecked {
    }
  }
  fallback() external virtual  payable
  {
    bytes28  l0 = s2;
    bytes28  l1 = l0;
    assert(l1 == s2);
  }
}
contract C2 {
  error er0();
  int160   s6;
  bytes30   s7;
  int152   s8;
  constructor(int160 i0,bytes30 i1,int152 i2)   {
    s6 *= int160(0);
    s7 &= bytes30(0x000000000000000000000000000000000000000000000000000000000000);
    s8 |= (((int152(0) ^ int152(((~(int152(0))) / int152(816529573448637962866865303094895596742501866)))) | int152(2854495385411919762116571938898990272765493247)) | int152(2854495385411919762116571938898990272765493247));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffff0000000000000000000000000000"));
      int160  l2 = s6;
      int160  l3 = l2;
      assert(l3 == s6);
      0;
      int160  l4 = s6;
      int160  l5 = l4;
      assert(l5 == s6);
      bytes30  l6 = s7;
      bytes30  l7 = l6;
      assert(l7 == s7);
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:366-1441): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su0.sol:449-459): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:917-927): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:928-937): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:938-945): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 6133: (su0.sol:2095-2096): Statement has no effect.
// Warning 5667: (su0.sol:1531-1540): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1541-1551): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1552-1561): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1918-1925): Unused local variable.
// Warning 2072: (su0.sol:1927-1942): Unused local variable.
