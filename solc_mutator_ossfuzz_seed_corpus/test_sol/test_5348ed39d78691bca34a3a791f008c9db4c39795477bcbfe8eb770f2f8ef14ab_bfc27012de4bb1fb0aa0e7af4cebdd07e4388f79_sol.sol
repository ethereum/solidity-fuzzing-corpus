==== Source:  ====

==== Source: su0.sol ====
function f0()      returns(uint8 o0,bool o1){
  function (address, bool) internal   returns (int24, uint40, address) l0;
}
contract C0 {
  receive() external   payable
  {
    (uint8 l0, bool l1) = f0();
    (bool l2, bytes memory l3) = payable(this).call{value: 0}("");
  }
  uint40 public constant cons0 = 1099511627775;
  struct St0 {
    mapping(bool => int24)[10] el0;
    address el1;
    bytes10 el2;
    uint240 el3;
  }
  C0.St0   s0;
  bool  public s1 = true;
}
pragma solidity >= 0.0.0;
error er0();
contract C1 is C0 {
  struct St1 {
    uint152 el0;
    address payable el1;
  }
  mapping(int40 => bool)   s2;
  mapping(uint136 => bytes18)   s3;
  mapping(bytes32 => mapping(bytes20 => bytes27))  public s4;
  constructor()   {
    s2[int40(((true ? int24(6764813) : int24(-2298494)) / int40(-433110206167)))] = (int232((((((int232(1503412018935195831322903207595352887892414220961442027967770112236315) | int232(3450873173395281893717377931138512726225554486085193277581262111899647)) - int232(1659741130784193314505221993062277950039489499389743029254280631715685)) - int232(1400174490285181296675794150681919943589455388751405304494350776209553)) - int232(0)) / int232(0))) != int232(0));
    s3[((((uint136(0) ^ uint136(86217620214285697494236936982923372769621)) % uint136(87112285931760246646623899502532662132735)) % uint136(87112285931760246646623899502532662132735)) | uint136(87112285931760246646623899502532662132735))] = bytes18(0xffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
}

==== Source: su1.sol ====
struct St2 {
  bytes31 el0;
}
contract C2 {
  address   s5;
  constructor(address i0)   {
    s5 = address(this);
    {
    }
  }
  fallback() external   payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    (bool l2) = payable(this).send(0);
  }
  function f3() public      {
    (bool l0) = payable(this).send(13398068811958918609);
    for(    bool l1 = true;
;
)
    {
      return;
    }
  }
  function f4(address i0,address i1) public virtual    returns(uint96 o0,bytes1 o1)  {
    (bool l0) = payable(this).send(0);
    (bool l1) = payable(this).send(0);
    o1 |= (bytes1(0xd6) ^ (bytes1(0x00) ^ bytes1(bytes9(0xffffffffffffffffff))));
  }
}
error er1(uint152 ep0, function (bytes memory, uint32, bool) external   returns (bool, bytes12) ep1);
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su1.sol:30-678): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su0.sol:27-35): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:36-43): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:48-119): Unused local variable.
// Warning 2072: (su0.sol:177-185): Unused local variable.
// Warning 2072: (su0.sol:187-194): Unused local variable.
// Warning 2072: (su0.sol:209-216): Unused local variable.
// Warning 2072: (su0.sol:218-233): Unused local variable.
// Warning 5667: (su1.sol:74-84): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:171-178): Unused local variable.
// Warning 2072: (su1.sol:180-195): Unused local variable.
// Warning 2072: (su1.sol:238-245): Unused local variable.
// Warning 2072: (su1.sol:311-318): Unused local variable.
// Warning 2072: (su1.sol:376-383): Unused local variable.
// Warning 5667: (su1.sol:440-450): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:451-461): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:489-498): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:518-525): Unused local variable.
// Warning 2072: (su1.sol:557-564): Unused local variable.
// Warning 2018: (su0.sol:0-122): Function state mutability can be restricted to pure
