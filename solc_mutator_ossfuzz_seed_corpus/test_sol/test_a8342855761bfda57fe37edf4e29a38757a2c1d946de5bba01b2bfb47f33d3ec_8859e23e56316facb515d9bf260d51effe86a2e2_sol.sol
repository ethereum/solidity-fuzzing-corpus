==== Source:  ====

==== Source: su0.sol ====
struct St0 {
  bool el0;
}
pragma solidity >= 0.0.0;
contract C0 {
  address payable public constant cons0 = payable(0x52dBBC1c3B9F9A8aF7c25daDdCCAb927F2ca4aFC);
  fallback() external virtual  
  {
    while (false)
    {
      if ((false != (address(this) == address(this))))
      {
        if ((bytes24(0x7651975473bac79b9eafe15607490002da2ba1509d0bb33b) < bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff)))
        {
          for(uint solinit0 = 0; solinit0 < (((((uint256(0) - uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint168(uint168(72555597848177905440609992767175724749946930754118))) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit0++)
          {
            break;
          }
          return;
        }
        else
        {
          break;
        }
        continue;
      }
    }
  }
  type T0 is bytes28;
  bytes29   s0;
  address   s1;
  mapping(uint248 => uint24)  public s2;
  C0.T0  public s3;
  constructor(bytes29 i0,address i1,C0.T0 i2)   {
    s0 |= bytes29(0x8bb894ccc5e16cc0ba4771061d1718b9fbbaf73998fac943cf55511a18);
    s1 = address(this);
    s3 = C0.T0.wrap(bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
    s2[(uint248(0) ** uint80(uint80(1208925819614629174706175)))] -= uint24(0);
    unchecked {
    }
  }
}

==== Source: su1.sol ====
contract C1 {
  function f1(address payable i0) internal virtual     {
  }
  bytes1   s4;
  constructor(bytes1 i0)   {
    s4 &= bytes1(0x00);
    {
    }
  }
  type T1 is int184;
}
pragma solidity >= 0.0.0;
type T2 is uint120;

using {
lt2 as <, gt2 as >, leq2 as <=, geq2 as >=,
bitor2 as |, bitand2 as &, bitxor2 as ^, bitnot2 as ~,
add2 as +, sub2 as -, mul2 as *, div2 as /, mod2 as %,
eq2 as ==, neq2 as !=

} for T2 global;



function lt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) < T2.unwrap(y); }

function gt2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) > T2.unwrap(y); }

function leq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) <= T2.unwrap(y); }

function geq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) >= T2.unwrap(y); }




function bitor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) | T2.unwrap(y)); }

function bitand2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) & T2.unwrap(y)); }

function bitxor2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) ^ T2.unwrap(y)); }

function bitnot2(T2 x) pure returns (T2) { return T2.wrap(~T2.unwrap(x)); }




function add2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) + T2.unwrap(y)); }

function sub2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) - T2.unwrap(y)); }

function mul2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) * T2.unwrap(y)); }

function div2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) / T2.unwrap(y)); }

function mod2(T2 x, T2 y) pure returns (T2) { return T2.wrap(T2.unwrap(x) % T2.unwrap(y)); }



function eq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) == T2.unwrap(y); }

function neq2(T2 x, T2 y) pure returns (bool) { return T2.unwrap(x) != T2.unwrap(y); }



// ----
// Warning 5740: (su0.sol:845-855): Unreachable code.
// Warning 5740: (su0.sol:986-994): Unreachable code.
// Warning 5667: (su0.sol:1143-1153): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1154-1164): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1165-1173): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:104-113): Unused function parameter. Remove or comment out the variable name to silence this warning.
