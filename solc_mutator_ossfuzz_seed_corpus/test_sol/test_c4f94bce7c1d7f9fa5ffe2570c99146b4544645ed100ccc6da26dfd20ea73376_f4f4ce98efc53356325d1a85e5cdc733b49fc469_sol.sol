
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(uint48 ep0, function (uint208) external   returns (uint96, address) ep1);
bool constant cons0 = (((bytes14(0xffffffffffffffffffffffffffff) & bytes14(0xffffffffffffffffffffffffffff)) & (bytes14(0x0000000000000000000000000000) ^ bytes14(0xffffffffffffffffffffffffffff))) != bytes14(0xffffffffffffffffffffffffffff));
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94
}
contract C0 {
  type T0 is uint40;
  modifier m0() 
  {
    address l0 = address(this);
    _;
  }
  bytes24  public s0;
  constructor(bytes24 i0) payable  {
    s0 = bytes24(0x5aff54f3e1efbb92f433dcceb746f8482bf471c78faf3ceb);
    {
    }
  }
  event ev0();
  modifier m1(C0.T0 i0,bool i1) 
  {
    if (true)
    {
      _;
    }
    if (((int208(-76604711677317480169629517656843791537836162251620273822886096) % (int208(100456836802568026845940280425950514350519557177985331566994562) ** uint32((uint32(4294967295) ^ uint32(3250150122))))) >= int208(71259505770824018200372414792229775592508979718985058460247567)))
    {
    }
    else if (cons0)
    {
      if (cons0)
      {
        if ((int80(604462909807314587353087) >= int80(405989168791078194461323)))
        {
        }
        else if (true)
        {
          if (cons0)
          {
          }
          else if (true)
          {
          }
          else
          {
            if (true)
            {
            }
            else if ((int32(0) != int32(785875944)))
            {
            }
            else if (false)
            {
            }
          }
        }
      }
      else if (((uint160(1362561851122949780590838468823069327853921513615) >= uint160(1461501637330902918203684832716283019655932542975)) || cons0))
      {
      }
      else if (((((((uint8(0) - uint8(0)) ** uint136(uint136(0))) - uint8(255)) ^ uint8(255)) ** uint136(uint136(87112285931760246646623899502532662132735))) == uint8(255)))
      {
        assembly
        {
        }
        _;
      }
      _;
      emit ev0();
    }
    else
    {
      _;
    }
  }
  struct St0 {
    mapping(bool => bytes20) el0;
    C0.T0 el1;
  }
  function f0() public  m0() m0()  returns(int192 o0,C0.T0 o1,bytes memory o2)
  {
    for(    0;
;
)
    {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffffffffffffffffff");
    }
  }
}
contract C1 {
  function f1(uint224 i0,bytes17 i1) public virtual  
  {
  }
  event ev1(function () external   returns (int96, string memory)  ep0);
  error er1();
  mapping(C0 => C0.St0)[]   s1;
  fallback() external   
  {
    if (false)
    {
      return;
      unchecked {
      }
    }
    else if (false)
    {
    }
  }
  event ev2() anonymous;
  type T1 is uint80;
  error er2();
}
// ====
// ----
