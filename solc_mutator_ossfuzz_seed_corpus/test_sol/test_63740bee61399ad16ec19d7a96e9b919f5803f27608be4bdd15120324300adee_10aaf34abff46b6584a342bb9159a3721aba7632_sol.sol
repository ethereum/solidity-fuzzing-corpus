
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
int16 constant cons0 = 32767;
contract C0 {
  bytes24   s0 = bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff);
  int200   s1;
  uint120   s2;
  constructor(int200 i0,uint120 i1) payable  {
    s1 += ((int200(0) - ((int200(0) | int200(803469022129495137770981046170581301261101496891396417650687)) % int200(0))) ** uint24(uint24(0)));
    s2 ^= (~(uint120(uint176(((uint176(95780971304118053647396689196894323976171195136475135) - (false ? uint176(37797353615819353339762652066346624556002538880404380) : uint176(0))) / uint176(63812932077851031004940748815564747140083465576415338))))));
    unchecked {
      bytes24  l0 = s0;
      bytes24  l1 = l0;
      assert(l1 == s0);
      int200  l2 = s1;
      int200  l3 = l2;
      assert(l3 == s1);
      {
        int200  l4 = s1;
        int200  l5 = l4;
        assert(l5 == s1);
        uint120  l6 = s2;
        uint120  l7 = l6;
        assert(l7 == s2);
        uint120  l8 = s2;
        uint120  l9 = l8;
        assert(l9 == s2);
        (bool l10, bytes memory l11) = address(this).call((true ? bytes("0000000000000000000000000000000000000000001f1b56") : bytes(string("cfaaa5010bbb41c60000000000000000000000"))));
        bytes24  l12 = s0;
        bytes24  l13 = l12;
        assert(l13 == s0);
        for(;
(bytes2(bytes21(0x000000000000000000000000000000000000000000)) >= bytes7(0x00000000000000));
bytes15(bytes4(0x00000000)))
        {
          bytes13 l14 = (bytes13(0x00000000000000000000000000) ^ (bytes13(0x00000000000000000000000000) & (bytes13(0xcaec1d7e84f94e2469cf5dee5d) & bytes13(0x00000000000000000000000000))));
        }
        (s0) = (bytes24(0x26c1bcb52a10943e157ecc32dcb37d3cb9667e11a938ab89));
        assert(s0 == bytes24(0x26c1bcb52a10943e157ecc32dcb37d3cb9667e11a938ab89));
      }
      bytes24  l15 = s0;
      bytes24  l16 = l15;
      assert(l16 == s0);
    }
  }
  fallback() external   
  {
    {
      bytes24  l0 = s0;
      bytes24  l1 = l0;
      assert(l1 == s0);
      (bool l2, bytes memory l3) = address(this).call(bytes(string("ffffffffffffffffffffffffffffffffffffffffffffffffffffb46c743a2ea8267fd920623b44950fd8fd97fb497107")));
      int200  l4 = s1;
      int200  l5 = l4;
      assert(l5 == s1);
      (bool l6, bytes memory l7) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000"));
      for(uint solinit0 = 0; solinit0 < (uint256(0) % 11); solinit0++)
      {
        unchecked {
          int176 l8 = (int40(388726312374) - int176(41634881269373073348365557721159072629708555226487510));
          for(          uint224 l9 = uint224(12980526882817791981880676015150024719167445051799293342375686686908);
true;
)
          {
            assembly
            {
            }
          }
          uint160 l10 = (((uint160(803965025081604723461858721496826415584952045313) >> uint208(uint208(0))) * uint160(120425488761917577605642814693829788267249051295)) | uint160(0));
          address l11 = (true ? address(this) : address(this));
          function (uint240[10][6][] memory) internal   returns (uint24, bool) l12;
        }
        unchecked {
        }
      }
      bytes24  l13 = s0;
      bytes24  l14 = l13;
      assert(l14 == s0);
    }
  }
}

==== Source: su1.sol ====
library L0 {
  function f1(uint104 i0,address i1) public   
  {
    i1 = address(0x0000000000000000000000000000000000000002);
    assert(i1 == address(0x0000000000000000000000000000000000000002));
    address l0 = msg.sender;
    function (bytes32) external   returns (bytes6[] memory, uint40, address[][][][5][] memory) l1;
    return;
  }
  error er0(bool ep0, bytes24 ep1);
  error er1(uint152 ep0, address payable ep1);
}
using L0 for uint104;
pragma solidity >= 0.0.0;
library L1 {
  error er2(function (int200, bool) external   returns (int168, int120, address payable) ep0);
}
// ====
// ----
