
==== Source: su0.sol ====
uint64 constant cons0 = (((((uint64((uint64(0) / uint64(0))) * uint64(7908484742707447608)) + uint64(18446744073709551615)) - uint64(18446744073709551615)) - uint64(0)) | uint64(18446744073709551615));
struct St0 {
  int160 el0;
  int64 el1;
  int48 el2;
}
pragma solidity >= 0.0.0;
type T0 is uint216;
error er0(function (St0 memory, string memory, int104) external   returns (T0) ep0, function (bytes28, int80, function (St0 memory, int24, bytes16) external   returns (T0)) external   ep1);
library L0 {
  function f0(bool i0,St0 memory i1) external   
  {
    if (((false || true) ? false : (bytes7(0x00000000000000) >= bytes7(0xa263f996c88908))))
    {
    }
    else
    {
    }
    int112 l0 = int112(2596148429267413814265248164610047);
  }
  bytes19 public constant cons1 = bytes19(0xffffffffffffffffffffffffffffffffffffff);
  modifier m0(int56 i0,function (bytes31, St0 memory, bytes9) external   returns (int208, address[] memory)[] memory i1) 
  {
    _;
  }
  function f1(uint168 i0) external  m0(((((((int56(26795448974501771) * int56(0)) ** uint256(uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & int56(-22689817262652709)) ^ int56(-11692863730706450)) & int56(36028797018963967)) ^ int56(31381489763083876)),new function (bytes31, St0 memory, bytes9) external   returns (int208, address[] memory)[](1))  returns(uint128 o0,int120 o1,uint192 o2)
  {
    if (true)
    {
    }
    else if ((true != false))
    {
    }
    else if ((((int8(0) % int8(127)) == int8(0)) || false))
    {
    }
  }
  error er1();
  using L0 for *;
  error er2(function (uint32, uint192, function (address, int144, T0) external   returns (T0, int112)) external   ep0);
  modifier m1(function (St0 memory) external   i0) 
  {
    _;
    _;
  }
  modifier m2() 
  {
    revert L0.er1();
    _;
  }
  event ev0();
}
// ====
// ----
