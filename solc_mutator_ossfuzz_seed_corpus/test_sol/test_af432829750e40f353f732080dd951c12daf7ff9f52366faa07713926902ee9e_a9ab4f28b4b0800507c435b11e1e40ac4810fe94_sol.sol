
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  modifier m0(int80 i0,bytes14 i1) 
  {
    unchecked {
      i0 = (((((~(int80(366168771973925173480715))) % int80(244898543746431774501010)) & int80(604462909807314587353087)) | int80(604462909807314587353087)) ^ int80(604462909807314587353087));
      assert(i0 == (((((~(int80(366168771973925173480715))) % int80(244898543746431774501010)) & int80(604462909807314587353087)) | int80(604462909807314587353087)) ^ int80(604462909807314587353087)));
      (i0) = (((((((int80(604462909807314587353087) ** uint184(uint184(8315731006587388163693272731393406965681141142661853019))) | int80(-45053487477595789657166)) * int80(604462909807314587353087)) + int80(0)) & int80(0)) + int80(0)));
      assert(i0 == ((((((int80(604462909807314587353087) ** uint184(uint184(8315731006587388163693272731393406965681141142661853019))) | int80(-45053487477595789657166)) * int80(604462909807314587353087)) + int80(0)) & int80(0)) + int80(0)));
      if (true)
      {
        (bool l0, bytes memory l1) = payable(this).call{value: 14109842466377562347}("");
        uint152[6] storage l2;
      }
      else
      {
        (i1) = (bytes14(bytes2(0x0000)));
        assert(i1 == bytes14(bytes2(0x0000)));
      }
      (bool l3, bytes memory l4) = payable(this).call{value: 8268130254736122154}("");
      (bool l5) = payable(this).send(0);
      {
        uint48 l6 = (uint48(0) + ((((uint48(281474976710655) ^ uint48(22965601837935)) * uint48(281474976710655)) ^ uint48(205835388740713)) ^ uint48(53554231648452)));
        uint96 l7 = ((((((uint96(79228162514264337593543950335) * uint96(0)) + uint96(65767018589841921333806907541)) - uint96(76123198811103386121889424163)) | uint96(79228162514264337593543950335)) - uint96(79228162514264337593543950335)) | uint96(0));
        assembly
        {
          for 
          {
            let al0 := mload(add(0x80, mod(i0, 2048)))
            let al1 := 19856936469902686048390347945936846635381503921230303899933574652828168546698
          }
          sload(i0)
          {
            i0 := i0
            i1 := i0
          }
          {
            sstore(callvalue(), i0)
          }
        }
        function () internal   returns (bool, uint24) l8;
      }
    }
    _;
  }
  receive() external  m0(((int80(0) | int80(604462909807314587353087)) | int80((int80((int80(0) / int80(604462909807314587353087))) / int80(-429857183919274705394921)))),bytes14(0x0000000000000000000000000000)) payable
  {
    uint16[3] storage l0;
    return;
  }
  struct St0 {
    bytes el0;
  }
  address   s0 = address(this);
  bytes3  public s1 = bytes3(0x000000);
  mapping(bytes28 => C0.St0)  public s2;
  constructor()   {
    { }
  }
}
// ====
// ----
