==== Source:  ====

==== Source: su0.sol ====
library L0 {
  function f0() external    returns(bool o0,function (int168, bytes23) external   returns (uint8, bool) o1)
  {
    assembly
    {
      let al0 := o0
      o0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      function af0(ai0) -> ao0, ao1, ao2, ao3, ao4, ao5, ao6, ao7, ao8
      {
        switch mload(add(0x80, mod(ai0, 2048)))
        case 115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
        }
        case 0
        {
          revert(ai0, ai0)
        }
      }
      let al1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
    }
  }
  function f1(uint136 i0) external   
  {
    int88 l0 = int88(0);
    address[][8] memory l1 = [new address[](7), new address[](7), new address[](7), new address[](7), new address[](7), new address[](7), new address[](7), new address[](7)];
  }
  function f2(address i0,function (string memory, address payable, bool) external   returns (function () external  ) i1) public   
  {
    0;
  }
}
using L0 for uint136;
pragma solidity >= 0.0.0;
using L0 for uint136;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  receive() external   payable
  {
    uint136[][] memory l0 = new uint136[][](8);
    address payable l1 = payable(address(this));
    unchecked {
      {
        bytes10 l2 = (bytes10(0x00000000000000000000) & (bytes10(0xffffffffffffffffffff) & bytes10(0xffffffffffffffffffff)));
        (bool l3, bytes memory l4) = payable(this).call{value: 0}("");
        function (int72, bytes20) external   l5;
        l2 ^= (bytes10(0xffffffffffffffffffff) & bytes10(bytes23(0x0000000000000000000000000000000000000000000000)));
      }
      int88 l6 = ((int72(1260600963750289155655) - (int16(0) & int72(0))) ^ int88(0));
    }
  }
  bool   s0 = false;
  uint104   s1 = uint104(7077760497536558495693250306879);
  address   s2 = address(this);
  bytes29  public s3;
  constructor(bytes29 i0)   {
    s3 &= bytes18(0xffffffffffffffffffffffffffffffffffff);
    { }
  }
  struct St0 {
    uint256 el0;
  }
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
}
library L1 {
  function f4(uint40[] memory i0) private    returns(bytes16 o0)
  {
  }
  function f5(address i0,function (int112) external   returns (bool) i1) external   
  {
    int96 l0 = int96(int80(-192306413782957367572301));
  }
}
// ----
// Warning 5667: (su0.sol:57-119): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:684-694): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:716-724): Unused local variable.
// Warning 2072: (su0.sol:741-763): Unused local variable.
// Warning 6133: (su0.sol:1055-1056): Statement has no effect.
// Warning 5667: (su0.sol:930-940): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:941-1035): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:79-100): Unused local variable.
// Warning 2072: (su1.sol:127-145): Unused local variable.
// Warning 2072: (su1.sol:331-338): Unused local variable.
// Warning 2072: (su1.sol:340-355): Unused local variable.
// Warning 2072: (su1.sol:401-440): Unused local variable.
// Warning 2072: (su1.sol:574-582): Unused local variable.
// Warning 5667: (su1.sol:813-823): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1116-1126): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1127-1173): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:1195-1203): Unused local variable.
// Warning 2018: (su0.sol:15-669): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:672-915): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:918-1061): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:1104-1250): Function state mutability can be restricted to pure
