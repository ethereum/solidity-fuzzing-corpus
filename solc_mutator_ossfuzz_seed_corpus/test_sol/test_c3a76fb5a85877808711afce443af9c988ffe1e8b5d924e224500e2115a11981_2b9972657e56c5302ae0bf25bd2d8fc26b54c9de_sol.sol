
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0(bytes10 ep0, bool ep1);
struct St0 {
  uint200 el0;
  uint184 el1;
  bytes11 el2;
}

==== Source: su1.sol ====
import "su0.sol";
function f0()     returns(function (bool, function (int232[] memory, bytes10) external   returns (int192, function () external  , bool)[] memory, bool) external   returns (string memory, bool, int120) o0,bytes24 o1)
{
}
contract C0 {
  St0   s0 = St0(uint200(1606938044258990275541962092341162602522202993782792835301375), uint184(0), bytes11(0x4c2d70d9d859b716f83bdf));
  modifier m0(int104 i0) virtual
  {
    (bool l0, bytes memory l1) = address(this).call("0000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    _;
  }
  function f1(uint200 i0,bytes14[] calldata i1) external    returns(bool o0,function (bytes19, St0 memory) external   o1,St0 memory o2)
  {
  }
  function f2(int224 i0,bool i1) public virtual m0(((((int104(10141204801825835211973625643007) * (int104(-3659028203781352223951687148244) * int104(-3638111290069104362306697006500))) ** uint64(uint64(18446744073709551615))) ^ int104(-8756318241956638468956672045515)) ** uint32(uint32(4294967295)))) payable returns(function (function (bytes21, int232) external   returns (uint8, address, function (int16, address payable, uint88) external   returns (int184))) external   returns (function (function (function (int160, bytes23) external   returns (uint16, address payable, address), string memory, function (uint72, bytes memory, bool) external   returns (bool)) external  , uint256) external   returns (uint240, function (bytes3) external   returns (uint88)), uint80[] memory, bool) o0,bytes17 o1,int48 o2)
  {
    (s0.el2) = (bytes11(0xd6026642b0819983af6042));
    unchecked {
    }
    St0 memory l0 = St0(uint200(500763453062846227186140602720104382097569127280925259069758), uint184(10280920025471999143788862385502602170840093659160849711), bytes11(0x0000000000000000000000));
    function (int144, string memory) internal   returns (uint200) l1;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88, M89, M90, M91, M92, M93, M94, M95,
    M96, M97, M98, M99, M100, M101, M102, M103,
    M104, M105, M106, M107, M108, M109, M110, M111,
    M112, M113, M114, M115, M116, M117, M118, M119,
    M120, M121, M122, M123, M124, M125, M126, M127,
    M128, M129, M130, M131, M132, M133, M134, M135,
    M136, M137, M138, M139, M140, M141, M142, M143,
    M144, M145, M146, M147, M148, M149, M150
  }
  struct St1 {
    bytes31 el0;
    bool el1;
  }
  modifier m1(bool[2] memory i0,int32 i1) 
  {
    _;
  }
  type T0 is bool;
  event ev0();
}
library L0 {
  C0.T0 public constant cons0 = C0.T0.wrap(true);
  modifier m2(function (uint88) external   returns (bool, C0.EN0, bytes13) i0) 
  {
    bool l0 = false;
    _;
  }
  error er1(function (uint24, int248) external   ep0, int160 ep1);
  bytes25 public constant cons1 = (false ? bytes25(((bytes24(0x000000000000000000000000000000000000000000000000) | bytes24(0xaea0467b96f24eb1b1d16508083936db673edee9206397d2)) | bytes24(0x000000000000000000000000000000000000000000000000))) : bytes25(0x00000000000000000000000000000000000000000000000000));
  function f3() external    returns(bool o0,bytes1 o1,int48 o2)
  {
    assembly
    {
      {
      }
    }
  }
  function f4() internal    returns(C0.T0 o0)
  {
  }
}
error er2();
struct St2 {
  C0.EN0 el0;
  C0.T0 el1;
  bytes22 el2;
  bytes8[2][] el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
