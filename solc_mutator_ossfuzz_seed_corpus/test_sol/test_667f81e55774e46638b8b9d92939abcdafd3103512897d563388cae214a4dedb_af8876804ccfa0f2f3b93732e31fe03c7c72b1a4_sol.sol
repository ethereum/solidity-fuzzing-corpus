==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
library L0 {
  modifier m0() 
  {
    function (bytes memory, function (bytes32) external  , int144) external   l0;
    while (false)
    {
      _;
    }
  }
  function f0() internal    returns(function (bool) external   o0,address payable[3][1][8][][4] memory o1,function () external   o2)
  {
    address l0 = address(0x0000000000000000000000000000000000000003);
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  using L0 for *;
  function f1() external    returns(int216 o0)
  {
    (o0) = (int216(52656145834278593348959013841835216159447547700274555627155488767));
    assert(o0 == int216(52656145834278593348959013841835216159447547700274555627155488767));
    bytes27 l0 = bytes27(0x1e17d4cc5db75263481f4442e4c782860962cac4455f5baa8865dd);
  }
  modifier m1(function (address payable, string memory) external   i0) 
  {
    _;
  }
  fallback() external   payable
  {
    (bool l0, bytes memory l1) = address(this).call(abi.encodeWithSignature("f1()"));
    (int216 l2) = this.f1();
  }
  string   s0 = string("ffffffff00000000000000000000000000000000000000");

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bytes26  public s1;
  address   s2;
  bool   s3;
  constructor(bytes26 i0,address i1,bool i2)   {
    s1 ^= bytes26((bytes11(bytes30((~((bytes16(0xc74643acfab95283ba41d7d64baded4a) | bytes16(0x0782f8d91747656f492877f7c9287401)))))) | bytes11(0xffffffffffffffffffffff)));
    s2 = address(this);
    s3 = false;
    unchecked {
      {
        string memory l0 = s0;
        string memory l1 = l0;
        assert(compareMemoryAndStorage(l1, s0));
        bool  l2 = s3;
        bool  l3 = l2;
        assert(l3 == s3);
        bytes26  l4 = s1;
        bytes26  l5 = l4;
        assert(l5 == s1);
        assert(false);
      }
      if (true)
      {
      }
      else if ((payable(address(this)) >= payable(this.f1.address)))
      {
      }
      delete s2;
      address  l6 = s2;
      address  l7 = l6;
      assert(l7 == s2);
      address  l8 = s2;
      address  l9 = l8;
      assert(l9 == s2);
    }
  }
}
// ----
// Warning 3628: (su1.sol:398-2145): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 5667: (su1.sol:195-224): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:225-264): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:265-290): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:300-310): Unused local variable.
// Warning 2072: (su1.sol:666-676): Unused local variable.
// Warning 2072: (su1.sol:878-885): Unused local variable.
// Warning 2072: (su1.sol:887-902): Unused local variable.
// Warning 2072: (su1.sol:964-973): Unused local variable.
// Warning 5805: (su1.sol:1938-1942): "this" used in constructor. Note that external functions of a contract cannot be called while it is being constructed.
// Warning 5667: (su1.sol:1292-1302): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1303-1313): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1314-1321): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:161-369): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:432-749): Function state mutability can be restricted to pure
