
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0(bool i0)     {
  if (i0)
  {
    while (true)
    {
      continue;
    }
  }
}
function f1(int208 i0)     {
}
contract C0 {
  bool immutable public s0;
  constructor(bool i0)   {
    s0 = false;
    unchecked {
      if (i0)
      {
        if (i0)
        {
        }
        else if (i0)
        {
          if (i0)
          {
            revert(true f2 /*suffix expr*/);
          }
        }
      }
      else
      {
        do
        {
          revert(string("This is a really long string that must ideally be random but is currently hard coded"));
        }
        while (true);
        if (i0)
        {
          if (i0)
          {
            f0(((bytes3(0x722ebd) & ((~(bytes3(0x000000))) & bytes3(0x000000))) == bytes3(0xe3edf9)));
            if (i0)
            {
              do
              {
              }
              while (false);
            }
            f0({i0: (bytes6(0xffffffffffff) != (false ? bytes6(0xffffffffffff) : bytes6(0xffffffffffff)))});
          }
          else
          {
            (i0) = (true);
            assert(i0 == true);
          }
        }
        else
        {
        }
      }
    }
  }
  event ev0(address payable  ep0, address payable  ep1);
  function f3(bool i0,bool i1,bool i2) public virtual    returns(bool[3] memory o0,int32 o1)  {
  }
  receive() external   payable
  {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    (bool l2, bytes memory l3) = address(this).call(abi.encodeWithSelector(this.f3.selector, false,((-945990171783178580088152927723742469138047187025252496 f5 /*suffix expr*/ ^ (((bytes2(0xffff) & bytes2(0x0f6d)) | bytes2(0xffff)) | bytes2(0xffff))) < bytes2(0xffff)),((~((bytes24(0x000000000000000000000000000000000000000000000000) & bytes24(0x000000000000000000000000000000000000000000000000)))) >= bytes24(0x000000000000000000000000000000000000000000000000))));
  }
}
function f2(bool i0) pure suffix  returns(string memory o0)
{
  address l0 = address(0x0000000000000000000000000000000000000004);
  if (i0)
  {
    do
    {
      bytes11 l1 = bytes11(0xffffffffffffffffffffff);
      if (i0)
      {
        if (i0)
        {
          continue;
        }
        break;
      }
      else
      {
        f1((int208(((int208(184304297058840905063383872294202008668264258596247006021908664) | int208(((int208(98279527735439393322529366767050994839706305948614475673210360) & int208(205688069665150755269371147819668813122841983204197482918576127)) / int208(0)))) / int208(205688069665150755269371147819668813122841983204197482918576127))) - int208(205688069665150755269371147819668813122841983204197482918576127)));
        address l2 = address(0x0000000000000000000000000000000000000002);
        break;
      }
    }
    while (true);
  }
  else if (i0)
  {
  }
}
function f5(int184 i0) pure suffix  returns(bytes2 o0)
{
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
contract C1 {
  uint224 public constant cons0 = 9450445748164778042798556111230962673585022000692598097170077009465;
  receive() external   payable
  {
  }
  struct St0 {
    int168 el0;
    address payable[] el1;
  }
  struct St1 {
    uint136 el0;
    bytes el1;
    function (function (bytes memory, uint80) external  , bytes32, bool) external   el2;
  }
  int168   s1 = int168(160141822974476679104047365708651951249516076754491);
  int240  public s2;
  constructor(int240 i0)   {
    s2 &= int240(883423532389192164791648750371459257913741948437809479060803100646309887);
    unchecked {
    }
  }
}
struct St2 {
  int192 el0;
  C0 el1;
  uint248 el2;
}
// ====
// ----
