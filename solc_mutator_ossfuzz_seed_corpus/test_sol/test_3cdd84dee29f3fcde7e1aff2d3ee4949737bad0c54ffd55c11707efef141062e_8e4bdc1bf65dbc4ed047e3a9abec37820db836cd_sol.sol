
==== Source: su0.sol ====
struct St0 {
  bool el0;
  mapping(address => bytes19) el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
function f0(int160 i0,uint208 i1)     {
  if (i1 < ((hex"839106c1d5e5e16a781c" f1 /*suffix expr*/ * (((uint208(0) + uint208(411376139330301510538742295639337626245683966408394965837152255)) * uint208(103232461152330461248089773531771469749449485061355112120047250)) >> uint40(uint40(332858658439)))) ^ uint208(411376139330301510538742295639337626245683966408394965837152255)))
  {
    if (i1 <= (((uint208(58779112406356932763946778827296740024250777159102897333682242) * uint208((hex"0000000000000000000000" f2 /*suffix expr*/ / uint208(0)))) - uint208(0)) * uint208(0)))
    {
      if (i0 >= int160((int160((0x0000000000000000000000000000000000000001 f3 /*suffix expr*/ / int160((((int160(730750818665451459101842416358141509827966271487) - int160(0)) % int160(0)) / int160(0))))) / int160(-72259704802667824657519395131340500098256014117))))
      {
      }
      else
      {
        revert(string("This is a really long string that must ideally be random but is currently hard coded"));
      }
    }
    return;
  }
}
contract C0 {
  mapping(bytes4 => bool)  public s0;
  string   s1;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  uint8   s2;
  int64   s3;
  constructor(string memory i0,uint8 i1,int64 i2) payable  {
    s1 = string("This is a really long string that must ideally be random but is currently hard coded");
    s2 -= (true ? uint8(0) : (((uint8(200) ** uint232(uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) & uint8(2)) | uint8(0)));
    s3 = (int64(-3644993137588908121) | int64(9223372036854775807));
    s0[bytes4(0xad56d7dd)] = false;
    unchecked {
    }
  }
  error er0();
  event ev0(function (bool) external   returns (int72, bool, bool)  ep0, int232  ep1, bytes  ep2) anonymous;
  error er1();
}
struct St1 {
  uint192 el0;
  bool el1;
}
error er2(function () external   returns (string memory, St1 memory, function (bytes10, int128) external   returns (address)[6] memory) ep0, function (bool, St1 memory) external   returns (St1 memory, function () external   returns (uint16, int144, bool), address payable) ep1);
pragma solidity >= 0.0.0;
struct St2 {
  string el0;
  function (bytes8) external   el1;
  bytes14[] el2;
}
function f1(bytes10 i0) pure suffix  returns(uint208 o0)
{
  if (i0 < ((((0x33ec7C1146e2C2544e1c4E6feB0cB0Eb97B1537C f4 /*suffix expr*/ > address(0x0000000000000000000000000000000000000008)) ? address(0x0000000000000000000000000000000000000002) : address(0x0000000000000000000000000000000000000006)) > address(0x0000000000000000000000000000000000000002)) ? bytes1(0x59) : bytes1(0x44)))
  {
    bytes3 l0 = bytes3(0xc00c7b);
  }
  else if (i0 < (bytes10(0xffffffffffffffffffff) ^ (bytes10(0xa3bc3f5748a86a81585d) | (bytes10(0xffffffffffffffffffff) | bytes10(0xffffffffffffffffffff)))))
  {
    o0 &= (uint208(0) | uint208(24230944886667277190477451454680676142045857421756435494782545));
    if (i0 <= (false ? bytes10(0x00000000000000000000) : (bytes10(0xffffffffffffffffffff) & 0x0000000000000000000000000000000000000005 f5 /*suffix expr*/)))
    {
      uint152 l1 = uint152(5708990770823839524233143877797980545530986495);
    }
    else
    {
      if (i0 <= (bytes10(0xffffffffffffffffffff) ^ (bytes10(0x57d232502ba33f710433) | i0)))
      {
      }
    }
  }
}
function f2(bytes11 i0) pure suffix  returns(uint208 o0)
{
}
function f3(address i0) pure suffix  returns(int160 o0)
{
}
function f4(address i0) pure suffix  returns(address o0)
{
}
function f5(address i0) pure suffix  returns(bytes10 o0)
{
}
// ====
// ----
