
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  function f0() external    returns(uint120[5] memory o0,bytes4 o1)
  {
    int152 l0 = int152(0);
    assembly
    {
      o0 := 19695418913861754605564367143447093197343734451454601145950041074973348906193
      let al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
    }
  }
  error er0(function (function (function (bytes17, int24) external   returns (bytes memory, address payable, uint16), bytes28, uint216) external   returns (bytes15)) external   returns (int112, bytes17) ep0);
  function f1(bytes memory i0) private    returns(bytes memory o0)
  {
    uint200 l0 = (uint200(1151842901125801688451247268066082811193169579337033636744930) & uint200(1099744897284861100241733067860588762028584515723075012039551));
    unchecked {
      function () external   returns (bytes3) l1;
    }
  }
}
using L0 for bytes;
contract C0 {
  using L0 for *;
  bytes9   s0 = bytes9(0x000000000000000000);
  int184 public constant cons0 = 12259964326927110866866776217202473468949912977468817407;
  function f2() public   payable returns(address payable[] memory o0)
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("00000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
}
// ====
// ----
