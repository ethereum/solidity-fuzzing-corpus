==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0(function (address payable) external   i0,bytes28 i1) external   payable  returns(bool o0,function () external   returns (bool, int256, function (int232, address payable, address) external  ) o1)  {
  }
  uint208 immutable public s0;
  constructor(uint208 i0)   {
    s0 = (uint208(129464338794725464458249345442336434276847214579955001909791268) ^ (uint208((((uint208(409374424488248282456157907503317325571322849645255812375000126) * uint208(0)) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) / uint208(0))) - uint208(0)));
    {
    }
  }
  error er0(bool ep0);
}
pragma solidity >= 0.0.0;
error er1(uint104 ep0, int184 ep1);
struct St0 {
  address payable el0;
  uint240 el1;
  bytes el2;
  uint24 el3;
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f1(address i0)      returns(bytes memory o0){
  o0 = bytes(string.concat(string(bytes("c5d6ffffffffffffffffffffffffffffff")), string("This is a really long string that must ideally be random but is currently hard coded")));
  assert(keccak256(bytes(o0)) == keccak256(bytes(bytes(string.concat(string(bytes("c5d6ffffffffffffffffffffffffffffff")), string("This is a really long string that must ideally be random but is currently hard coded"))))));
}
contract C1 {
  mapping(bool => int8)  public s1;
  address   s2 = address(this);
  uint72   s3 = uint72(0);
  mapping(int40 => bool)   s4;
  constructor()   {
    s1[(false != true)] |= int8(40);
    s4[int40(549755813887)] = false;
    unchecked {
    }
  }
  function f2(uint72 i0) external virtual    returns(address o0)  {
    for(;
;
)
    {
      require((int48(140737488355327) <= int48(140737488355327)));
    }
    do
    {
      return (address(this));
    }
    while (true);
    (bool l0, bytes memory l1) = address(this).call(bytes("c9074b41746ac4bd21d667f34fa7a9d994951fab2b87c1f876222bfc83fb5e5cc7b7c659223a194d167a8bc23551"));
    (s2) = (address(this));
    assert(s2 == address(this));
  }
  function f3(bytes22 i0,int112 i1,address i2) external     returns(bytes memory o0)  {
    return (bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  uint240 public constant cons0 = 1766847064778384329583297500742918515827483896875618958121606201292619775;
}
address constant cons1 = 0x2Db43c10fB79b97a1B8d69e32f3C8c47B1904C8d;
function f4(bool i0)      returns(bytes23 o0,string memory o1){
}
// ----
// Warning 3149: (su0.sol:387-569): The result type of the exponentiation operation is equal to the type of the first operand (uint208) ignoring the (larger) type of the second operand (uint240) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 5740: (su1.sol:965-969): Unreachable code.
// Warning 5740: (su1.sol:976-1187): Unreachable code.
// Warning 5667: (su0.sol:275-285): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:38-48): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:758-767): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:977-984): Unused local variable.
// Warning 2072: (su1.sol:986-1001): Unused local variable.
// Warning 5667: (su1.sol:1207-1217): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1218-1227): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:1228-1238): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su1.sol:26-483): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:1195-1408): Function state mutability can be restricted to pure
