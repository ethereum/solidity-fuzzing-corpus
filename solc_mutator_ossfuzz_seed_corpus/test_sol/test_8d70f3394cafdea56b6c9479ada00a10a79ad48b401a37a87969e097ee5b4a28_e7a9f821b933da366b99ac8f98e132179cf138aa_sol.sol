==== Source:  ====

==== Source: su0.sol ====
function f0(uint72 i0)     returns(uint40[][] memory o0)
{
}
contract C0 {
  fallback() external virtual  payable
  {
    function () external   l0;
    if (false)
    {
      uint200 l1 = (uint8((uint8(((uint8(255) % uint8(255)) / uint8(255))) / uint8(254))) & uint8(0));
      (bool l2) = payable(this).send(0);
    }
    else
    {
      return;
    }
    (bool l3, bytes memory l4) = payable(this).call{value: 6659072509457286071}("");
    address[][1][][7][10][9] storage l5;
  }
  address payable  public s0 = payable(address(this));
  bool[][3][]  public s1;

	function compareMemoryAndStorage(bool[][3][] memory v1, bool[][3][] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(bool[][3] memory v1, bool[][3] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(bool[] memory v1, bool[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool immutable  s2 = true;
  constructor(bool[][3][] memory i0) payable  {
    s1 = i0;
    unchecked {
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
      (s1[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]) = ([new bool[](7), new bool[](7), new bool[](7)]);
      (s1[((type(uint256).min ^ uint256(28714451109415899423633122590330890495777885702548991638504515144036790277872)) & ((uint256(0) - uint256(67193779842735167244191792066336024095696073160819471177607870091579939330383)) & uint256(41349750263078623919233388876468941650458793825397431119278940269383713798359)))]) = (s1[(uint256(0) - ((payable(address(this)) > payable(address(this))) ? uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))]);
      s1.pop();
      s1 = [[new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)], [new bool[](7), new bool[](7), new bool[](7)]];
      s1[((((uint256(29043589277818717788293388904810057986147371911666471657018297071802677040889) << uint152((uint152(536381585671877130870302766383074002159992593) | uint152(0)))) | uint256(82191226484876630577887917834244791781494952000101116388995112606271357912202)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) + uint256(0))] = [new bool[](7), new bool[](7), new bool[](7)];
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
// ----
// Warning 3628: (su0.sol:61-3059): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// Warning 2072: (su0.sol:122-147): Unused local variable.
// Warning 2072: (su0.sol:176-186): Unused local variable.
// Warning 2072: (su0.sol:280-287): Unused local variable.
// Warning 2072: (su0.sol:360-367): Unused local variable.
// Warning 2072: (su0.sol:369-384): Unused local variable.
// Warning 2072: (su0.sol:444-479): Unused local variable.
// Warning 2018: (su0.sol:1122-1364): Function state mutability can be restricted to view
