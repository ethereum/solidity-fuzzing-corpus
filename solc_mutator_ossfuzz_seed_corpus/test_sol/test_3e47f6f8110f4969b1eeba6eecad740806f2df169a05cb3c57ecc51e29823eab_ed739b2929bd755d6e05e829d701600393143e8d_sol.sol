
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()      returns(bool o0,uint120 o1,bytes11 o2){
  (o2) = (bytes11(0x0000000000000000000000));
  assert(o2 == bytes11(0x0000000000000000000000));
}
function f1()      returns(uint80[7] memory o0,int56 o1){
  (o1) = ((int56(36028797018963967) | int56((int56(36028797018963967) / ((int56(36028797018963967) - int56(36028797018963967)) * int56(-17071344120923214))))));
  assert(o1 == (int56(36028797018963967) | int56((int56(36028797018963967) / ((int56(36028797018963967) - int56(36028797018963967)) * int56(-17071344120923214))))));
  return ([uint80(1208925819614629174706175), uint80(656325690572538671755437), uint80(0), uint80(1208925819614629174706175), uint80(1069680569991841201497568), uint80(960339759239366624625729), uint80(785594554367104930717192)], (~(((~(((int56(-464218069765761) ^ int56(36028797018963967)) % int56(0)))) | int56(0)))));
}
struct St0 {
  uint64 el0;
  bool el1;
  int176 el2;
  string el3;
}

==== Source: su1.sol ====
struct St1 {
  uint88 el0;
}
struct St2 {
  address payable el0;
  uint192 el1;
  bool el2;
  mapping(address => bytes14) el3;
}
pragma solidity >= 0.0.0;
address constant cons0 = 0x054dE69FD220DaF490Fc1AE07763AC8d4552A1ce;
// ====
// ----
