
==== Source: su0.sol ====
contract C0 {
  error er0(bytes31 ep0);
  uint104   s0;
  int72[]   s1 = [int72(-116354487820127701893), int72(2361183241434822606847), int72(315711766340741085784), int72(2361183241434822606847), int72(2361183241434822606847)];

	function compareMemoryAndStorage(int72[] memory v1, int72[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  bool  public s2 = true;
  constructor(uint104 i0)   {
    s0 /= ((uint104(0) | uint104(9060821988934020919298340279888)) | ((uint104(0) & uint104(10198014532977506046083210984724)) - uint104(0)));
    {
    }
  }
  function f0(bool i0) private     returns(address payable o0)  {
    if (i0)
    {
      bool  l0 = s2;
      bool  l1 = l0;
      assert(l1 == s2);
      if (i0)
      {
        if (i0)
        {
          s1.push((int72(2361183241434822606847) | (true ? int72(((int72(2361183241434822606847) ^ int72(0)) / int72(2361183241434822606847))) : int72(382051027304938809884))));
          s1.pop();
        }
      }
      s1.push((((~((int72(((int72(0) + int72(2361183241434822606847)) / int72(-2079689163386905976987))) ^ int72(2361183241434822606847)))) * int72(0)) * int72(0)));
    }
    else if (i0)
    {
      bool  l2 = s2;
      bool  l3 = l2;
      assert(l3 == s2);
      if (i0)
      {
        assert(true);
        return (payable(address(this)));
      }
      else if (i0)
      {
        o0 = payable(address(this));
        assert(o0 == payable(address(this)));
        if (i0)
        {
          s1.push(int72(0));
          int72[] memory l4 = s1;
          int72[] memory l5 = l4;
          assert(compareMemoryAndStorage(l5, s1));
        }
      }
    }
  }
  receive() external virtual  payable
  {
    s1.pop();
    if ((((uint16(35047) < uint144(18080198529369706436860302714871425922357986)) ? payable(address(this)) : payable(address(this))) >= payable(address(this))))
    {
      s1[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] %= (int16(32767) & ((int72(-124877750949128721999) + int72(2361183241434822606847)) - int72(0)));
    }
    return;
  }
  int224 public constant cons0 = 0;
}
pragma solidity >= 0.0.0;
address payable constant cons1 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);

==== Source: su1.sol ====
function f2()      returns(bytes6[4] memory o0,bytes1 o1){
  return ([bytes6(0x000000000000), bytes6(0x645a5651c68e), bytes6(0x000000000000), bytes6(0x3a1ede94500d)], bytes1(0 f3 /*suffix expr*/));
}
int240 constant cons2 = 883423532389192164791648750371459257913741948437809479060803100646309887;
pragma solidity >= 0.0.0;
contract C1 {
  function f4() private     returns(address o0)  {
  }
  struct St0 {
    address el0;
    bool el1;
    bool el2;
    uint200 el3;
  }
  fallback() external virtual  
  {
    return;
  }
  struct St1 {
    bytes29 el0;
    int80[5] el1;
    address payable el2;
    bool el3;
  }
  mapping(int120 => address)  public s3;
  uint152   s4 = uint152(0);
  uint128   s5 = uint128(340282366920938463463374607431768211455);
  constructor()   {
    s3[(~(((int120(-33776226332475275883459546590973114) + (int120(0) % int120(0))) | int120(461708558589183518775134614853998322))))] = address(this);
    unchecked {
    }
  }
}
function f3(uint24 i0) pure suffix  returns(bytes12 o0)
{
}
// ====
// ----
