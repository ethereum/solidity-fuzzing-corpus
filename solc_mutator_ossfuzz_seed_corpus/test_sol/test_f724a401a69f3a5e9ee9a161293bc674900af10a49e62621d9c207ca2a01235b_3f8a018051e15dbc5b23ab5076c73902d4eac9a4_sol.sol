
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
error er0();

==== Source: su1.sol ====
contract C0 {
  fallback() external virtual  
  {
    if (((((uint200(414381374993760840274611828197450053300390209176113995630823) | (uint200(1126584249243370222566483803774882960088453964413954209842647) | uint200(1606938044258990275541962092341162602522202993782792835301375))) ^ uint200(73071059648629194722435978205121012588743945574548174140006)) ** uint80(uint80(1208925819614629174706175))) <= uint200(0)))
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffff"));
      do
      {
        return;
      }
      while (((-(((((int112(0) ^ int112(1444528609117895126314056339547995)) - int112(1233360413427615584382389223996923)) | int112(0)) % int112(-2058836662014223627567548210460384)))) == int112(2596148429267413814265248164610047)));
    }
  }
  function f1() private     returns(uint152 o0)  {
    (o0) = ((uint152(0) >> uint232((uint232(6901746346790563787434755862277025452451108972170386555162524223799295) ^ uint40(0)))));
    assert(o0 == (uint152(0) >> uint232((uint232(6901746346790563787434755862277025452451108972170386555162524223799295) ^ uint40(0)))));
  }
  int8  public s0;
  address payable   s1 = payable(address(this));
  constructor(int8 i0)   {
    s0 += int8(127);
    unchecked {
    }
  }
  struct St0 {
    bool el0;
    bytes31 el1;
  }
  function f2(address payable i0) private      {
    ((false ? true : true) ? [string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")] : [string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded")]);
  }
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
