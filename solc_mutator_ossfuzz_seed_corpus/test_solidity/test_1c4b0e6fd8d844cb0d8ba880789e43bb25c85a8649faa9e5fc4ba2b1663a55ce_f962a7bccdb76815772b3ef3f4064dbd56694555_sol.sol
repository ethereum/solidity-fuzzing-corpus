
==== Source: su0.sol ====
contract C0 {
  modifier m0() virtual
  {
    _;
    _;
    assembly
    {
      if 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        let al0 := sub(0, 0)
      }
      switch 115792089237316195423570985008687907853269984665640564039457584007913129639935
      case 0
      {
      }
      default
      {
        let al1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      }
      switch 0
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
      }
      case 106571764875236492955132138158395742733272830235535779307643546778620317810815
      {
      }
      case 115792089237316195423570985008687907853269984665640564039457584007913129639935
      {
        for 
        {
          let al2 := 72119882991595619290469651266849332182992469477076558644909885373005439378235
          al2 := al2
          {
            let al3 := al2
          }
        }
        115792089237316195423570985008687907853269984665640564039457584007913129639935
        {
        }
        {
          mstore(mod(mload(mod(mload(mod(38897093421977608000496918848860865192760466866965013421377747043187235528173, 2048)), 2048)), 2048), address())
          break
        }
        mstore(mod(0, 2048), 0)
      }
    }
  }
  struct St0 {
    bytes20 el0;
  }
  type T0 is uint24;
  bytes12 public constant cons0 = (bytes12(0x000000000000000000000000) ^ (((bytes12(bytes12(0xef169aad0150ba37906de3a7)) ^ bytes12(0x354eeb135c2ca3e53e715dfc)) | bytes12(0x000000000000000000000000)) ^ bytes12(0x6febcc0cc91ce2dcc35d9b2b)));
  receive() external   payable
  {
  }
  function f1() public virtual m0() 
  {
    payable(this).transfer(12998609128410753284);
    do
    {
      continue;
    }
    while ((true || (!(false))));
  }
  C0.T0   s0 = C0.T0.wrap(uint24(5389684));
  bytes14   s1;
  constructor(bytes14 i0) payable  {
    s1 &= bytes14(0xffffffffffffffffffffffffffff);
    unchecked {
      if ((((!(true)) || true) ? true : false))
      {
      }
      else
      {
        if (false)
        {
          bytes25 l0 = bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff);
        }
        else
        {
          s0 = C0.T0.wrap(uint24(0));
        }
      }
      revert("000000000000000000d0a84097643433830b943f57f2");
      for(      C0.St0 storage l1;
;
new bool[](1))
      {
        if (false)
        {
          this.f1();
        }
        bytes22 l2 = bytes22(0x8499f93dbf58a2730688f0abb3d330f57d8659a54eeb);
      }
      s1 &= bytes14(0x0000000000000000000000000000);
      if (false)
      {
      }
      else if ((((int192(3138550867693340381917894711603833208051177722232017256447) > int192(-462836433318153468116006946919429100797559984668379383160)) != false) && true))
      {
        bool l3 = (((~((int240(443985040746866864094646567894583563108439211523317005835559367983687564) | int240(0)))) < int240(0)) && true);
      }
    }
  }
  event ev0();
  modifier m1(bytes18 i0) 
  {
    _;
  }
  modifier m2(int208 i0,int248 i1) virtual
  {
    emit ev0();
    _;
  }
  modifier m3(uint40 i0) 
  {
    _;
  }
}
function f2(address payable i0)    
{
}
struct St1 {
  bool el0;
}
library L0 {
  function f3() internal   
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000008));
    unchecked {
    }
  }
  modifier m4() 
  {
    if (true)
    {
      if (false)
      {
        _;
      }
    }
  }
  event ev1();
}
uint176 constant cons1 = (((~((((uint176(95780971304118053647396689196894323976171195136475135) ** uint232(uint232(4588572271230364490192272348970831465260479806431012003502111623218))) * uint176(95780971304118053647396689196894323976171195136475135)) % uint176(95780971304118053647396689196894323976171195136475135)))) * uint176(0)) << uint168(uint168(188803200669676141575162073531601088013019073623342)));
pragma solidity >= 0.0.0;
// ====
// ----
