
==== Source: su0.sol ====
contract C0 {
  function f0(uint40 i0) external   payable  returns(address o0,int232 o1,bool o2)  {
    if (i0 < uint40(0))
    {
      if (i0 != uint40(((uint40(1099511627775) << uint96(uint96(79228162514264337593543950335))) / ((~(uint40(0))) % uint40(1099511627775)))))
      {
        for(        bytes16 l0 = (bytes2(0x0000) & bytes16(0x00000000000000000000000000000000));
;
)
        {
          break;
        }
        o2 = false;
        assert(o2 == false);
      }
      else if (i0 >= uint40(1099511627775))
      {
        (bool l1, bytes memory l2) = payable(this).call{value: 0}("");
      }
      if (i0 > ((((uint40(1099511627775) * (uint40(0) - uint40(121025683509))) - uint40(1099511627775)) - uint40(299320959352)) * uint40(599393755224)))
      {
        (o2) = (true);
        assert(o2 == true);
      }
      (bool l3, bytes memory l4) = payable(this).call{value: 3221426719082263830}("");
    }
    else
    {
      (bool l5) = payable(this).send(5218880414057483170);
    }
  }
  int224   s0;
  constructor(int224 i0)   {
    s0 |= int224((int224(((uint224(26959946667150639794667015087019630673637144422540572481103610249215) << uint152((uint152(0) << uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))))) ** uint16(uint16(61123)))) / int224(0)));
    unchecked {
      int224  l0 = s0;
      int224  l1 = l0;
      assert(l1 == s0);
    }
  }
  function f1(int224 i0) public virtual  payable   {
  }
  fallback() external   payable
  {
    return;
  }
}
pragma solidity >= 0.0.0;
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }




==== Source: su1.sol ====
function f3()      returns(int192 o0){
  return (((int192(1328471527973441575733678706750490325785593435231726083737) & (~(((int192(1539575376018306724443100444182672188060896012394024213440) - int192(3138550867693340381917894711603833208051177722232017256447)) % int192(0))))) ^ int192(3138550867693340381917894711603833208051177722232017256447)));
}
contract C1 {
  struct St0 {
    function (uint256, int16) external   el0;
    mapping(uint104 => bytes13) el1;
  }
  error er0();
  fallback() external virtual  
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("6e0e05e9384c122bd1757f342699cae7aba0cc0c1cffffffffffffffffffffffffffff"));
    (bool l2, bytes memory l3) = address(this).call(bytes("89348c9998842dffffffffffffffffff"));
  }
  function f5() external     returns(address o0,function () external   returns (bytes19) o1)  {
    require(false);
    for(uint solinit0 = 0; solinit0 < (uint256(34132217518713254861574643104489340960197421180860188856535573356885339442866) % 11); solinit0++)
    {
      if (true)
      {
        (bool l0, bytes memory l1) = address(this).call(bytes("0000000000000000000000000000000000"));
        if (true)
        {
          o0 = address(this);
          assert(o0 == address(this));
        }
      }
      (int192 l2) = f3();
    }
  }
  error er1(uint192 ep0);
  bytes27   s1;
  mapping(uint96 => address)  public s2;
  constructor(bytes27 i0)   {
    s1 = bytes27(0xffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    s2[(~(uint96(0)))] = address(this);
    unchecked {
    }
  }
  struct St1 {
    address payable el0;
    mapping(uint144 => mapping(bytes12 => uint104)) el1;
    int120 el2;
    bool el3;
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
