
==== Source: su0.sol ====
struct St0 {
  bool[] el0;
  bool el1;
}
pragma solidity >= 0.0.0;
contract C0 {
  function f0(uint64 i0) external      {
  }
  bytes28  public s0;
  uint24 immutable  s1 = uint24(0);
  bytes28   s2 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
  bytes1   s3 = bytes1(0xff);
  constructor(bytes28 i0)   {
    s0 = bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
    unchecked {
    }
  }
  event ev0();
}

==== Source: su1.sol ====
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



contract C1 {
  address immutable public s4 = address(this);
  int72  public s5 = int72(-1527321922155975829171);
  uint40 immutable  s6;
  constructor(uint40 i0) payable  {
    s6 = (uint40((uint104(3258313500055448321909954550274) * ((~(uint104(2315798881106455037448588482185))) + uint104(0)))) * uint40(250846210532));
    {
    }
  }
  error er0();
  event ev1() anonymous;
}
bytes18 constant cons0 = bytes18(0xffffffffffffffffffffffffffffffffffff);
pragma solidity >= 0.0.0;
// ====
// ----
