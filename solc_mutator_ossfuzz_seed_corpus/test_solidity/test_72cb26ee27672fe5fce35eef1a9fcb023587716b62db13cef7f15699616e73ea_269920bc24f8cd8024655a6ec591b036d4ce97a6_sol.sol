
==== Source: su0.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49
}
function f0()    
{
  {
  }
  bytes29 l0 = bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  f0();
}
pragma solidity >= 0.0.0;
error er0(uint136 ep0);
type T0 is bool;

==== Source: su1.sol ====
contract C0 {
  error er1();
  function f1(bytes calldata i0,bool i1) public virtual  
  {
  }
  function f2(function (uint256, address, address[1] memory) external   i0) public    returns(int184 o0,function (address payable, uint96) external   returns (uint16, function (bytes12, address, string memory) external   returns (bool, bool[] memory, bytes11)[] memory) o1)
  {
  }
  type T1 is bool;
  bool  public s0 = true;
  bool  public s1;
  uint224 immutable  s2 = uint224(16329260737250297728514640772040141102811981626520659905655792856014);
  constructor(bool i0)   {
    s1 = true;
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("0000000000000000000000000000000000000000ffffffffff");
      if ((!(true)))
      {
      }
      else if ((((~((int120(664613997892457936451903530140172287) + (int120(0) ^ int120(0))))) ** uint160(uint160(0))) != int120(-464145596705386604213394648075595937)))
      {
      }
      else if (true)
      {
        bool[2][2] storage l2;
        uint240 l3 = ((((((uint240(224925691882840305506801243180923682793787433078179815945986394045250357) - uint240(0)) + uint240(1706064162109592609756477617781468777823221955390593688666433775274655215)) << uint256(uint256(0))) >> uint240(uint240(0))) | uint240(0)) << uint184(uint184(20917071973782499938714084341361611111885275242398573828)));
      }
      function (address, bool) external   returns (function (uint64, bytes21, string memory) external   returns (bool), C0.T1) l4;
    }
  }
  modifier m0(C0.T1 i0,bytes21[2] memory i1) virtual
  {
    (bool l0, bytes memory l1) = address(this).call("d1dce344009921dc42743364ff08313f96726fbbfedf1f4dffffff");
    _;
  }
  modifier m1() virtual
  {
    if (true)
    {
      (bool l0, bytes memory l1) = address(this).call("d93355b4f2eae9a73537b80afb71fa8edc4cc7f71ef0629624c191ffffffffffffffffffffffffffff");
      revert er1();
      _;
    }
    else
    {
    }
  }
  event ev0();
  error er2(C0.T1 ep0, string ep1);
  struct St0 {
    string el0;
  }
}
type T2 is bytes7;
pragma solidity >= 0.0.0;
struct St1 {
  mapping(bytes1 => int224)[] el0;
}
library L0 {
  modifier m2() 
  {
    address l0 = address(0x0000000000000000000000000000000000000008);
    if (false)
    {
      _;
    }
    else
    {
    }
  }
  function f3(C0.St0 memory i0,function (int248, C0.T1) external   returns (bool[1] memory) i1,bool i2) external   
  {
    C0.St0(string("ffffff00000000000000000000000000000000000000000000"));
    assembly
    {
    }
    try i1(((((int248(157314233113073942123591705691938262352859705136144663142901106268852194339) + int248(0)) | int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) + int248(-136670813679500111794676545591329903262291699346884223691837050661372239792)) + int248(0)),C0.T1.wrap(false)) returns (bool[1] memory l0)
    {
      do
      {
        do
        {
          int224 l1 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
        }
        while ((!(false)));
        continue;
        break;
      }
      while (true);
    }
    catch
    {
    }
    catch Panic(uint256 l2)
    {
    }
  }
  function f4(C0.St0 memory i0) external  m2()  returns(function (function () external  , address payable, C0.T1) external   o0,uint112 o1,bytes20 o2)
  {
  }
  using L0 for *;
}
// ====
// ----
