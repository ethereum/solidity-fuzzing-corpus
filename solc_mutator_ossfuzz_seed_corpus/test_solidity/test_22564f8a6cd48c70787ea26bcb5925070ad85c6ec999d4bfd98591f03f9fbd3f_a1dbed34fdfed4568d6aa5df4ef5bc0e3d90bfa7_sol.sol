
==== Source: su0.sol ====
struct St0 {
  uint160 el0;
  function (function () external   returns (bytes16), bytes32) external   returns (bytes memory, uint248, uint168) el1;
  uint104 el2;
}
struct St1 {
  int232 el0;
  bytes7 el1;
  bool el2;
  mapping(bool => St0) el3;
}
contract C0 {
  function f0() public   payable  returns(function (int208) external   o0,St0 memory o1)  {
    if ((((uint16((uint16(((uint16(0) % uint16(0)) / uint16(13045))) / uint16(65535))) | uint16(19340)) ** uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))) != uint16(0)))
    {
      if (true)
      {
        if (((((uint104(2096998143018937613211194670183) | uint104(20282409603651670423947251286015)) << uint72(uint72(0))) ^ uint112(5192296858534827628530496329220095)) >= uint112(5081991130409736112641956577095964)))
        {
          return (o0, o1);
        }
        else if (false)
        {
          if (((bytes8(0xffffffffffffffff) <= bytes8(0xed1ee4edf17cd2da)) ? false : true))
          {
            (bool l0, bytes memory l1) = address(this).call(bytes("5fbfb88590f49981bd6e9e9cc431bc562b13655133f716ac3e0631084afbb9ce"));
          }
        }
      }
    }
  }
  function f1() external virtual  payable  returns(St0 memory o0)  {
  }
  function f2() external virtual     {
    0;
    if (true)
    {
      for(;
;
)
      {
        continue;
      }
    }
  }
  bool   s0 = true;
  struct St2 {
    St0 el0;
    address payable el1;
    uint40 el2;
    string el3;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28
}
pragma solidity >= 0.0.0;
// ====
// ----
