
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
int8 constant cons0 = int8(0);
function f0(bool i0,bytes memory i1)    
{
  assembly
  {
    let al0 := 57904450604277166774651153026572680202750088657836050910963517013893138817794
  }
}
struct St0 {
  mapping(address => uint192) el0;
  bool el1;
  address el2;
}

==== Source: su1.sol ====
function f1()    
{
}
pragma solidity >= 0.0.0;
type T0 is bool;
error er0();
library L0 {
  event ev0(uint16 indexed ep0);
  using L0 for *;
  error er1();
  function f2(uint24[2] memory i0,bytes29 i1,int184 i2) public   
  {
    while (true)
    {
      if (true)
      {
        continue;
      }
      else if (true)
      {
        assert(true);
        continue;
      }
      continue;
    }
    i2 %= int184(12259964326927110866866776217202473468949912977468817407);
    string memory l0 = "dbc5e1d172ec22fe7c17216d8056f1ff249ac6b979900fd56a400792f50da4b70f29";
  }
  function f3() external    returns(bool o0,address o1)
  {
  }
  bytes28 public constant cons1 = ((bytes28(0xc976767067219ae4b272af223f3d50bf802023663d5b3d961ae64589) | (bytes28(0x00000000000000000000000000000000000000000000000000000000) & (true ? bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) : bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff)))) | bytes28(0xb32b0f359a5e1ced2f0d59ac0078fab68f76c6815ad83f3d4e0a1da4));
  modifier m0() 
  {
    _;
  }
  type T1 is address payable;
  modifier m1() 
  {
    bytes memory l0 = abi.encodePacked(bytes16(bytes16(0xffffffffffffffffffffffffffffffff)), L0.T1(L0.T1.wrap(payable(address(0x0000000000000000000000000000000000000005)))), bytes32(bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)), uint256(((uint256(0) % uint256(0)) + uint256(0))));
    _;
    revert L0.er1();
    _;
    if ((((uint40(1099511627775) * (uint40(661485524515) + uint40(1099511627775))) | uint40(217559451044)) >= uint40(1099511627775)))
    {
      assembly
      {
        {
          let al1 := cons1
        }
      }
    }
    else if (true)
    {
      for(;
((!(false)) == (int128(((int128(37857401482838087576792079038456967550) % int128(0)) / int128(0))) != int128(170141183460469231731687303715884105727)));
true)
      {
        _;
        address payable l1 = payable(address(0x0000000000000000000000000000000000000005));
        break;
      }
      _;
      assembly
      {
      }
    }
    else
    {
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79

}
address payable constant cons2 = payable(address(((bytes20(address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF)) ^ (bytes20(address(0x0000000000000000000000000000000000000000)) | bytes20(address(0x0000000000000000000000000000000000000000)))) | bytes20(address(0x0000000000000000000000000000000000000000)))));
// ====
// ----
