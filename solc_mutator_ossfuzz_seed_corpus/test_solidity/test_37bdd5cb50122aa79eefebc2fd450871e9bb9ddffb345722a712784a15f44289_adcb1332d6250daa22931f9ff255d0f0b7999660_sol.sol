
==== Source: su0.sol ====
contract C0 {

	function compareMemoryAndCalldata(uint112[] memory v1, uint112[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f0(function (int200) external   returns (uint168) i0,uint112[] calldata i1) external     returns(function (bool, bool, bytes16) external   o0,function () external   returns (uint168, uint32, int184) o1)  {
    return (o0, o1);
  }
  event ev0();
  function f1() public     returns(int112[2] memory o0)  {
    return ([int112(-1529380049896402531964582170248101), int112(2596148429267413814265248164610047)]);
  }
  int176   s0;
  function (address, uint112) external  []  public s1;

	function compareMemoryAndStorage(function (address, uint112) external  [] memory v1, function (address, uint112) external  [] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  uint32 immutable  s2 = uint32(3241068558);
  constructor(int176 i0,function (address, uint112) external  [] memory i1)   {
    s0 *= int176(47890485652059026823698344598447161988085597568237567);
    s1 = i1;
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C1 {
  fallback() external virtual  
  {
  }
  function f3() public      {
    return;
  }
  int192   s3 = int192(3138550867693340381917894711603833208051177722232017256447);
  function f4(int192 i0,int192 i1) public virtual    returns(uint232 o0,function (int128, uint208, uint16) external   returns (bytes memory) o1,address payable o2)  {
    return (((uint232(4675298835129252199811570550198412844013596961707329935425012715116428) % uint232(0)) | (uint232(1770489634868959702288824442865217357097698973209240892158739460090350) + uint232(0))), o1, payable(address(this)));
  }
}
struct St0 {
  bool el0;
  uint80[] el1;
  mapping(bytes14 => address) el2;
}
struct St1 {
  function (bool[] memory) external   returns (address, bool) el0;
  int24 el1;
}
// ====
// ----
