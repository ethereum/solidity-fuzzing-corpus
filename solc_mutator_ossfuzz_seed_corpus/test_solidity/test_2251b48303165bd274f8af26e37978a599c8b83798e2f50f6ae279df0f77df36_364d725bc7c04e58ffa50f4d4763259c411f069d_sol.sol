
==== Source: su0.sol ====
bool constant cons0 = (true && (false || (true ? false : true)));
contract C0 {
  event ev0(string  ep0, address payable  ep1);
  modifier m0(uint104[] memory i0,uint240 i1) virtual
  {
    _;
  }
  error er0(string[] ep0);
  struct St0 {
    bytes25 el0;
    uint200 el1;
    address el2;
    function (uint192, int248) external   returns (uint224) el3;
  }
  function f0() external virtual m0(new uint104[](1),uint240(0))  returns(bool o0,int80 o1,int152 o2)
  {
  }
  mapping(address => int88)  public s0;
  int16  public s1 = int16(32767);
  C0.St0   s2;
  constructor() payable  {
    s0[address(ripemd160("ffffffffffffffffffffffa0444369"))] *= ((int88(154742504910672534362390527) * (int88(154742504910672534362390527) % int88(154742504910672534362390527))) | int88(154742504910672534362390527));
    {
      while ((bytes4(0xffffffff) <= bytes4(0xffffffff)))
      {
        assert(true);
      }
    }
  }
  event ev1(string  ep0);
  function f1() public   payable returns(uint32 o0)
  {
    try this.f0() returns (bool l0, int80 l1, int152 l2)
    {
      (s2.el2, s2.el1) = (address(this), s2.el1);
    }
    catch
    {
    }
    (bool l3, bytes memory l4) = address(this).call("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    if (false)
    {
    }
    else if (true)
    {
    }
    if ((((uint224(((uint224(26959946667150639794667015087019630673637144422540572481103610249215) << uint192(uint192(4559132025785416399567229301821283448499917950439934093136))) / uint224(26959946667150639794667015087019630673637144422540572481103610249215))) * uint224(26959946667150639794667015087019630673637144422540572481103610249215)) < uint224(26959946667150639794667015087019630673637144422540572481103610249215)) && true))
    {
      unchecked {
        revert er0(new string[](2));
      }
      (bool l5, bytes memory l6) = address(this).call(abi.encodeWithSelector(this.f0.selector));
    }
  }
}
type T0 is bool;
library L0 {
  function f2(function (string memory, uint128, bytes28) external   returns (bytes26) i0,uint200 i1) public   
  {
  }
  function f3(int232 i0) external    returns(C0.St0 memory o0)
  {
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25
  }
  bytes5 public constant cons1 = (bytes5(0x12efe34693) & bytes5(0xcbf6a8b662));
  error er1(address payable ep0);
  modifier m1(bytes5 i0) 
  {
    address payable l0 = payable(address(ripemd160("ffffffffffffffffffff000000000000000000000000000000")));
    for(    bytes3(0x76b3fb);
cons0;
)
    {
      _;
    }
    _;
  }
  modifier m2() 
  {
    _;
  }
  int160 public constant cons2 = int160(((((((int160(0) ** uint200(uint200(1606938044258990275541962092341162602522202993782792835301375))) & int160(362223551541498499558405996632268583338441810691)) % int160(-366889314605630945392071723802687235642839320211)) ** uint232(uint232(6901746346790563787434755862277025452451108972170386555162524223799295))) | int160(0)) / int160(730750818665451459101842416358141509827966271487)));
  type T1 is int184;
}
function f4(bool i0)     returns(int96 o0,function (int176, bool) external   returns (function (function () external   returns (bool[1] memory, uint120), int240, function (function () external   returns (function (C0.St0 memory, bool) external   returns (bool)), L0.T1) external  ) external   returns (int160, T0, int104), uint80, int200) o1)
{
  uint232 l0 = ((uint232((uint232(6901746346790563787434755862277025452451108972170386555162524223799295) / (uint232(299928286004189823691559332783245620854191939941872624797233957528530) >> uint16(uint16(42299))))) % uint232(6097010516841093975623932296584144748274207313809594995584277716562282)) >> uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)));
}
pragma solidity >= 0.0.0;
error er2();
struct St1 {
  C0.St0 el0;
}
// ====
// ----
