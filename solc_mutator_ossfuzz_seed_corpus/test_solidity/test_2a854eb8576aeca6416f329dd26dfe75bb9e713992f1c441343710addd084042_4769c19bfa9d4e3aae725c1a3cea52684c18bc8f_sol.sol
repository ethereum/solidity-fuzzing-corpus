
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  bytes el0;
  function (function () external  , uint256) external   returns (function (address, bool, uint104) external   returns (address payable), bool, function (bytes4[10] memory) external   returns (uint192, int224, function (bool) external  )) el1;
  bytes el2;
  bytes el3;
}

==== Source: su1.sol ====
struct St1 {
  function (int32, address, int96) external   returns (bytes memory, bool) el0;
  bytes2 el1;
  uint72 el2;
}
contract C0 {
  function f0() external virtual     {
  }
  function f1() external virtual     {
    try this.f1()
    {
      for(      bool l0 = true;
;
uint216(0))
      {
        (bool l1, bytes memory l2) = address(this).call((0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f2 /*suffix expr*/ ? 0x7859AF4DB72595C81238347B5B75a6c97c4607F4 f3 /*suffix expr*/ : bytes("8e07f8a65bc2acdf7022a212cfd70b6eca03f8eabbd8ca4fd6acd0053e5a849a")));
        do
        {
          (l0, l1) = (false, ((int88(-34128952887688555100574568) - int88(154742504910672534362390527)) == ((int88(136156287966035424067098359) ** uint64(uint64(0))) - int88(154742504910672534362390527))));
          assert(l0 == false);
          assert(l1 == ((int88(-34128952887688555100574568) - int88(154742504910672534362390527)) == ((int88(136156287966035424067098359) ** uint64(uint64(0))) - int88(154742504910672534362390527))));
          break;
        }
        while ((payable(address(this)) <= true f4 /*suffix expr*/));
        if (true)
        {
          (bool l3, bytes memory l4) = address(this).call(bytes("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
          do
          {
            if (true)
            {
              address(this);
              continue;
            }
            return;
          }
          while (true);
        }
        else if ((address(this) >= address(this)))
        {
          continue;
        }
      }
    }
    catch
    {
    }
  }
  bytes16   s0;
  constructor(bytes16 i0)   {
    s0 &= false f5 /*suffix expr*/;
    unchecked {
    }
  }
}
pragma solidity >= 0.0.0;
function f2(address i0) pure suffix  returns(bool o0)
{
}
function f3(address i0) pure suffix  returns(bytes memory o0)
{
  o0 = bytes("b0de7b79404d083adf028431d489955e7ad7727488ce0ccfa03af032f9db8a2affffffffffffffffffffffffff");
  assert(keccak256(bytes(o0)) == keccak256(bytes(bytes("b0de7b79404d083adf028431d489955e7ad7727488ce0ccfa03af032f9db8a2affffffffffffffffffffffffff"))));
  if (i0 <= address(0x0000000000000000000000000000000000000003))
  {
    while (false)
    {
      delete o0;
      for(uint solinit0 = 0; solinit0 < (uint256(108838342272379163107936013441256620158911917699899601730598226998618151893482) % 11); solinit0++)
      {
        break;
      }
      continue;
    }
    return (bytes("00000000000000000000000000"));
  }
}
function f4(bool i0) pure suffix  returns(address payable o0)
{
}
function f5(bool i0) pure suffix  returns(bytes4 o0)
{
}
// ====
// ----
