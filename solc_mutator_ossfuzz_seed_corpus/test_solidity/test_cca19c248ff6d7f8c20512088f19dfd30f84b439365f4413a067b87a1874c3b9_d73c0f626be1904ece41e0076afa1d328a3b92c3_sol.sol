
==== Source: su0.sol ====
struct St0 {
  uint256 el0;
  int120 el1;
}
pragma solidity >= 0.0.0;
struct St1 {
  int240 el0;
  mapping(bytes24 => address) el1;
  St0 el2;
}
contract C0 {
  function f0() public virtual    returns(uint256 o0)  {
    o0 &= uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935);
    if (true)
    {
      if ((address(this) >= address(this)))
      {
        o0 = (((uint256(0) | (uint256((uint256(0) / uint256(0))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & uint256(0)) * uint256(0));
        assert(o0 == (((uint256(0) | (uint256((uint256(0) / uint256(0))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) & uint256(0)) * uint256(0)));
        return (uint256(0));
      }
      else
      {
        (o0) = (uint256(77285109584479285749580484640636720170264836776225443657169062223058062647806));
        assert(o0 == uint256(77285109584479285749580484640636720170264836776225443657169062223058062647806));
        address payable l0 = payable(address(this));
      }
    }
  }
  error er0();
  receive() external   payable
  {
    for(uint solinit0 = 0; solinit0 < ((true ? uint256(0) : uint256((uint256(((uint256(0) ** uint72(uint72(1385296998026997877704))) / uint256(19023058720632106274812812601222350216105716870631655371905510734415043043495))) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)))) % 11); solinit0++)
    {
      bool l0 = true;
    }
  }

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(bytes calldata i0) external   payable  returns(bytes11 o0,bytes24 o1,uint248 o2)  {
    revert er0();
  }
  function f3() external virtual    returns(bytes memory o0)  {
    if ((int104(-3108211425031994121856047169134) > int104(359325725348436352459756014078)))
    {
    }
    else
    {
      try this.f3() returns (bytes memory l0)
      {
        o0 = bytes("ffffffffff000000000000");
        assert(keccak256(bytes(o0)) == keccak256(bytes(bytes("ffffffffff000000000000"))));
      }
      catch
      {
        revert er0();
      }
    }
  }
  St0  public s0;

	function compareMemoryAndStorage(St0 memory v1, St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}  St1   s1;

	function compareMemoryAndCalldata(St0 memory v1, St0 calldata v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}  function f4(St0 calldata i0,int80 i1) public   payable  returns(uint184 o0)  {
    revert er0();
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f5(address i0)      returns(bool o0,int48 o1){
  if (i0 < address(0x0000000000000000000000000000000000000007))
  {
    if (i0 >= address(0x0000000000000000000000000000000000000005))
    {
      revert(string("This is a really long string that must ideally be random but is currently hard coded"));
    }
    else
    {
      if (i0 == address(0x0000000000000000000000000000000000000006))
      {
      }
    }
    for(    bool l0 = true;
;
new bytes3[](7))
    {
      if (i0 >= address(0x0000000000000000000000000000000000000004))
      {
        continue;
      }
      address payable l1 = payable(address(bytes20(address(0x0000000000000000000000000000000000000000))));
      break;
    }
  }
}
struct St2 {
  address el0;
}
error er1();
// ====
// ----
