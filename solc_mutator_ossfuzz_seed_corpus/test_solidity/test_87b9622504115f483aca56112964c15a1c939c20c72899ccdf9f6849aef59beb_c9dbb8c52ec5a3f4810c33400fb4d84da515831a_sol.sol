
==== Source: su0.sol ====
contract C0 {
  event ev0(int112  ep0);
  error er0();
  address payable[]   s0 = [payable(address(0x0000000000000000000000000000000000000007)), payable(address(0x0000000000000000000000000000000000000001))];
  int160   s1 = int160(0);
  int112  public s2;
  address payable   s3;
  constructor(int112 i0,address payable i1)   {
    s2 += int112(2596148429267413814265248164610047);
    s3 = payable(address(this));
    {
      emit ev0(int112((int112(1392826007430775626492641412973651) / int112(2596148429267413814265248164610047))));
      revert er0();
    }
  }
  type T0 is bytes31;
  function f0(address i0,string calldata i1) external   payable returns(address o0,bytes memory o1,C0.T0 o2)
  {
    for(    bytes9 l0 = bytes9(0x000000000000000000);
(false || ((!(false)) || (int240(883423532389192164791648750371459257913741948437809479060803100646309887) >= int240(0))));
bytes21(0x8831d05efd44fb2e524fc5ad99b431c7e1f16b73d0))
    {
      s0.push(payable(address(this)));
      revert("d3c929a87f132f207e0594357ba50fb2cfaba83996a3e20f68db2ccf112d271f281d9f380b64");
      (s0, s0[1]) = ([payable(address(0x0000000000000000000000000000000000000004)), payable(address(0x0000000000000000000000000000000000000004))], payable(address(this)));
    }
  }
  event ev1(C0.T0  ep0);
  error er1();
  address payable public constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
  modifier m0() virtual
  {
    assert(true);
    s0.pop();
    _;
  }
}
bool constant cons1 = false;
pragma solidity >= 0.0.0;
library L0 {
  bool public constant cons2 = (!(true));
  function f1(bool i0,function (C0.T0, int224, bytes28) external   returns (int40, bytes6, string memory) i1) internal   
  {
  }
  function f2() external    returns(uint64 o0,bytes19 o1)
  {
    if (false)
    {
    }
    else if ((false && true))
    {
      bytes1 l0 = bytes1(0xff);
    }
    else
    {
    }
    if (false)
    {
      if (((((~(((uint112(5192296858534827628530496329220095) << uint64(uint64(9088464553617884393))) << uint184(uint184(0))))) * uint112(0)) >> uint192(uint192(0))) == uint112(4027307881263556816412864272120092)))
      {
      }
      else if (((uint72(4722366482869645213695) % uint72(4722366482869645213695)) < uint72(1398781128939389252053)))
      {
        assembly
        {
        }
      }
      else if ((true || false))
      {
        assert(true);
        address l1 = address(ripemd160("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"));
      }
    }
  }
  type T1 is int232;
  int48 public constant cons3 = (int48(140737488355327) % int48(140737488355327));
  function f3(int128 i0,bytes10 i1,address payable i2) private   
  {
  }
}
struct St0 {
  bool el0;
  string el1;
}
// ====
// ----
