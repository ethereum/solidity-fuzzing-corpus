
==== Source: su0.sol ====
type T0 is int136;
contract C0 {
  function f0() external    returns(bool o0)
  {
    {
    }
  }
  event ev0(uint32  ep0, function () external   returns (address payable, bytes15)  ep1);
  type T1 is bool;
  modifier m0() virtual
  {
    _;
  }
  function f1(C0.T1 i0,uint160 i1) public   payable returns(function () external   o0,address payable o1,address[1] memory o2)
  {
  }
  modifier m1() virtual
  {
    assembly
    {
    }
    require(true, "cb9923eacfdc21e00fd69457f1b969428920e209e2fac2b7592cc6e8dcffffffffffffffffffffffffff");
    assembly
    {
      return(sload(115792089237316195423570985008687907853269984665640564039457584007913129639935), mload(mod(call(31587989203698181045149634074320890708690420935521290514461094001998052791547, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 47949037019739593093050132615009921417423379610138315681613792858823177507134, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 2048)))
      {
        revert(115792089237316195423570985008687907853269984665640564039457584007913129639935, mload(mod(mload(mod(0, 2048)), 2048)))
        let al0 := 7382733937042894144607267634055216129405319836379571315857766203834317826059
      }
    }
    _;
  }
  uint48   s0;
  C0.T1   s1;
  constructor(uint48 i0,C0.T1 i1)   {
    s0 += (uint48((uint48(((uint48(((uint48(0) ** uint120(uint120(0))) / uint48(0))) ** uint96(uint96(15725787756960739913059338878))) / uint48(281474976710655))) / uint48(0))) & uint48(0));
    s1 = i1;
    unchecked {
      for(;
;
)
      {
        (bool l0, bytes memory l1) = address(this).call("0000000000000000000000000000000000000000000000000000000000");
        try this.f0() returns (bool l2)
        {
        }
        catch
        {
          bytes memory l3 = "ffffffffffffffffffffffffffffffffffffffffffffffffffff7058101c";
          continue;
        }
        catch Error(string memory l4)
        {
          (bool l5, bytes memory l6) = address(this).call("b53e7944c0d68e09c51e1418ad00ff");
          delete l5;
        }
        if (((((int176(47890485652059026823698344598447161988085597568237567) + (int176(-43013263214672359199758174974945360116730294633549935) ** uint72(uint72(4722366482869645213695)))) % int176(-21516959843350443899260626735053570353946358103738695)) | int176(0)) >= int176(0)))
        {
          break;
        }
      }
    }
  }
}
struct St0 {
  mapping(int176 => bytes3) el0;
  bool[] el1;
  bytes10 el2;
  T0 el3;
}
uint64 constant cons0 = ((((((uint64(0) & uint64(0)) & uint64(18446744073709551615)) ** uint40(uint40(939883005127))) % uint64(0)) << uint248(uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))) >> uint64(uint64(0)));
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
bytes16 constant cons1 = (false ? ((bytes16(0xffffffffffffffffffffffffffffffff) & bytes16(0x4e88fc44cfaae0cd1f52427a62e8922d)) & bytes16(0x00000000000000000000000000000000)) : bytes16(0xe45e0443fda3fcbc1c7b8f4d3f1027d0));
pragma solidity >= 0.0.0;
struct St1 {
  int248[] el0;
  string el1;
  uint144 el2;
  string el3;
}
// ====
// ----
