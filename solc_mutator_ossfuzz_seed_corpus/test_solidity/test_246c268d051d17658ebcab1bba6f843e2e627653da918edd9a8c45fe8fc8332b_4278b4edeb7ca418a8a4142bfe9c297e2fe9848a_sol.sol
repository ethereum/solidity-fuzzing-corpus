
==== Source: su0.sol ====
address constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
library L0 {
  int48 public constant cons1 = (int48(140737488355327) - ((((int48(140737488355327) & int48(44495125722251)) * int48(-127949353043478)) + int48(-21889374011961)) * int48(0)));
  function f0(int104 i0) external    returns(uint120 o0)
  {
  }
  function f1(address payable i0,function (bytes1, address payable) external   i1,uint24 i2) external    returns(function (int184, bool, uint160) external   returns (string memory) o0)
  {
    int256 l0 = int256(((int256(((int256(22519186316692685519952297431966939818985883659751187129940391535298472888467) * int256(0)) / int256(0))) % int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) / int256(0)));
  }
  function f2() internal   
  {
  }
  using L0 for *;
  error er0();
}
function f3(bytes20 i0)    
{
  revert("bfa2f7d2ffffffffffffffffffffffffffffffffffffffff");
  revert L0.er0();
}
pragma solidity >= 0.0.0;
using L0 for uint;

==== Source: su1.sol ====
import "su0.sol";
using L0 for uint;
function f4(int96 i0,function (uint152, bytes21) external   returns (uint208, bool) i1)    
{
}
pragma solidity >= 0.0.0;
error er1(bool ep0);
contract C0 {
  receive() external   payable
  {
    unchecked {
      payable(this).transfer(769011647798385496);
      if ((bytes19(0x2b0985638f0bea773b9f1cb2474054f30e8c2e) > bytes19(0xe9304ada7817626437345b2f92c48ea7c7950b)))
      {
        uint168 l0 = uint168(0);
      }
      else
      {
      }
      return;
    }
  }
  type T0 is address payable;
  using L0 for *;
  uint192 public constant cons2 = (uint192((uint192(958530334885818881838278191874527468072077736287500992976) / (((uint192(0) % uint192(6277101735386680763835789423207666416102355444464034512895)) >> uint144(uint144(0))) ^ uint192(4524869005750465533631770856576351477681772432173293621173)))) & uint192(0));
  event ev0(bytes  ep0);
  modifier m0(int24 i0) 
  {
    if (((true || true) && true))
    {
      emit ev0(bytes("45d6890ebcebc7a8d6fd01fe475e49f623e584ae3a5ddc0c7deb8b910161bfdd75ea11"));
      if (true)
      {
        { }
        _;
      }
    }
    else if (true)
    {
    }
    else
    {
      bool l0 = false;
    }
    revert er1(false);
    _;
    _;
  }
  fallback() external  m0(((((int24(8388607) + int24(2303775)) ^ int24(-1721870)) + int24(6084406)) | int24(0))) 
  {
    if ((!(false)))
    {
      if (false)
      {
        return;
        do
        {
          if (true)
          {
          }
          else if (true)
          {
            revert er1(false);
          }
        }
        while (false);
      }
    }
    else if (true)
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 11026399165170335223}("");
      (bool l2, bytes memory l3) = payable(this).call{value: 832195352228890098}("");
    }
  }
  modifier m1(bool i0) 
  {
    bool l0 = (!((bytes1(0x9f) > bytes1(0xff))));
    _;
    payable(this).transfer(14976049931931336421);
    emit ev0(bytes("ffffffffffffffffffffffffffe5c293"));
  }
  bool  public s0 = false;
}
struct St0 {
  uint160 el0;
  int136 el1;
}
// ====
// ----
