
==== Source: su0.sol ====
contract C0 {
  function f0() external      {
    return;
  }
  int104   s0;
  bytes   s1 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2c0074a88bc42eabd6fe901d2811bc");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  constructor(int104 i0)   {
    s0 ^= (((((int104(0) ^ int104(0)) % int104(0)) & int104(10141204801825835211973625643007)) ** uint184(uint184(24519928653854221733733552434404946937899825954937634815))) ** uint16(uint16(19712)));
    unchecked {
    }
  }
  error er0();
  uint96 public constant cons0 = 53299528822252709019010234959;
  receive() external virtual  payable
  {
    try this.f0()
    {
      if ((payable(address(this)) >= payable(address(this))))
      {
        (s1) = (bytes("00000000000000000000000000000000000000000000000000000000000000000000"));
        assert(keccak256(bytes(s1)) == keccak256(bytes(bytes("00000000000000000000000000000000000000000000000000000000000000000000"))));
        s1.pop();
      }
      else
      {
        while (true)
        {
          continue;
        }
        require(true);
      }
      do
      {
        this.f0();
        continue;
      }
      while (true);
      if (true)
      {
        if (false)
        {
          try this.f0()
          {
            (bool l0, bytes memory l1) = payable(this).call{value: 17041559581389551525}("");
            (s0) = (((int104(10141204801825835211973625643007) + (int104(((~(int104(0))) / int104(0))) % int104(-8630604476310748145343275225040))) % int104(0)));
            assert(s0 == ((int104(10141204801825835211973625643007) + (int104(((~(int104(0))) / int104(0))) % int104(-8630604476310748145343275225040))) % int104(0)));
          }
          catch
          {
            if (true)
            {
            }
            else
            {
              try this.f0()
              {
                if ((payable(address(this)) >= payable(address(bytes20(address(0xBB7289Bd5207A595572BF11Ac8C18A19b5D0ec01))))))
                {
                }
                int104  l2 = s0;
                int104  l3 = l2;
                assert(l3 == s0);
              }
              catch
              {
                this.f0();
              }
            }
          }
        }
      }
      else if (true)
      {
      }
    }
    catch
    {
    }
    catch Panic(uint256 l4)
    {
    }
  }
}
struct St0 {
  address payable el0;
  address el1;
  int256 el2;
}
pragma solidity >= 0.0.0;
error er1(address payable ep0);

==== Source: su1.sol ====
contract C1 {
  int72 immutable public s2 = int72(-1472166039619346272904);
  bytes4  public s3 = bytes4(0xffffffff);
  error er2(bytes31 ep0);
  function f2() public   payable  returns(uint80 o0)  {
  }
  function f3(bytes4 i0,bytes4 i1) external virtual     {
    bytes4  l0 = s3;
    bytes4  l1 = l0;
    assert(l1 == s3);
  }
}
error er3(uint48 ep0);
function f4(address payable i0,bytes23 i1)     {
  revert er3((((uint48(0) ** uint56((uint56((uint56(0) / uint56(72057594037927935))) ** uint80(uint80(0))))) * uint48(281474976710655)) % uint48(260211237623144)));
}
pragma solidity >= 0.0.0;
struct St1 {
  uint240 el0;
  bool el1;
}
// ====
// ----
