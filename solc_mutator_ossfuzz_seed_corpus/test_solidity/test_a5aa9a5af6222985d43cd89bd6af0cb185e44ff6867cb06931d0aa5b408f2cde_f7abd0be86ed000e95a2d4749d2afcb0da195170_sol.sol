==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(bytes5 i0,uint32 i1) public   payable   {
    for(    string("This is a really long string that must ideally be random but is currently hard coded");
;
)
    {
      for(uint solinit0 = 0; solinit0 < (((uint256(65420532709725339429346323773987889766860661737091094524421518357320456235700) * uint256(65684695881582520970189287371625783280291926668872061958712198205428617462793)) | ((uint256(0) ^ uint256(0)) % uint256(62833150014912327234874164027780539982654128713866528322359866375318826787637))) % 11); solinit0++)
      {
        (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
        if (i1 > uint32(4294967295))
        {
        }
        else
        {
          for(          address payable l2 = true f1 /*suffix expr*/;
;
)
          {
            break;
          }
          return;
        }
        (i0) = (bytes5(0x79c24c8f4e));
        assert(i0 == bytes5(0x79c24c8f4e));
        continue;
      }
    }
  }
  event ev0();

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(string calldata i0,uint8 i1) private      {
    int248 l0 = ((((((int248(226156424291633194186662080095093570025917938800079226639565593765455331327) - int248(-125630498259453218622829189418467097712862906950953392470670276255211742373)) & int248(166575765651509399635431756458032935110840037673254018219680144397695501810)) % int248(0)) + int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) * int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) ** uint24(uint24(0)));
    string memory l1 = i0;
    assert(compareMemoryAndCalldata(l1, i0));
  }
  error er0();
  mapping(int112 => function () external   returns (bool, bytes18, bool)[5])[]   s0;
}
function f1(bool i0) pure suffix  returns(address payable o0)
{
  if (i0)
  {
    return (payable(address(0x0000000000000000000000000000000000000007)));
  }
  else
  {
    int16 l0 = true f3 /*suffix expr*/;
  }
}
function f3(bool i0) pure suffix  returns(int16 o0)
{
  return (((~(int16(32767))) ^ (int16(32767) - int16(-15257))));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f4(function (int40, bool) external   returns (uint16, bytes22, uint32) i0,string memory i1)     {
  if (bytes(i1).length != uint256(0))
  {
    return;
  }
}
// ----
// Warning 6133: (su0.sol:108-202): Statement has no effect.
// Warning 2072: (su0.sol:590-597): Unused local variable.
// Warning 2072: (su0.sol:599-614): Unused local variable.
// Warning 2072: (su0.sol:855-873): Unused local variable.
// Warning 5667: (su0.sol:1306-1314): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1335-1344): Unused local variable.
// Warning 2072: (su0.sol:2173-2181): Unused local variable.
// Warning 5667: (su0.sol:2227-2234): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su1.sol:38-108): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:1275-1898): Function state mutability can be restricted to pure
// Warning 2018: (su1.sol:26-192): Function state mutability can be restricted to pure
