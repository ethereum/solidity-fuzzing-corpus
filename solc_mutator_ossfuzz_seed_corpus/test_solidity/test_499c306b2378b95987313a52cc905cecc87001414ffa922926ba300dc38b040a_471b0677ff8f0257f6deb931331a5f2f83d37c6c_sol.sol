
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  error er0();
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37, M38, M39,
    M40, M41, M42, M43, M44, M45, M46, M47,
    M48, M49, M50, M51, M52, M53, M54, M55,
    M56, M57, M58, M59, M60, M61, M62, M63,
    M64, M65, M66, M67, M68, M69, M70, M71,
    M72, M73, M74, M75, M76, M77, M78, M79,
    M80, M81, M82, M83, M84, M85, M86, M87,
    M88
  }
  error er1();
  struct St0 {
    address el0;
    bytes2 el1;
  }
  type T0 is int184;
  receive() external   payable
  {
  }
  bytes31  public s0;
  address payable   s1;
  C0.St0   s2 = C0.St0(address(0x0000000000000000000000000000000000000005), bytes2(0x0000));
  constructor(bytes31 i0,address payable i1) payable  {
    s0 |= bytes31(0x1a8ae048d00a0059a267a4fdc0547ea103df722f9fc72225c565acee4dd425);
    s1 = payable(address(this));
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 13146411428432126928}("");
      unchecked {
        revert er1();
        payable(this).transfer(12716975179276834425);
        do
        {
          for(;
false;
C0.St0(address(0x0000000000000000000000000000000000000002), bytes2(0x0000)))
          {
            while (false)
            {
              C0.T0 l2 = C0.T0.wrap(int184(7584634303625170977334182154481080414664390879709760115));
            }
          }
          s0 |= i0;
        }
        while ((C0.EN0(uint8(1)) > C0.EN0.M44));
      }
      (l0) = payable(this).send(14586544592721577186);
      (s2.el1, s2.el0, s2.el1) = (bytes2(0xffff), address(this), bytes2(0xffff));
      (bool l3) = payable(this).send(12081967292753034586);
      if (false)
      {
      }
      else if ((((uint200(0) ^ (uint200(812009951716181673893676487850390339505912751721447099980809) & uint200(0))) << uint128(uint128(0))) != uint200(0)))
      {
        s0 ^= bytes31(0x00000000000000000000000000000000000000000000000000000000000000);
      }
      else
      {
      }
    }
  }
  event ev0(int32  ep0, function (bytes20, C0.T0, C0.EN0) external   returns (bytes25, function (int40, C0.T0, function () external   returns (uint216, C0.EN0, bytes12)) external   returns (C0.T0, uint112), bytes30)  ep1);
  fallback() external virtual  
  {
    if ((true ? false : true))
    {
    }
    else if (false)
    {
      assembly
      {
      }
    }
    else
    {
      if (((bytes15(0xffffffffffffffffffffffffffffff) < bytes15(0x95e77666e9ea273acbe570c109cb69)) && false))
      {
      }
      else if ((((!((bytes1(0xff) != bytes1(0x00)))) && true) || true))
      {
        for(        C0.St0(address(0x0000000000000000000000000000000000000006), bytes2(0xffff));
true;
)
        {
        }
        return;
      }
      else if (false)
      {
      }
    }
    function (bool, function (bytes9, int240) internal   returns (C0.St0 memory, int136, address payable)) internal   l0;
    s2.el1 ^= bytes2(0xffff);
  }
  uint32 public constant cons0 = ((((((uint32(1499765708) >> uint40(uint40(1099511627775))) % uint32(2942074594)) << uint224(uint224(13478131157750835945323760624085897827059339752484662106128739255798))) ^ uint32(0)) & uint32(0)) + uint32(4294967295));
}
error er2();
// ====
// ----
