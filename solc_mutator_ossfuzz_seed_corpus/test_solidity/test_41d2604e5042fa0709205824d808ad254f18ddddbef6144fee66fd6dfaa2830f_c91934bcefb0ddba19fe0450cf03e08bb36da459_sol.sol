
==== Source: su0.sol ====
struct St0 {
  mapping(int80 => bytes6) el0;
  bytes11 el1;
  function (address, address) external   returns (bytes31, uint160, bytes2) el2;
  bytes1 el3;
}
address constant cons0 = 0xf1237C501a29A5e3E7ed296dD2AE6e306aE30755;
library L0 {
  function f0() external    returns(uint224 o0,bytes memory o1)
  {
  }
  modifier m0() 
  {
    _;
    do
    {
      _;
    }
    while ((uint224(26959946667150639794667015087019630673637144422540572481103610249215) <= (uint224(5732312804602590409990193364614630139658304734974595905374435106416) + uint224(((uint224(0) ** uint40(uint40(0))) / uint224(0))))));
  }
  address public constant cons1 = cons0;
  modifier m1() 
  {
    _;
  }
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31

  }
  function f1() private  m1()  returns(function () external   returns (uint160, bool) o0,int112 o1)
  {
    L0.EN0[2] memory l0 = [L0.EN0(uint8(255)), L0.EN0.M14];
    if (true)
    {
      l0[0] = L0.EN0.M2;
      do
      {
        assembly
        {
          for 
          {
            o1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
            switch mload(mod(l0, 2048))
            case 115792089237316195423570985008687907853269984665640564039457584007913129639935
            {
              l0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
            }
          }
          cons1
          {
            for 
            {
            }
            l0
            {
            }
            {
              for 
              {
              }
              0
              {
                let al0 := cons0
              }
              {
              }
              o1 := 43566195822306502422809249668895306434115912308475320103561463883068629502202
              switch div(99162689498097912585949156044218654041296612593598871661550395279344163788910, 0)
              default
              {
              }
            }
          }
          {
            o1 := cons0
            break
            o1 := l0
            o1 := create2(o1, 32349493385209770667525455986429613898718315964737454561619705590044604460352, 27522526643538209593898025172511107675732377053391500864192900727681963145843, 47818222192617278344770161254711594108865498930083509202452813805217391818280)
            break
          }
          stop()
        }
        l0[1] = L0.EN0(uint8(19));
      }
      while (((l0[0] > L0.EN0.M4) || ((uint104(20282409603651670423947251286015) == uint104(20282409603651670423947251286015)) && false)));
    }
    else
    {
      require(false, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
      assembly
      {
        selfdestruct(mload(mod(cons0, 2048)))
        switch 7229328418598109473430452894163939359340838374644778743683140681873187090258
        default
        {
          {
          }
        }
        l0 := mload(mod(71364518164839761545018008071943113521401173634162800375946532428119639920633, 2048))
      }
    }
  }
}
pragma solidity >= 0.0.0;
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32
}
error er0();
type T0 is address payable;
// ====
// ----
