
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(bool i0,address i1) public virtual  payable  returns(uint144 o0,string memory o1)  {
    if (i0)
    {
      if (i1 == address(this))
      {
        return ((((((int56((int56(0) / int56(-17881815504185198))) > int56(-33835588994101682)) == true) ? uint144(18785857827600489298414557114892043512747037) : uint144(22300745198530623141535718272648361505980415)) & uint144(1983908372412032710125540818445785562490640)) % uint144(15371755841720335988162252366878623592383929)), string("This is a really long string that must ideally be random but is currently hard coded"));
      }
    }
    else
    {
      if (i0)
      {
      }
      else
      {
        if (i0)
        {
          if (i0)
          {
            o1 = string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string(bytes("18ecbb66be0453fa99418a9831101d664f968403c8cefbef6a85ffffffffffffffff")));
            assert(keccak256(bytes(o1)) == keccak256(bytes(string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string(bytes("18ecbb66be0453fa99418a9831101d664f968403c8cefbef6a85ffffffffffffffff"))))));
            return (uint144(9025059392920539858419406038911318156412475), string("This is a really long string that must ideally be random but is currently hard coded"));
          }
        }
        else
        {
          if (i1 == msg.sender)
          {
            for(            function (string memory, int200) external   returns (address payable, bytes3) l0;
;
)
            {
              return (((true ? (((uint144(22300745198530623141535718272648361505980415) ^ uint144(22300745198530623141535718272648361505980415)) ^ uint144(22300745198530623141535718272648361505980415)) & uint144(13759056872267215937624778439789207421165669)) : uint144(0)) % uint144(22300745198530623141535718272648361505980415)), string("This is a really long string that must ideally be random but is currently hard coded"));
            }
          }
          bool l1 = false;
          (bool l2, bytes memory l3) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffae60148961212dfb75e0a9216b1e33e054a6bae1a5d224139a6c3a47a72077"));
        }
      }
    }
  }
  error er0(int256 ep0);
  address payable   s0 = payable(address(this));
  int160[]   s1 = [int160(730750818665451459101842416358141509827966271487)];

	function compareMemoryAndStorage(int160[] memory v1, int160[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  mapping(bool => mapping(int88 => mapping(int72 => uint24)[]))   s2;
  bytes28  public s3 = bytes28(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  constructor()   {
    unchecked {
    }
  }
  type T0 is uint16;
  fallback() external   
  {
    revert er0((int256(0) - (int256(((int256((int256(-51291293689883790075359685202749851389122370480652846284512664339528917580128) / int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) - int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) / int256(57896044618658097711785492504343953926634992332820282019728792003956564819967))) - int256(0))));
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  address[] el0;
}
// ====
// ----
