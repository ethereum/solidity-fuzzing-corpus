
==== Source: su0.sol ====
struct St0 {
  uint248 el0;
}
contract C0 {
  fallback() external virtual  
  {
    while (false)
    {
    }
    if (((~((int56(26339544764710981) + ((int56(-8593066895274547) - int56(0)) | int56(36028797018963967))))) <= int56(36028797018963967)))
    {
    }
  }

	function compareMemoryAndCalldata(address[] memory v1, address[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f1(address[] calldata i0,bool i1) public virtual  payable  returns(bool o0)  {
    uint8 l0 = (uint8(0) + uint8(0));
    address[] memory l1 = i0;
    assert(compareMemoryAndCalldata(l1, i0));
  }
  int48  public s0 = int48(140737488355327);
  int240   s1 = int240(883423532389192164791648750371459257913741948437809479060803100646309887);
  bool immutable public s2;
  constructor(bool i0) payable  {
    s2 = false;
    unchecked {
    }
  }
  function f2() internal     returns(St0 memory o0)  {
    int240  l0 = s1;
    int240  l1 = l0;
    assert(l1 == s1);
  }
  struct St1 {
    uint200 el0;
    St0 el1;
    function () external   el2;
    int200 el3;
  }
}
contract C1 is C0 {
  struct St2 {
    int24 el0;
  }
  function f3() external virtual    returns(string memory o0,string memory o1)  {
    if (((uint16(65535) - ((uint16(37432) ^ uint16(46317)) % uint16(0))) != uint16(0)))
    {
    }
    else if (true)
    {
    }
  }
  int8   s3;
  mapping(bytes10 => int240)   s4;
  bool   s5 = false;
  constructor(int8 i0) payable C0(true)
  {
    s3 |= int8(0);
    s4[bytes10(0x00000000000000000000)] %= int240(883423532389192164791648750371459257913741948437809479060803100646309887);
    unchecked {
    }
  }
  function f4() external virtual    returns(function () external   returns (uint136) o0,C0.St1 memory o1)  {
    (bool l0, bytes memory l1) = address(this).call(abi.encodePacked(uint64(((uint64((int64(9223372036854775807) % int64(9223372036854775807))) - uint64(0)) % uint64(0))), bytes1(bytes1(0xe6))));
  }
  function f1(address[] calldata i0,bool i1) public virtual override  payable returns(bool o0)
  {
    if (i1)
    {
      require(true);
      o0 = true;
      assert(o0 == true);
    }
  }
  fallback() external virtual override  
  {
    return;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St3 {
  bool el0;
  bytes2 el1;
  bool el2;
  function () external   el3;
}
// ====
// ----
