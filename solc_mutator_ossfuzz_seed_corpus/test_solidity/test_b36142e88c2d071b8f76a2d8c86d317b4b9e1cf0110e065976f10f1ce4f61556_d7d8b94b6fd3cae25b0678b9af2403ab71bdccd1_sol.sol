
==== Source: su0.sol ====
contract C0 {
  uint240  public s0 = uint240(194138712611718093673755714655093575911102752290202698512813132659548284);
  uint96   s1 = uint96(0);
  receive() external virtual  payable
  {
    (s1) = (uint96(64638577257270004488626110620));
    assert(s1 == uint96(64638577257270004488626110620));
  }
  error er0(function (int96, uint216) external   returns (address) ep0);
  function f1(uint240 i0,uint96 i1) public virtual    returns(bytes29 o0,bool o1)  {
    o1 = true;
    assert(o1 == true);
    uint240  l0 = s0;
    uint240  l1 = l0;
    assert(l1 == s0);
    return (bytes29(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffff), (bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) < (bytes32(0xba6b515e93458345ca76d74e2773af97b432fb8b4ed90a3003349596dab467ae) & bytes32(0x4fc85e08d05e8eb70ca75d5b7c667f91eb25592c2f20704269d22fd4f5002c5b))));
  }
}
struct St0 {
  function (string memory, bytes4) external   returns (uint192) el0;
  address el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f2(string calldata i0,uint80 i1) external virtual  payable   {
  }
  struct St1 {
    int168 el0;
    uint208 el1;
    int40 el2;
    mapping(bytes19 => int200) el3;
  }
  bytes  public s2 = bytes("ffffffffffffffffffffffffff9d2f5a5ef21fbda2");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  int256   s3 = int256(0);
  bytes17   s4 = bytes17(0xffffffffffffffffffffffffffffffffff);
  address payable  public s5;
  constructor(address payable i0)   {
    s5 = payable(address(this));
    unchecked {
    }
  }
}
bool constant cons0 = false;
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
