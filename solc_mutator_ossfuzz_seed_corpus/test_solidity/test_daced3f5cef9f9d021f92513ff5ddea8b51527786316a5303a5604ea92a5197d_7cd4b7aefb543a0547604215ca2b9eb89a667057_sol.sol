
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int216 el0;
  int256 el1;
  mapping(bool => int152) el2;
}
function f0(bytes16 i0,function (bool, address payable) external   returns (address payable, int72) i1)     {
  for(;
(false == (payable(address(0x0000000000000000000000000000000000000001)) > payable(address(0x0000000000000000000000000000000000000006))));
)
  {
    for(uint solinit0 = 0; solinit0 < ((((uint256((payable(address(0x0000000000000000000000000000000000000007)).balance / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % uint256(0)) - uint256(14717479227155431478275291648880035768257683944777470908913241914744693953242)) % 11); solinit0++)
    {
      do
      {
        continue;
      }
      while (false);
      for(      bytes28 l0 = bytes12(0x4542365aa332c6d3cd9731c6);
true;
(((((uint96(0) & uint96(79228162514264337593543950335)) | uint96(79228162514264337593543950335)) << uint96(uint96(0))) | uint96(79228162514264337593543950335)) > uint96(73437817662521110337997523882)))
      {
        try i1(false,payable(i1.address)) returns (address payable l1, int72 l2)
        {
          break;
        }
        catch
        {
          for(uint solinit1 = 0; solinit1 < (true f1 /*suffix expr*/ % 11); solinit1++)
          {
            string memory l3 = string("This is a really long string that must ideally be random but is currently hard coded");
          }
          continue;
        }
        if (i0 < bytes16(0x3cee175b99f9bebe86f490f44dd66266))
        {
        }
      }
    }
  }
}
function f2(function (int232) external   returns (bytes memory, address payable, uint208)[] memory i0,uint48[] memory i1)     {
  function (address[] memory) external   returns (uint248) l0;
  i1[(((((uint256(0) | uint256(37521928559746058064321892724494449953705660429765393229963383126101444424071)) ** uint256(uint256(51956338438219127239558590284682092529594648806766080923065487955837632623927))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint48(uint48(131292419299133)))] |= (~(uint48(22182762698306)));
}
error er0();
function f1(bool i0) pure suffix  returns(uint256 o0)
{
  if (i0)
  {
    uint256 l0 = uint256(((uint256(0) - (uint256(0) >> uint112((uint112(4301442900926262650436460836781428) << uint16(uint16(65535)))))) / uint256(66398674139686728732705946268560808984288762618313282410632140880843679774171)));
    for(    bytes26 l1 = bytes26(0x2c8899d522f98a98a28c2289a7cb2c33a2c4fe1943066b48a0d4);
;
((~(int24(0))) - int24((int24(8388607) / int24(-4547779)))))
    {
      require(true);
    }
  }
  else
  {
    return ((((uint256(0) >> uint144(uint144(20350948738615344537984419506280902531523943))) % (uint256(0) ^ uint256(45050068408767585067922538587878043166085848852461023846292274872199726643334))) >> uint240(uint240(0))));
  }
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
struct St1 {
  uint88 el0;
  bytes13 el1;
}
error er1(int40 ep0, int136[4] ep1);
// ====
// ----
