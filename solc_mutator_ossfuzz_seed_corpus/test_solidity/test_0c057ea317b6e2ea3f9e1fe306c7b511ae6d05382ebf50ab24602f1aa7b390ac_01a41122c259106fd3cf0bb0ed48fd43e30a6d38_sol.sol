
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0() external   payable  returns(bytes memory o0,int200 o1,function () external   returns (bytes16, address) o2)  {
  }
  struct St0 {
    bool el0;
  }
  int176   s0;
  C0.St0  public s1 = C0.St0(false);

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  mapping(bool => address)   s2;
  uint120   s3 = uint120(0);
  constructor(int176 i0)   {
    s0 *= (((-((-((int176(47890485652059026823698344598447161988085597568237567) % int176(0)))))) + int176(47890485652059026823698344598447161988085597568237567)) ** uint136(uint136(87112285931760246646623899502532662132735)));
    s2[true] = address(this);
    {
      if (i0 < ((int176(-5368308234196914674465167251176604341071869762488940) * (int176(0) % int176(0))) & int176(47890485652059026823698344598447161988085597568237567)))
      {
        (s1.el0, s1.el0) = (hex"c7fBc6400d2C29dee2a96eB519C30B3a24419011" f1 /*suffix expr*/, true);
        assert(s1.el0 == hex"c7fBc6400d2C29dee2a96eB519C30B3a24419011" f1 /*suffix expr*/);
        assert(s1.el0 == true);
        int176  l0 = s0;
        int176  l1 = l0;
        assert(l1 == s0);
      }
    }
  }
}
struct St1 {
  bool el0;
  uint200[10] el1;
  bool el2;
}
function f1(bytes20 i0) pure suffix  returns(bool o0)
{
  if (i0 > (bytes20(address(0x0000000000000000000000000000000000000000)) & bytes5(0x75806dcc32)))
  {
    return (0 f2 /*suffix expr*/);
  }
  else
  {
    o0 = true;
    assert(o0 == true);
  }
}
function f2(uint168 i0) pure suffix  returns(bool o0)
{
}

==== Source: su1.sol ====
contract C1 {
  int88   s4 = int88(154742504910672534362390527);
  int176   s5 = int176(25318419621678478130468849920947220939147636885356345);
  bytes8   s6;
  constructor(bytes8 i0)   {
    s6 |= (bytes8(0x0000000000000000) | bytes8(0xffffffffffffffff));
    unchecked {
      if (i0 < hex"0000000000000000000000000000000000000000" f3 /*suffix expr*/)
      {
        if (i0 < bytes8(0xffffffffffffffff))
        {
          (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffff00000000000000000000000000000000000000000000000000"));
        }
        else
        {
        }
      }
    }
  }
  event ev0();
  struct St2 {
    bytes6 el0;
    bool el1;
    int128 el2;
  }
  struct St3 {
    function (function (int160, uint88) external   returns (bytes11, bytes29)[] memory, uint208, bytes6) external   returns (address) el0;
  }
  event ev1(C1.St3  ep0, bytes8  ep1);
}
struct St4 {
  address el0;
  int160 el1;
  bytes26 el2;
}
pragma solidity >= 0.0.0;
function f3(bytes20 i0) pure suffix  returns(bytes8 o0)
{
  (o0) = ((((bytes1(0x00) ^ bytes1(0x00)) ^ bytes1(0x00)) | bytes8(0x0000000000000000)));
  assert(o0 == (((bytes1(0x00) ^ bytes1(0x00)) ^ bytes1(0x00)) | bytes8(0x0000000000000000)));
}
// ====
// ----
