
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    int32 el0;
  }
  uint104  public s0 = uint104(0);
  bytes10   s1 = bytes10(0xffffffffffffffffffff);
  uint128  public s2 = uint128(340282366920938463463374607431768211455);
  receive() external virtual  payable
  {
  }
  function f1() external virtual    returns(int48[7][6] memory o0)  {
    return ([[int48(0), int48(-50037533387220), int48(-73904918359818), int48(140737488355327), int48(60903753188151), int48(-41386952651115), int48(124625143404002)], [int48(0), int48(0), int48(-123807023360624), int48(0), int48(0), int48(140737488355327), int48(140737488355327)], [int48(24631981880547), int48(140737488355327), int48(0), int48(140737488355327), int48(0), int48(0), int48(0)], [int48(140737488355327), int48(0), int48(59141408906395), int48(140737488355327), int48(0), int48(1440625253112), int48(-25535256058063)], [int48(51974294715192), int48(104386858102367), int48(0), int48(140737488355327), int48(37140882519213), int48(-70764792181350), int48(89691611836541)], [int48(0), int48(0), int48(0), int48(0), int48(140737488355327), int48(-130027686276305), int48(140737488355327)]]);
  }
  function f2(bytes10 i0,bytes10 i1,bytes10 i2) external   payable  returns(int160 o0)  {
    while (true)
    {
      if (i0 == bytes10(0x628056882e711b253b75))
      {
        int72(-787877486571994524894);
      }
      o0 -= (int160(730750818665451459101842416358141509827966271487) * int160(0));
      for(      address l0 = (true ? address(this) : msg.sender);
true;
)
      {
        break;
      }
      while (false)
      {
        if (i0 <= (i1 | bytes4(bytes25(0x00000000000000000000000000000000000000000000000000))))
        {
          if (i0 > bytes10(0xffffffffffffffffffff))
          {
            break;
          }
        }
        else if (i0 == (bytes10(0x897d99bf594b90072b41) | (true ? bytes10(0x69733d5093ab94688f88) : (bytes10(0xffffffffffffffffffff) | bytes10(0x00000000000000000000)))))
        {
          continue;
        }
        break;
      }
    }
  }
}
struct St1 {
  address payable el0;
}
function f3(address payable i0,bool i1)      returns(bytes30[] memory o0){
  (o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]) = (o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]);
  assert(o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)] == o0[uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)]);
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68
}
// ====
// ----
