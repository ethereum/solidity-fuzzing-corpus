
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()     {
}
contract C0 {
  function f1() private      {
  }
  error er0();
  function f2(uint216 i0) public virtual  payable  returns(function (bytes11) external   returns (bytes memory, address, int256)[] memory o0)  {
  }
  int256  public s0 = int256(0);
  fallback() external virtual  
  {
    s0 /= int256(57896044618658097711785492504343953926634992332820282019728792003956564819967);
    if ((true ? false : (((uint248(0) - uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)) | uint248(452312848583266388373324160190187140051835877600158453279131187530910662655)) == uint248(452312848583266388373324160190187140051835877600158453279131187530910662655))))
    {
      return;
    }
    else
    {
      do
      {
        (function (bytes11) external   returns (bytes memory, address, int256)[] memory l0) = this.f2({i0: uint216(103921234333006528696469006251931207427549176314874099454558851255)});
        continue;
      }
      while (false);
    }
    require(false, string(bytes("00000000000000000000000000000000ff")));
  }
}
contract C1 {
  receive() external virtual  payable
  {
    if (true)
    {
    }
    if (false)
    {
      if (false)
      {
        if (true)
        {
        }
        else
        {
          revert C0.er0();
        }
        return;
      }
      else if ((payable(address(this)) > (true ? payable(address(this)) : payable(address(this)))))
      {
        return;
      }
    }
  }
  address payable   s1;
  int248  public s2 = int248(226156424291633194186662080095093570025917938800079226639565593765455331327);
  mapping(bytes18 => mapping(address => bytes24))  public s3;
  int120 immutable public s4;
  constructor(address payable i0,int120 i1)   {
    s1 = payable(address(this));
    s4 = (true ? int120(0) : (~((int120(0) % int120(664613997892457936451903530140172287)))));
    unchecked {
    }
  }
  function f5() public      {
  }
  error er1();
  function f6() public virtual  payable   {
    (bool l0, bytes memory l1) = payable(this).call{value: 2656680533096574600}("");
    address payable  l2 = s1;
    address payable  l3 = l2;
    assert(l3 == s1);
  }
}

==== Source: su1.sol ====
struct St0 {
  address payable el0;
  uint224 el1;
}
pragma solidity >= 0.0.0;
function f7(address i0)     {
}
struct St1 {
  int56 el0;
  address payable el1;
}
import "su0.sol";
// ====
// ----
