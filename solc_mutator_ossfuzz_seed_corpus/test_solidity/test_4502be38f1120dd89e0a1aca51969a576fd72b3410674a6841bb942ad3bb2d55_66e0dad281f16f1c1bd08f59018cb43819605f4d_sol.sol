==== Source:  ====

==== Source: su0.sol ====
type T0 is address;
pragma solidity >= 0.0.0;
contract C0 {
  fallback() external   
  {
    do
    {
      while (false)
      {
      }
      assembly
      {
      }
    }
    while ((!((true && false))));
    address payable l0 = payable(address(this));
    return;
  }
  struct St0 {
    function (int112, bytes memory, T0) external   returns (bytes memory) el0;
    int72 el1;
    address payable el2;
    mapping(T0 => address[2]) el3;
  }
  modifier m0() virtual
  {
    _;
  }
  C0.St0   s0;
  int144  public s1;
  bool   s2;
  uint56   s3;
  constructor(int144 i0,bool i1,uint56 i2)   {
    s1 *= ((~((((int144(-4801520601591580979551855966168602030609507) + int144(11150372599265311570767859136324180752990207)) + int144(-7959917908638570890574908677687825564187779)) ^ int144(11150372599265311570767859136324180752990207)))) % int144(11150372599265311570767859136324180752990207));
    s2 = (int8(127) <= ((int8((int8((int8(0) / int8(127))) / int8(-45))) * int8(55)) ** uint64(uint64(18446744073709551615))));
    s3 &= uint56(((((uint56((uint56(0) / uint56(67986325281721281))) * uint56(72057594037927935)) + uint56(72057594037927935)) * uint56(0)) / uint56(34298113303037115)));
    unchecked {
      s0.el1 /= int72(0);
    }
  }
  error er0();
  function f1(function (T0, int224, function (uint8, function (bytes memory, int176, address) external   returns (string memory), T0) external   returns (uint168, bool, bool)) external   returns (int240, bytes10) i0) private  m0() 
  {
  }
  error er1();
  bool public constant cons0 = false;
  event ev0(uint24 indexed ep0) anonymous;
  event ev1(T0  ep0, int80  ep1) anonymous;
}
library L0 {
  error er2(address payable ep0);
  modifier m1(address payable i0,bool i1) 
  {
    _;
    if (true)
    {
      assert(true);
    }
    address payable l0 = payable(address(0x0000000000000000000000000000000000000006));
    _;
  }
  modifier m2() 
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000001));
    _;
  }
  using L0 for *;
}
bytes14 constant cons1 = bytes14(0xffffffffffffffffffffffffffff);
struct St1 {
  address payable el0;
  bool el1;
  uint48 el2;
}
function f2(address payable i0,T0 i1)     returns(function (int96, bytes17, bool) external   returns (address payable) o0)
{
}
// ----
// Warning 3149: (su0.sol:918-1018): The result type of the exponentiation operation is equal to the type of the first operand (int8) ignoring the (larger) type of the second operand (uint64) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 2072: (su0.sol:213-231): Unused local variable.
// Warning 5667: (su0.sol:564-573): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:574-581): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:582-591): Unused function parameter. Remove or comment out the variable name to silence this warning.
