
==== Source: su0.sol ====
struct St0 {
  address payable el0;
}
struct St1 {
  int192 el0;
  mapping(bool => uint104) el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
function f0(bool[] memory i0)      returns(bool o0){
  for(uint solinit0 = 0; solinit0 < (uint256((uint256((uint80((0 f1 /*suffix expr*/ / (uint80(978973530967153240093274) * uint80(1132703858563386599558365)))) << uint216(uint216(96913611021369367205844344523353520007249944203903871004925404330)))) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) % 11); solinit0++)
  {
    break;
  }
}
struct St2 {
  int248 el0;
}
pragma solidity >= 0.0.0;
struct St3 {
  function (St2 memory, function (bytes18[] memory) external  , uint96) external   returns (bool, string memory) el0;
  mapping(address => int232)[] el1;
  function (bool, bytes18, bytes29) external   returns (int160, St2 memory) el2;
}
function f1(int112 i0) pure suffix  returns(uint80 o0)
{
  if (i0 >= int112((((i0 ** uint168((true ? uint168(0) : uint168(374144419156711147060143317175368453031918731001855)))) ** uint32(uint32(4294967295))) / int112(2596148429267413814265248164610047))))
  {
  }
}
// ====
// ----
