
==== Source: su0.sol ====
library L0 {
  error er0(string ep0);
  using L0 for *;
  event ev0(bytes  ep0, uint128  ep1, bool indexed ep2);
  address public constant cons0 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;
  modifier m0() 
  {
    _;
  }
  bytes11 public constant cons1 = bytes11(0x120b6030dfcf0e3ad9940f);
  error er1(bytes23 ep0, int224 ep1);
}
struct St0 {
  bytes9 el0;
  uint16 el1;
  function () external   returns (bytes memory, bytes memory, bool) el2;
}
error er2();
contract C0 {
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10
  }
  event ev1();
  function f0(uint240 i0,function (bool, bytes6) external   returns (address, bytes memory) i1) external virtual  payable returns(bool o0,function (function (C0.EN0, function (function (St0 memory, uint56, bytes27) external   returns (address payable, bool)) external   returns (C0.EN0, uint200, function (function (bool, bytes21) external   returns (St0[1] memory)) external  )) external   returns (St0 memory), function (int96, C0.EN0, string memory) external   returns (uint72, bytes24, St0 memory), int128) external   returns (uint88) o1)
  {
    emit ev1();
    assembly
    {
      revert(0, 52469010825519390572630705750057870203014883058610839273924678493562145151726)
    }
  }
  function f1(bytes5 i0) external virtual  payable returns(int256 o0)
  {
  }
  receive() external virtual  payable
  {
    return;
  }
  modifier m1() 
  {
    _;
  }
  fallback() external   
  {
  }
  mapping(int120 => int80)  public s0;
  mapping(int240 => C0.EN0)   s1;
  address payable  public s2;
  constructor(address payable i0)   {
    s2 = payable(address(this));
    s0[(int120(664613997892457936451903530140172287) & int120(0))] |= (int80(604462909807314587353087) * int80(604462909807314587353087));
    s1[int240(635897839121613158451517545309976661312361116722377168148570055362499331)] = C0.EN0(uint8(9));
    unchecked {
      try this.f1(bytes5(0xe361367e47)) returns (int256 l0)
      {
      }
      catch
      {
      }
      catch Error(string memory l1)
      {
        if (false)
        {
        }
        else if (false)
        {
          (int256 l2) = this.f1({i0: bytes5(0x86702686fb)});
        }
        else if (true)
        {
        }
      }
      (int256 l3) = this.f1(bytes5(0xffffffffff));
    }
  }
}
type T0 is int160;
pragma solidity >= 0.0.0;
function f4(int128 i0)    
{
  assembly
  {
    i0 := sar(exp(115792089237316195423570985008687907853269984665640564039457584007913129639935, 80416220630578172065377290138711782745936855362761146015354853827697406907077), 0)
    for 
    {
    }
    eq(42324943648205181348517939115380056753192110622709190821545190533313245555588, 111702915094907441647558240704356715823158619589135255841964788837546756552261)
    {
    }
    {
      pop(call(i0, 0, 115792089237316195423570985008687907853269984665640564039457584007913129639935, 0, 0, 0, 39363187551924030037606401747218504056863476542830681227190097483117334113087))
      continue
      return(i0, address())
      stop()
      i0 := 1659547491248622712663512500580356483702926225165900983679965863583035413207
    }
  }
}
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59
}
// ====
// ----
