==== Source:  ====

==== Source: su0.sol ====
pragma solidity >= 0.0.0;
library L0 {
  error er0();
  function f0(address i0,int176 i1,int240 i2) external    returns(function (uint40, bool) external   returns (bool, int152, bool) o0)
  {
    if (true)
    {
    }
  }
  modifier m0(string memory i0,address payable i1) 
  {
    _;
  }
  event ev0();
}
int80 constant cons0 = (((((int80(604462909807314587353087) * int80(604462909807314587353087)) + int80(0)) * int80(0)) - int80(0)) ** uint224(uint224(0)));
contract C0 {
  modifier m1(int96[2] memory i0) virtual
  {
    delete i0[1];
    (i0[0]) = (int96(39614081257132168796771975167));
    _;
    _;
    _;
  }
  fallback() external virtual  
  {
    revert L0.er0();
    assembly
    {
      return(cons0, cons0)
    }
    if (true)
    {
    }
    emit L0.ev0();
  }
  using L0 for *;
  function f2() external   
  {
    assert(true);
    return;
  }
  event ev1(function () external    ep0, function (uint208) external   returns (address, bytes18, bool)  ep1, bool  ep2);
  address[1]   s0 = [address(0x0000000000000000000000000000000000000002)];
  address   s1 = address(this);
  uint232   s2 = uint232(6901746346790563787434755862277025452451108972170386555162524223799295);
  int80   s3 = int80(383243597029447890942564);
  struct St0 {
    bool el0;
    bool[] el1;
    address el2;
    address el3;
  }
  event ev2();
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53, M54, M55,
  M56, M57, M58, M59, M60, M61, M62, M63,
  M64, M65, M66, M67, M68, M69, M70, M71,
  M72, M73, M74, M75, M76, M77, M78, M79,
  M80, M81, M82, M83, M84, M85, M86, M87,
  M88, M89, M90, M91, M92, M93, M94, M95,
  M96, M97, M98, M99, M100, M101, M102, M103,
  M104, M105, M106, M107, M108, M109, M110, M111,
  M112, M113, M114, M115, M116, M117, M118, M119,
  M120, M121, M122, M123, M124, M125, M126, M127,
  M128, M129, M130, M131, M132, M133, M134, M135,
  M136, M137, M138, M139, M140, M141, M142, M143,
  M144, M145, M146, M147, M148, M149, M150, M151,
  M152, M153, M154, M155, M156, M157, M158, M159,
  M160, M161, M162, M163, M164, M165, M166, M167,
  M168, M169, M170, M171, M172, M173, M174, M175,
  M176, M177, M178, M179, M180, M181, M182, M183,
  M184, M185, M186, M187, M188, M189, M190, M191,
  M192, M193, M194, M195, M196, M197, M198, M199,
  M200, M201, M202, M203, M204, M205, M206, M207,
  M208, M209, M210, M211, M212, M213, M214, M215,
  M216, M217, M218, M219, M220, M221, M222, M223,
  M224, M225, M226, M227, M228, M229, M230, M231,
  M232, M233, M234, M235, M236, M237, M238, M239,
  M240, M241, M242, M243, M244, M245, M246, M247

}
using L0 for uint;
error er1(function (EN0, bool) external  [][2] ep0, uint96 ep1);
type T0 is address payable;

==== Source: su1.sol ====
import "su0.sol";
type T1 is bytes6;
uint24 constant cons1 = ((((uint24(((uint24(3696453) * uint24(16777215)) / uint24(16777215))) + uint24(0)) << uint184(uint184(17007518986980541920172811246740962176816312980069877887))) << uint248(uint248(179204897369658125438615691139626612133416858014205837176957119335047809810))) >> uint224(uint224(7733192732833980643512878739768286406238781133573302033007854620255)));
enum EN1 {
  M0, M1, M2, M3, M4, M5
}
struct St1 {
  C0.St0 el0;
}
pragma solidity >= 0.0.0;
function f3()     returns(T0 o0)
{
}
// ----
// Warning 3149: (su0.sol:330-459): The result type of the exponentiation operation is equal to the type of the first operand (int80) ignoring the (larger) type of the second operand (uint224) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// TypeError 7615: (su0.sol:715-720): Only direct number constants and references to such constants are supported by inline assembly.
// TypeError 7615: (su0.sol:708-713): Only direct number constants and references to such constants are supported by inline assembly.
// Warning 3149: (su1.sol:64-221): The result type of the shift operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint184) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
// Warning 3149: (su1.sol:63-319): The result type of the shift operation is equal to the type of the first operand (uint24) ignoring the (larger) type of the second operand (uint248) which might be unexpected. Silence this warning by either converting the first or the second operand to the type of the other.
