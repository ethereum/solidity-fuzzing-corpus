
==== Source: su0.sol ====
error er0();
library L0 {
  function f0(bytes16 i0) external    returns(int40 o0,address o1)
  {
    while (true)
    {
    }
  }
  address payable public constant cons0 = payable(0x0000000000000000000000000000000000000000);
  error er1(address ep0);
  using L0 for *;
  error er2();
  bool public constant cons1 = ((true || false) || false);
  event ev0(bytes18  ep0);
  type T0 is bytes20;
  modifier m0() 
  {
    if ((bytes9(0x677666622c64064f6e) >= bytes9(0xffffffffffffffffff)))
    {
      while (true)
      {
        assembly
        {
          stop()
        }
        _;
        continue;
      }
    }
    else if (false)
    {
      while (false)
      {
        _;
      }
      _;
      while (true)
      {
        emit L0.ev0(bytes18(0xffffffffffffffffffffffffffffffffffff));
      }
    }
    assembly
    {
      let al0 := 56033753701254930637379813897666888255169294676808872069520773931010252037674
    }
  }
}
function f1(function (address, bytes11) external   i0)    
{
  if (true)
  {
  }
  try i0(address(0x0000000000000000000000000000000000000006),bytes11(0x4a241198b121bcd4e54efa))
  {
  }
  catch
  {
    if (false)
    {
      for(      string memory l0 = "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
;
)
      {
        if (((true ? true : true) || false))
        {
          assembly
          {
          }
        }
      }
      return;
    }
    else if ((int16(0) >= ((~(int16(32767))) + (int16(-25595) * int16(-9308)))))
    {
    }
    else
    {
    }
    for(    int104 l1 = (((~((((int104(-9433968300303827131103824396064) * int104(0)) * int104(-8064587733063550003757558649971)) | int104(0)))) % int104(10141204801825835211973625643007)) | int104(0));
false;
)
    {
      if (true)
      {
      }
      else if (true)
      {
      }
      if (false)
      {
        continue;
        revert("3f7e33c5c8630b09c98e1b8801c0196ebf1a490d0bd78d3eabf3085960ffffffffffffffffffffffffffff");
      }
      else if (true)
      {
      }
      else
      {
      }
    }
  }
}
contract C0 {
  struct St0 {
    mapping(uint96 => bytes30) el0;
    function (bytes6) external   returns (bool) el1;
  }
  event ev1() anonymous;
  modifier m1(L0.T0 i0) virtual
  {
    _;
  }
  function f2(bytes17 i0,bytes calldata i1) external virtual m1(L0.T0.wrap(bytes20(address(0x08D559c33cA1Dc303f3F1fFDb7A73aBF323805e0)))) 
  {
    assembly
    {
    }
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffff0000000000000000");
    }
    { }
    bool l2 = true;
  }
  uint256 public constant cons2 = uint256(((((((uint256(2387782061332466829308135332392359885559251656364963182893427991992993256776) % uint256(0)) >> uint32(uint32(4294967295))) << uint8(uint8(0))) >> uint176(uint176(0))) % uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) / uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)));
  event ev2();
  using L0 for *;
  modifier m2(bytes10 i0) virtual
  {
    unchecked {
    }
    _;
  }
  error er3();
  int160   s0;
  address immutable public s1 = address(this);
  constructor(int160 i0)   {
    s0 += (~((int160(0) | ((int160(245155025727564727109914323804148319871991034460) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) | int160(0)))));
    { }
  }
}
pragma solidity >= 0.0.0;
struct St1 {
  bytes31 el0;
  bool el1;
}
// ====
// ----
