
==== Source: su0.sol ====
struct St0 {
  function () external   returns (bytes12, function (bytes16, uint64, bool) external  ) el0;
  bytes el1;
  mapping(address => uint232) el2;
  uint112 el3;
}
contract C0 {
  struct St1 {
    function (int200, address) external   returns (uint104) el0;
    bool el1;
  }
  mapping(bytes29 => mapping(int8 => address))   s0;
  constructor()   {
    {
    }
  }
  event ev0(function () external   returns (uint176, uint208)  ep0);
  function f0(bytes30 i0) external virtual    returns(int40 o0)  {
    emit ev0(0x0000000000000000000000000000000000000007 f1 /*suffix expr*/);
  }
}
pragma solidity >= 0.0.0;
struct St2 {
  uint128 el0;
}
function f1(address i0) pure suffix  returns(function () external   returns (uint176, uint208) o0)
{
  if (i0 > address(0x0000000000000000000000000000000000000008))
  {
  }
  else
  {
    if (i0 <= address(0x0000000000000000000000000000000000000007))
    {
    }
  }
  return (o0);
}

==== Source: su1.sol ====
struct St3 {
  string el0;
  function (bool, bytes18, address payable) external   el1;
  uint48 el2;
  bool el3;
}
pragma solidity >= 0.0.0;
contract C1 {
  mapping(bool => bytes7)   s1;
  int248  public s2;
  constructor(int248 i0)   {
    s2 = ((~((-((((true ? int248(223229820956259009429695444463890679320313408664443245458123946493899747994) : int248(224622134665171796170328417248230562003629089477341064869816437985544053607)) ^ int248(226156424291633194186662080095093570025917938800079226639565593765455331327)) + int248(0)))))) & int248(185727470204522091319652524650752227920930138078032508814237327079771991402));
    s1[false] = bytes7(0xca038a9bfcf5a8);
    unchecked {
    }
  }
  function f2(bool i0,bytes19 i1) external virtual  payable  returns(function () external   returns (bool) o0)  {
  }
  function f3(int248 i0) external   payable  returns(bool o0)  {
    for(    bytes storage l0;
true;
(uint8(((uint8(0) & ((true ? uint8(0) : uint8(255)) * uint8(255))) / uint8(0))) % uint8(255)))
    {
      o0 = hex"0000" f4 /*suffix expr*/;
      assert(o0 == hex"0000" f4 /*suffix expr*/);
      o0 = false;
      assert(o0 == false);
      break;
    }
  }
  event ev1();
  function f5() private     returns(function (address payable) external   o0,bytes memory o1,function (uint152, bool) external   returns (address payable) o2)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("a87521dd7e4151514bf4d6ef984dcf263b3651afa53a000000000000000000000000000000000000000000000000000000"));
    o1 = bytes("0000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff");
    assert(keccak256(bytes(o1)) == keccak256(bytes(bytes("0000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffff"))));
    (bool l2) = this.f3({i0: int248(226156424291633194186662080095093570025917938800079226639565593765455331327)});
  }
}
function f4(bytes2 i0) pure suffix  returns(bool o0)
{
  require(true, string("This is a really long string that must ideally be random but is currently hard coded"));
}
// ====
// ----
