
==== Source: su0.sol ====
error er0(bool ep0, address ep1);
pragma solidity >= 0.0.0;
struct St0 {
  function (int160) external   el0;
  uint56 el1;
  address el2;
}

==== Source: su1.sol ====
error er1(uint208 ep0, function (bytes memory) external   returns (function () external  [] memory) ep1);
struct St1 {
  address[] el0;
  uint64 el1;
  uint112 el2;
  int16 el3;
}
function f0(function (address payable) external   returns (bool, uint24, address) i0)      returns(bool o0,function (bytes memory) external   returns (St1 memory, bool) o1,St1 memory o2){
  do
  {
    break;
  }
  while (false);
  if (false)
  {
  }
}
pragma solidity >= 0.0.0;
contract C0 {
  bool public constant cons0 = true;
  receive() external   payable
  {
    if ((payable(address(this)) <= payable(address(this))))
    {
    }
    else if (true)
    {
    }
    uint64(15799611127291172162);
  }
  uint120 immutable  s0 = uint120(571193473958314817696189030296456674);
  fallback() external virtual  
  {
    return;
  }
  function f3(uint120 i0,uint120 i1) external virtual  payable  returns(address o0)  {
    if (i0 >= uint120((uint120(10147318992959782715305279997025617) / uint120(((((uint184(0) == uint184(0)) ? uint120(1329227995784915872903807060280344575) : uint120(852685746483553574645709535890638310)) ** uint240(uint240(1766847064778384329583297500742918515827483896875618958121606201292619775))) / uint120(0))))))
    {
      while (false)
      {
        break;
      }
    }
    else
    {
      return (address(this));
    }
    o0 = address(this);
    assert(o0 == address(this));
  }
}
// ====
// ----
