
==== Source: su0.sol ====
function f0(bool i0)     {
}
function f1()      returns(int8 o0,uint224 o1){
  if (false)
  {
    f0(0 f2 /*suffix expr*/);
    o0 /= int8(-124);
    f0({i0: false});
  }
  else
  {
    for(uint solinit0 = 0; solinit0 < ((~(uint256(0))) % 11); solinit0++)
    {
      continue;
    }
    assert(false);
  }
}
pragma solidity >= 0.0.0;
function f2(uint40 i0) pure suffix  returns(bool o0)
{
  if (i0 < uint40(393623356710))
  {
  }
  else
  {
  }
  revert(string("This is a really long string that must ideally be random but is currently hard coded"));
}

==== Source: su1.sol ====
contract C0 {
  bytes28   s0;
  int240  public s1 = int240(883423532389192164791648750371459257913741948437809479060803100646309887);
  bool   s2 = false;
  constructor(bytes28 i0) payable  {
    s0 = bytes28(0x00000000000000000000000000000000000000000000000000000000);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call(bytes("f4c27689101cbacee2121f85938acc1a2428a5ffffffff"));
    }
  }
  function f3(bool i0) public     returns(bytes17 o0,bool o1)  {
    if (i0)
    {
      o1 = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f4 /*suffix expr*/;
      assert(o1 == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f4 /*suffix expr*/);
    }
    else
    {
      o0 &= (bytes17(0xffffffffffffffffffffffffffffffffff) | bytes17(((true != true) ? bytes3(0xffffff) : bytes3(0x000000))));
    }
  }
}
int112 constant cons0 = 0;
struct St0 {
  int240[] el0;
  address el1;
  bool el2;
  bool el3;
}
pragma solidity >= 0.0.0;
function f4(address i0) pure suffix  returns(bool o0)
{
  (o0) = (true);
  assert(o0 == true);
}
// ====
// ----
