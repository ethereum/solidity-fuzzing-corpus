
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
struct St0 {
  int256 el0;
  bytes el1;
  function (bytes memory) external   returns (bool, function (uint192, uint160) external   returns (uint256, address payable, address payable)[] memory, address) el2;
}
function f0(uint160 i0)     {
  if (i0 <= uint160(802315582460129933682678916941596810486289687754))
  {
    int192 l0 = 0 f1 /*suffix expr*/;
  }
  for(;
;
false)
  {
    continue;
  }
}
function f1(uint144 i0) pure suffix  returns(int192 o0)
{
  do
  {
    break;
  }
  while (true);
  if (i0 != (uint144(22300745198530623141535718272648361505980415) | uint144(0)))
  {
    function (bool, int104, bool[] memory) external   returns (bool, bool, function (uint8, bool) external   returns (St0 memory, address)) l0;
    uint256 l1 = uint256(71758707017037063227121492978321616557114393562325794127361640802672420187607);
  }
  else
  {
    o0 += ((~(0 f2 /*suffix expr*/)) * int136(43556142965880123323311949751266331066367));
    o0 ^= (~(int192(0)));
  }
}
function f2(uint96 i0) pure suffix  returns(int192 o0)
{
}

==== Source: su1.sol ====
struct St1 {
  bytes el0;
  string el1;
  address payable el2;
  bool el3;
}
pragma solidity >= 0.0.0;
function f3(uint32 i0)    pure suffix returns(address payable o0){
  if (i0 != uint32((((((uint88(0) % uint88(12627022398839968844652153)) * uint88(0)) | uint88(4741371385219663296874632)) ^ uint88(303699964031431880566478788)) | uint88(0))))
  {
    o0 = (hex"52" f4 /*suffix expr*/ ? payable(address(0x0000000000000000000000000000000000000007)) : payable(address(0x0000000000000000000000000000000000000002)));
    assert(o0 == (hex"52" f4 /*suffix expr*/ ? payable(address(0x0000000000000000000000000000000000000007)) : payable(address(0x0000000000000000000000000000000000000002))));
  }
  else
  {
    function (St1[] memory, bytes memory, address) external   returns (bytes memory, bytes21[] memory) l0;
  }
}
function f4(bytes1 i0) pure suffix  returns(bool o0)
{
  if (i0 > bytes1(0xff))
  {
    for(uint solinit0 = 0; solinit0 < (((payable(address(0x0000000000000000000000000000000000000008)).balance << uint112((uint112(0) + uint112(0)))) ^ uint256(0)) % 11); solinit0++)
    {
      for(uint solinit1 = 0; solinit1 < (0x0000000000000000000000000000000000000001 f5 /*suffix expr*/ % 11); solinit1++)
      {
        if (i0 > ((~(bytes1(0xff))) ^ ((~(bytes1(0xff))) ^ bytes1(0xce))))
        {
          break;
        }
        else
        {
        }
        if (i0 > hex"ffffffffffffffffffffffffffffffffffffffffffffffffff" f6 /*suffix expr*/)
        {
          for(uint solinit2 = 0; solinit2 < ((uint256(14391401777656162070770852003635291865619578048069101527177380214899231438640) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) % 11); solinit2++)
          {
          }
          for(          bytes25 l0 = (bytes25(0x00000000000000000000000000000000000000000000000000) ^ bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff));
;
payable(address(0x0000000000000000000000000000000000000004)))
          {
            return (true f7 /*suffix expr*/);
          }
          if (i0 != (bytes1(0x00) ^ bytes1(0xff)))
          {
            address l1 = address(0x0000000000000000000000000000000000000004);
            unchecked {
            }
            break;
          }
          else
          {
            assert(false);
            break;
          }
          while (false)
          {
            o0 = false;
            assert(o0 == false);
            break;
          }
        }
      }
    }
  }
}
function f5(address i0) pure suffix  returns(uint256 o0)
{
}
function f6(bytes25 i0) pure suffix  returns(bytes1 o0)
{
}
function f7(bool i0) pure suffix  returns(bool o0)
{
}
function f8(address i0) pure suffix  returns(bytes1 o0)
{
}
// ====
// ----
