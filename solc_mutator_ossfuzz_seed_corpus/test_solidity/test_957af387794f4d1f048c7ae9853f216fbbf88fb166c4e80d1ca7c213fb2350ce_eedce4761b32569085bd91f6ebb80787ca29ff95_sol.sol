==== Source:  ====

==== Source: su0.sol ====
function f0()     {
  if (205688069665150755269371147819668813122841983204197482918576127 f1 /*suffix expr*/)
  {
  }
  else
  {
  }
  do
  {
    continue;
  }
  while ((payable(address(0x0000000000000000000000000000000000000008)) == payable(address(0x0000000000000000000000000000000000000007))));
}
error er0(address ep0);
contract C0 {
  fallback() external virtual  payable
  {
  }
  uint40  public s0;
  constructor(uint40 i0)   {
    s0 >>= (~((((uint40(0) + (uint40(0) - uint40(621041568676))) | uint40(0)) % uint40(296585960811))));
    unchecked {
    }
  }
  function f3(uint40 i0) internal virtual    returns(bytes16 o0,address o1)  {
    if (i0 > (uint40(1099511627775) % (uint40(0) >> uint248((uint248(452312848583266388373324160190187140051835877600158453279131187530910662655) - uint248(0))))))
    {
      while (false)
      {
        continue;
      }
      (bool l0, bytes memory l1) = payable(this).call{value: 5807265829046578854}("");
      o0 ^= (~((false ? bytes16(0x00000000000000000000000000000000) : bytes16(0x6280bbe6f66a58c024d3f62923bb8588))));
    }
    else if (i0 != uint40(649790174364))
    {
    }
  }
}
pragma solidity >= 0.0.0;
function f1(int208 i0) pure suffix  returns(bool o0)
{
  if (i0 >= (int208(0) & (true ? ((int208(0) | int208(0)) ^ int208(-185548364208067327485478475600170431788696647353746689164920134)) : int208(-92503388087647454906028471290619832293393305788472671079152261))))
  {
    f0();
    o0 = (false ? false : (payable(address(0x0000000000000000000000000000000000000007)) == payable(msg.sender)));
    assert(o0 == (false ? false : (payable(address(0x0000000000000000000000000000000000000007)) == payable(msg.sender))));
    (o0) = (true);
    assert(o0 == true);
  }
  return (false);
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
function f4()      returns(address o0,uint128[10] memory o1,bool o2){
  if (false)
  {
    (o2) = (false);
    assert(o2 == false);
  }
  else if (-7068725566369948440 f5 /*suffix expr*/)
  {
    return (address(0x0000000000000000000000000000000000000006), [uint128(45952195021941267260048834869958911540), uint128(0), uint128(340282366920938463463374607431768211455), uint128(322825957331499674831318603249880213554), uint128(0), uint128(340282366920938463463374607431768211455), uint128(324601333257427541020137248815308199953), uint128(0), uint128(110527832862879926518644803875737631364), uint128(340282366920938463463374607431768211455)], ((((uint192(6277101735386680763835789423207666416102355444464034512895) % uint192(0)) % uint192(2102374808560801752560283552229933250433510545223039935071)) * uint192(2054270617058048334297271561680339503741375051090037882926)) == uint192(149999399544402502602188786714482833625648339235938135076)));
  }
}
error er1(address payable ep0);
struct St0 {
  string[7] el0;
}
function f5(int64 i0) pure suffix  returns(bool o0)
{
  o0 = (address(0x0000000000000000000000000000000000000006) >= msg.sender);
  assert(o0 == (address(0x0000000000000000000000000000000000000006) >= msg.sender));
}
// ----
// Warning 3628: (su0.sol:324-1138): This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
// TypeError 4907: (su1.sol:173-196): Built-in unary operator - cannot be applied to type bool.
