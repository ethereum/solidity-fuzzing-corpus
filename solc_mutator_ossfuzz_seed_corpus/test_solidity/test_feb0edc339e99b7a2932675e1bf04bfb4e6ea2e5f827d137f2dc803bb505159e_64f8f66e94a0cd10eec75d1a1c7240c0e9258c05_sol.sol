
==== Source: su0.sol ====
function f0(address payable i0)     {
  int160 l0 = (true f1 /*suffix expr*/ ^ ((int160(730750818665451459101842416358141509827966271487) | (int160(-613824785892850258325535197896004649491387719035) % int160(0))) - int160(-656955914873661484399926140026478970471776395856)));
  do
  {
    int144 l1 = (int144(-3027723907278016913045043536312514819477641) | ((int144(0) % int144(int16(32767))) ^ int144(11150372599265311570767859136324180752990207)));
  }
  while (((int48(-75700588965918) ^ (int48(140737488355327) & (int48(54371463592279) - int48(0)))) >= int48(92893647815337)));
}
pragma solidity >= 0.0.0;
function f1(bool i0) pure suffix  returns(int160 o0)
{
  return (int160((int160(0) / ((int160(0) * (-(int160(294097938427927836933894906580368178157979301327)))) & int160(0)))));
}

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0(address[5] indexed ep0);
  address payable   s0;
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
    }
  }
  fallback() external virtual  payable
  {
  }
}
struct St0 {
  int88 el0;
  address payable el1;
  int56 el2;
}
type T0 is uint128;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=

} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



error er0();
// ====
// ----
