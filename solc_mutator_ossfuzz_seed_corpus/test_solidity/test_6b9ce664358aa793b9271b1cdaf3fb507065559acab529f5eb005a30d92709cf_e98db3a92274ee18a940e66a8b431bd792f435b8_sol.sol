
==== Source: su0.sol ====
bytes6 constant cons0 = ((((bytes6(0x000000000000) & (bytes6(0x000000000000) ^ bytes6(0x3137af5efdb4))) & bytes6(0x9c6f48a94384)) | bytes6(0x0ca8ab1f07e3)) ^ bytes6(0xffffffffffff));
pragma solidity >= 0.0.0;
contract C0 {
  receive() external virtual  payable
  {
  }
  modifier m0(function () external   returns (bytes10) i0) 
  {
    _;
  }
  modifier m1() 
  {
    _;
    assembly
    {
      let al0 := 0
      al0 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
      return(extcodehash(115792089237316195423570985008687907853269984665640564039457584007913129639935), cons0)
    }
  }
  function f1() external virtual  payable returns(int128 o0)
  {
    while ((bytes29(0x0000000000000000000000000000000000000000000000000000000000) == bytes29(0x0000000000000000000000000000000000000000000000000000000000)))
    {
      (int128 l0) = this.f1();
      if (true)
      {
      }
    }
  }
  error er0(bytes22 ep0);
  uint72  public s0 = uint72(1800760270520616099432);
  function f2() public   payable
  {
    while (false)
    {
      assembly
      {
        switch s0.offset
        case 92232089825229557248516281532357481061645919114793823021446053692275678257217
        {
        }
        default
        {
        }
      }
    }
    try this.f1() returns (int128 l0)
    {
    }
    catch
    {
      revert er0(bytes22(0xffffffffffffffffffffffffffffffffffffffffffff));
      return;
      do
      {
        (bool l1) = payable(this).send(15634455049222809745);
        continue;
        payable(this).transfer(7698379172114528);
        revert er0(bytes22(0xffffffffffffffffffffffffffffffffffffffffffff));
      }
      while ((false || true));
    }
    (s0) = ((uint72(4722366482869645213695) + (uint72(0) | uint72(1486898044987345975437))));
  }
  error er1();
  modifier m2() 
  {
    _;
  }
}
error er2();
struct St0 {
  bytes el0;
  int224 el1;
  int168 el2;
}
// ====
// ----
