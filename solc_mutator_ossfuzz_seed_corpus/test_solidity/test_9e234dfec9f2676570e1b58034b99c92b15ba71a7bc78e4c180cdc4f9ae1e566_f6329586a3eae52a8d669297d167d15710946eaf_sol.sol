
==== Source: su0.sol ====
struct St0 {
  function (address, address) external   returns (bool, uint144) el0;
  address el1;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
error er0(bytes ep0, bool ep1);
pragma solidity >= 0.0.0;
contract C0 {
  address payable  public s0 = payable(address(this));
  int48  public s1;
  uint168  public s2;
  bool  public s3;
  constructor(int48 i0,uint168 i1,bool i2)   {
    s1 |= int48(((~(int48(-88604922429670))) / (int48(140737488355327) - int48(140737488355327))));
    s2 |= uint168(374144419156711147060143317175368453031918731001855);
    s3 = false;
    {
    }
  }
  struct St1 {
    bytes16 el0;
    uint128 el1;
  }
  function f0() private     returns(uint256 o0)  {
    if (false)
    {
      if (false)
      {
        o0 <<= uint176(14601259493314598653398263886560017380930890742837495);
        address payable  l0 = s0;
        address payable  l1 = l0;
        assert(l1 == s0);
      }
    }
  }
  receive() external   payable
  {
  }
}
contract C1 {
  event ev0(string  ep0);
  function f2(uint144 i0,function (function (bytes24, address payable, int208) external   returns (address, uint48)) external   returns (uint184, address) i1) private      {
    for(;
true;
string(bytes(string("This is a really long string that must ideally be random but is currently hard coded"))))
    {
      return;
    }
    do
    {
      if (true)
      {
        revert er0(bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000"), false);
      }
    }
    while (false);
  }
  address payable  public s4 = payable(address(this));
  int176  public s5;
  C0.St1[]   s6 = [C0.St1(bytes16(0x00000000000000000000000000000000), uint128(298013377308024383501469106154595510168)), C0.St1(bytes16(0xffffffffffffffffffffffffffffffff), uint128(2124894337303488469179310826663831578))];

	function compareMemoryAndStorage(C0.St1[] memory v1, C0.St1[] storage v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (!compareMemoryAndStorage(v1[i], v2[i]))

				return false;
		return true;
	}

	function compareMemoryAndStorage(C0.St1 memory v1, C0.St1 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

		if (v1.el1 != v2.el1)
			return false;

	return true;
	}  address   s7;
  constructor(int176 i0,address i1)   {
    s5 ^= (int176(47890485652059026823698344598447161988085597568237567) - ((false ? int48(140737488355327) : int48(0)) % int48(140737488355327)));
    s7 = address(this);
    unchecked {
      (bool l0, bytes memory l1) = address(this).call(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF f3 /*suffix expr*/);
    }
  }
}
function f3(address i0) pure suffix  returns(bytes memory o0)
{
  return (bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2d2c258320f5b88c0c1dfb9d7f10231755ecf733c3b814eeb04bcc4c"));
}
// ====
// ----
