
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
bool constant cons0 = true;
struct St0 {
  int40[4] el0;
  address payable el1;
  mapping(address => int208) el2;
  bytes el3;
}
contract C0 {
  bool   s0 = false;
  function f0(bool i0) private     returns(function (int88, address, uint200) external   returns (string[3] memory, address) o0)  {
    if (i0)
    {
      revert(string((true f1 /*suffix expr*/ ? bytes("0000000000000000000000000000000000000000000000000000000061ecc15c6bba4bf521") : bytes("5f7684752deb684d4681a1bbef178af178"))));
    }
  }
  struct St1 {
    uint104 el0;
    bytes9 el1;
    address payable el2;
  }
  function f2() public virtual     {
    delete s0;
    if ((uint56(0) <= uint56(7486363887354326)))
    {
      (bool l0, bytes memory l1) = address(this).call(bytes("000000000000000000000000000000000030"));
    }
    else if (true)
    {
      bool  l2 = s0;
      bool  l3 = l2;
      assert(l3 == s0);
    }
  }
}
function f1(bool i0) pure suffix  returns(bool o0)
{
  if (i0)
  {
    return (cons0);
  }
}

==== Source: su1.sol ====
function f3(bytes22 i0)    pure suffix returns(bool o0){
  assert(true);
}
pragma solidity >= 0.0.0;
contract C1 {
  function f4(address payable i0,bytes2 i1) public virtual    returns(function (function () external  ) external   o0,address o1,function (bool, bool) external   o2)  {
    if (i0 != payable(address(this)))
    {
      if (i1 != (~(((bytes2(0xffff) | ((bytes2(0xffff) & bytes2(0x99f2)) & bytes2(0x0000))) | bytes2(0xffff)))))
      {
      }
      (bool l0, bytes memory l1) = payable(this).call{value: 11387196379441182021}("");
    }
    else
    {
      try o2(((uint72(2468581124169425562883) * ((uint8(255) | uint8(255)) - uint72(4401227201640561347389))) >= uint72(0)),(bytes17(0x783a20d3f9b1466c071765616315ba8a7b) == bytes17(0xc2b69b55275b8c1c854bdeb716aef90b2e)))
      {
        payable(this).transfer(0);
        for(        function (address, uint104, bool) external   l2;
;
)
        {
        }
        for(uint solinit0 = 0; solinit0 < ((uint256(70197932770057089187256843859801917460535290000216511479541624206463817738992) * (((uint256(29326302283888772519249062530401435919142577541786389524149538760927421552268) + uint256(11949969068215870128156096554556078171434451642248935824655029085871317659607)) * uint256(70365475258607942870190135786150100710034529755427972436564067613436769117390)) * uint256(12821863324432428717737329188417473657179798955966103616596991905940262180929))) % 11); solinit0++)
        {
        }
      }
      catch
      {
        o1 = address(this);
        assert(o1 == address(this));
      }
    }
  }
  bytes   s1 = bytes("702372d5c197af40b63e09b2730000000000000000000000000000000000");

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bytes10 immutable  s2;
  bool   s3 = true;
  int136   s4 = int136(43556142965880123323311949751266331066367);
  constructor(bytes10 i0)   {
    s2 = bytes10(0x2c0df59df52525a328a2);
    unchecked {
    }
  }
  fallback() external virtual  payable
  {
    bytes memory l0 = s1;
    bytes memory l1 = l0;
    assert(compareMemoryAndStorage(l1, s1));
    s1.push("\x3b");
  }
}
import "su0.sol";
struct St2 {
  bytes3 el0;
}
// ====
// ----
