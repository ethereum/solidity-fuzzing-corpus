
==== Source: su0.sol ====
contract C0 {
  bytes10   s0;
  int104   s1;
  constructor(bytes10 i0,int104 i1)   {
    s0 ^= bytes10(0x00000000000000000000);
    s1 &= ((int104(3887099466741959903985164385436) * int104(0)) ** uint128(uint128(((uint128(0) % uint128(340282366920938463463374607431768211455)) / uint128(149538722736745293764263011306491854200)))));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("ffffffffffffff841b52900e");
      do
      {
        break;
        delete i0;
        continue;
      }
      while ((!(false)));
      (s1) = ((int104(0) % (int104(598300092318761596994542940636) % int104(0))));
    }
  }
  error er0(address ep0, function (bytes memory, bool, bool) external   returns (function () external  , int176, address) ep1);
}
type T0 is bytes20;
error er1(uint8 ep0);
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34
}
EN0 constant cons0 = EN0.M13;
library L0 {
  function f0() internal    returns(EN0 o0,string memory o1)
  {
    unchecked {
    }
    if (false)
    {
      if (true)
      {
      }
      else if (true)
      {
      }
    }
  }
  modifier m0() 
  {
    _;
    assembly
    {
    }
  }
  modifier m1(bytes25 i0,bool i1) 
  {
    bool l0 = true;
    (EN0 l1, string memory l2) = f0();
    _;
  }
  function f1() internal  m1(bytes25(0x00000000000000000000000000000000000000000000000000),false) 
  {
    f1();
  }
  error er2(T0 ep0, EN0 ep1);
  function f2() public  m0()  returns(function (bytes20, bytes4, bool) external   returns (bytes7) o0)
  {
    if (false)
    {
    }
    else if ((!(false)))
    {
      unchecked {
        assembly
        {
          for 
          {
          }
          cons0
          {
          }
          {
          }
          {
            switch gasprice()
            default
            {
              for 
              {
                return(cons0, 0)
                switch sdiv(cons0, 0)
                case 115792089237316195423570985008687907853269984665640564039457584007913129639935
                {
                  mstore(mod(0, 2048), 0)
                }
                case 115792089237316195423570985008687907853269984665640564039457584007913129639935
                {
                }
                let al0 := byte(cons0, 23401795113127220285938844643661651773052037813609068376816474154047803604134)
              }
              115792089237316195423570985008687907853269984665640564039457584007913129639935
              {
              }
              {
                switch mload(mod(cons0, 2048))
                case 115792089237316195423570985008687907853269984665640564039457584007913129639935
                {
                  let al1 := difficulty()
                  continue
                  al1 := al1
                }
                case 0
                {
                }
                {
                  break
                  return(115792089237316195423570985008687907853269984665640564039457584007913129639935, cons0)
                }
                break
              }
            }
            let al2 := cons0
            if mload(mod(al2, 2048))
            {
            }
          }
        }
      }
    }
    else
    {
    }
  }
  int256 public constant cons1 = ((((((int256(0) ^ int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) & int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)) * int256(0)) + int256(45922486354101450817199986402660433253776260974531283237359867842122359958279)) ** uint136(uint136(0))) * int256(57896044618658097711785492504343953926634992332820282019728792003956564819967));
  using L0 for *;
}
pragma solidity >= 0.0.0;
struct St0 {
  EN0 el0;
  T0 el1;
  address payable el2;
  bytes el3;
}
// ====
// ----
