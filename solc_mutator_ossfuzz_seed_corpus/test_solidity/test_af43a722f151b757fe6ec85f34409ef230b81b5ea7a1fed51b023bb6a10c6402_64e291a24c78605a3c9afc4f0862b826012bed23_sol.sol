
==== Source: su0.sol ====
contract C0 {
  function f0(bytes9 i0) internal virtual     {
  }
  type T0 is uint256;
  receive() external virtual  payable
  {
    payable(this).transfer(0);
  }
  uint248   s0 = uint248(0);
  C0.T0   s1 = C0.T0.wrap(uint256(0));
  fallback() external   
  {
    payable(this).transfer(2412385359141982280);
  }
  event ev0();
}
type T1 is address payable;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,

eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }





function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(payable(address(bytes20(address(T1.unwrap(x))) | bytes20(address(T1.unwrap(y)))))); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(payable(address(bytes20(address(T1.unwrap(x))) & bytes20(address(T1.unwrap(y)))))); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(payable(address(bytes20(address(T1.unwrap(x))) ^ bytes20(address(T1.unwrap(y)))))); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(payable(address(~bytes20(address(T1.unwrap(x)))))); }






function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



pragma solidity >= 0.0.0;
struct St0 {
  bool el0;
  bytes10 el1;
}
struct St1 {
  bytes18 el0;
}

==== Source: su1.sol ====
contract C1 {
  function f3() external     returns(function () external   returns (int112, address) o0)  {
    return (o0);
  }
  struct St2 {
    string el0;
    function () external   el1;
  }
  function f4() public virtual    returns(int208 o0,function () external   returns (int240, function (int248, bool, function (function (address payable, bytes16, bytes memory) external   returns (uint40, bool, address), function (bytes22, bytes17, bool) external   returns (int224, uint112, uint216), int80) external   returns (bytes19)) external  ) o1,address o2)  {
    (bool l0) = payable(this).send(0);
  }
  receive() external virtual  payable
  {
    (function () external   returns (int112, address) l0) = this.f3();
  }
  bool   s2;
  bool   s3;
  mapping(uint56 => bool)   s4;
  uint32  public s5;
  constructor(bool i0,bool i1,uint32 i2)   {
    s2 = ((true ? int136(0) : (true ? int240(0) : int240(-634431046890210529646264173551792676519194502943476748979057589945869124))) != int240(-44932182922542931558334656930617620905221768534254937198660046394391426));
    s3 = true;
    s5 *= uint32(0);
    s4[((uint56(50000853236404707) ^ uint56((((uint56(72057594037927935) | uint56(66964489946917063)) ^ uint56(0)) / uint56(72057594037927935)))) & uint56(72057594037927935))] = s4[uint56(1598016615309998)];
    unchecked {
      (bool l0, bytes memory l1) = payable(this).call{value: 11091449756134793766}("");
    }
  }
}
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
