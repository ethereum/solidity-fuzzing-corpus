
==== Source: su0.sol ====
struct St0 {
  address el0;
}
contract C0 {
  receive() external   payable
  {
    if ((uint200(1606938044258990275541962092341162602522202993782792835301375) != (uint200(1606938044258990275541962092341162602522202993782792835301375) ^ (uint200(1219424808931150938341257284776826252349605193078916707645741) & uint200(1606938044258990275541962092341162602522202993782792835301375)))))
    {
    }
  }
  function f1() external virtual  payable   {
    try this.f1()
    {
      (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    }
    catch
    {
      try this.f1()
      {
      }
      catch
      {
        return;
      }
      catch Error(string memory l2)
      {
        while ((int64(9223372036854775807) > (int64(0) % int64(0))))
        {
          require(true);
          try this.f1()
          {
            function (uint64, address, bytes12) external   returns (address payable, uint176) l3;
            revert(string("This is a really long string that must ideally be random but is currently hard coded"));
          }
          catch
          {
            break;
          }
        }
        if (true)
        {
          do
          {
            if ((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) <= (uint256(0) * uint256(0))))
            {
              try this.f1()
              {
                continue;
              }
              catch
              {
              }
            }
            continue;
          }
          while (((false ? (int136(0) - int136(int256(0))) : int136(0)) == int136(0)));
        }
      }
      catch Panic(uint256 l4)
      {
      }
    }
    catch Error(string memory l5)
    {
    }
    catch Panic(uint256 l6)
    {
    }
  }
  type T0 is bytes10;
  bool immutable  s0;
  constructor(bool i0) payable  {
    s0 = false;
    unchecked {
    }
  }
  error er0();
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
type T1 is bytes29;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,

eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }




function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) | T1.unwrap(y)); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) & T1.unwrap(y)); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) ^ T1.unwrap(y)); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(~T1.unwrap(x)); }





function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



function f2(bytes12 i0)    pure suffix returns(int128[10] memory o0){
  o0 = [int128(145665913889478636647846149624683336209), int128(170141183460469231731687303715884105727), int128(170141183460469231731687303715884105727), int128(33602096529873307297817214715573698324), int128(0), int128(0), int128(30866981240007355415910524604390674930), int128(0), int128(170141183460469231731687303715884105727), int128(123836916854363749531277264979994378857)];
  while (((((uint120(((uint120(1329227995784915872903807060280344575) ** uint40(uint40(625761212632))) / uint120(1329227995784915872903807060280344575))) - uint120(1202943147098400830730668689604029986)) ** uint176(uint176(95780971304118053647396689196894323976171195136475135))) << uint72(uint72(3285395357005908328598))) != uint120(0)))
  {
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
