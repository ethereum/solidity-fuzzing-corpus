
==== Source: su0.sol ====
function f0()     returns(int192[] memory o0)
{
  if (false)
  {
  }
  else
  {
    for(;
;
[uint128(340282366920938463463374607431768211455)])
    {
      (o0, o0[1]) = (new int192[](2), (int192(0) * ((int192(0) & (int192(0) ^ int192(0))) & int192(3138550867693340381917894711603833208051177722232017256447))));
    }
  }
}
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36
}
pragma solidity >= 0.0.0;
library L0 {
  modifier m0() 
  {
    _;
  }
  function f1(address i0,bytes25 i1) public  m0() 
  {
    if (true)
    {
      assembly
      {
      }
      assembly
      {
        {
        }
        i0 := calldataload(mod(i0, calldatasize()))
      }
    }
    else if (true)
    {
      revert(string.concat(string.concat("d6a7bb623d490a0eb4d70d8bfe", "0000ffffffffffffffffffffffffffffffffffffffffffffffffff", string("000000000000004b7ac470699d600c8a"))));
      int8 l0 = ((int8(127) * int8(((int8(-57) | int8(127)) / int8(0)))) | int8(0));
    }
    assembly
    {
      {
        let al0 := i0
        i1 := 101375081726097383235342219089485327537844034313194672321946642815761796835702
      }
      stop()
    }
    if ((!(true)))
    {
      string memory l1 = "00000000000028798f64605e761403ab9aa287fa4701bc84bf187e";
      assembly
      {
      }
    }
    else if (false)
    {
      int200 l2 = int200(0);
    }
    else
    {
    }
  }
  modifier m1(int232 i0,bool i1) 
  {
    int152 l0 = (int152((((((int152(2854495385411919762116571938898990272765493247) + int152(2854495385411919762116571938898990272765493247)) | int152(2478165140639035386132157072557280666271308129)) ** uint16(uint16(65535))) & int152(0)) / int152(-1597267097029266298540405538496407851191122849))) + int152(-1386154405386520048477939146943935436891472596));
    for(;
;
)
    {
      _;
    }
  }
  modifier m2(int192 i0,bytes28 i1) 
  {
    _;
  }
  error er0();
  function f2(bool i0) public    returns(function (EN0, EN0, bytes8) external   returns (bool, bytes13, address) o0)
  {
  }
  bool public constant cons0 = ((((uint112(((uint112(5192296858534827628530496329220095) ^ uint112(0)) / uint112(0))) % uint112(2015337478223422342405133150969738)) + uint112(5192296858534827628530496329220095)) + uint112(5192296858534827628530496329220095)) >= uint112(5192296858534827628530496329220095));
  modifier m3(address payable i0,uint208 i1) 
  {
    _;
    _;
  }
}
type T0 is uint8;
contract C0 {
  error er1();
  struct St0 {
    bytes4 el0;
    uint184 el1;
    function (T0) external   returns (EN0) el2;
  }
  bool  public s0 = true;
  function f3(bytes calldata i0,C0.St0 memory i1,function () external   returns (bytes memory)[][1] calldata i2) external   payable
  {
  }
  using L0 for *;
  error er2();
  type T1 is bytes16;
  C0.T1 public constant cons1 = C0.T1.wrap(bytes16(0x00000000000000000000000000000000));
  event ev0() anonymous;
  function f4(function (int208) external   returns (string memory) i0) public    returns(function () external   returns (C0.T1, EN0, string memory) o0)
  {
    address payable l0 = payable(address(this));
  }
}
// ====
// ----
