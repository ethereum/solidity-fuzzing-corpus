
==== Source: su0.sol ====
contract C0 {
  type T0 is address payable;
  function f0(C0.T0 i0) public      {
    require(true);
  }
  address  public s0 = address(this);
  int224 immutable  s1;
  C0.T0 immutable  s2 = C0.T0.wrap(payable(address(0x0000000000000000000000000000000000000008)));
  int48   s3;
  constructor(int224 i0,int48 i1) payable  {
    s1 = (int224(int120((int120((int120(664613997892457936451903530140172287) / int120(-188899973146425012251401777456526790))) / int120(664613997892457936451903530140172287)))) % int224(13479973333575319897333507543509815336818572211270286240551805124607));
    s3 &= ((int48(-61189753358467) ** uint256(uint256((((uint256(65173148067119762006027566276199873986617885021520574962402061224159978767319) << uint96(uint96(6595663179851318415206524547))) * uint256(82145483883249014576990702008131084334243847652421330568651472745630210574525)) / uint256(85563472249389950630586372971167549417461357540346314752664257317783462907756))))) * int48(-113648957803043));
    unchecked {
    }
  }
}
struct St0 {
  bool el0;
  uint8 el1;
}
error er0();
pragma solidity >= 0.0.0;
struct St1 {
  bytes19 el0;
  uint16 el1;
  bytes16 el2;
}

==== Source: su1.sol ====
contract C1 {

	function compareMemoryAndCalldata(string memory v1, string calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f1(string calldata i0,uint200 i1) external virtual    returns(function (bytes2) external   returns (bool, bytes14) o0)  {
  }
  function f2(address payable i0,uint56 i1,address i2) internal      {
  }
  bytes26   s4 = bytes26(0x646c0191f521ef5c1b17deab661e6c422ec6bdfd4c4fc4616f6e);
  int256   s5 = int256(31024256031450325241207822723971520001014886432054045342232721231753315907247);
  function f3() public      {
    return;
  }
}
type T1 is uint128;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,
add1 as +, sub1 as -, mul1 as *, div1 as /, mod1 as %,
eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }




function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) | T1.unwrap(y)); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) & T1.unwrap(y)); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) ^ T1.unwrap(y)); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(~T1.unwrap(x)); }




function add1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) + T1.unwrap(y)); }

function sub1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) - T1.unwrap(y)); }

function mul1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) * T1.unwrap(y)); }

function div1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) / T1.unwrap(y)); }

function mod1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) % T1.unwrap(y)); }



function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



function f4(function () external   i0,address payable[9][] memory i1)      returns(address o0,int8 o1,bytes24 o2){
  return (i0.address, (((int16(32767) != int16(-30348)) ? false : true) ? int8(-85) : int8(22)), bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff));
}
pragma solidity >= 0.0.0;
// ====
// ----
