
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(bytes3 i0,uint104 i1) private     returns(function (string[] memory) external   returns (int184, address, uint88) o0,bool o1)  {
  }
  event ev0(int128  ep0) anonymous;
  receive() external   payable
  {
    return;
  }
  event ev1();
  address payable   s0;
  bool   s1 = true;
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
    }
  }
}
contract C1 is C0 {
  C0 public constant cons0 = C0(payable(address(0x0000000000000000000000000000000000000008)));
  bytes31   s2;
  address   s3;
  mapping(int48 => function (bool, bytes9, uint200) external   returns (function () external   returns (C0, string memory), bool)[])   s4;
  int144   s5 = int144(11150372599265311570767859136324180752990207);
  constructor(address payable i0,bytes31 i1,address i2)  C0(payable(address(cons0)))
  {
    s0 = payable(address(cons0));
    s2 &= bytes31(0x8031618a27cf4fe2358f775de7e718967a63d3571c338097cd1df7f7ef2392);
    s3 = address(bytes20(address(0x0000000000000000000000000000000000000000)));
    unchecked {
    }
  }
  event ev2();
  bool public constant cons1 = true;
  event ev3(function (int120) external    ep0, C0  ep1, uint176 indexed ep2);
}
function f2(int104 i0)     {
  for(uint solinit0 = 0; solinit0 < (uint256(71277179086234289790840358291552967102676331533293877928530302328372605640573) % 11); solinit0++)
  {
    break;
  }
}
struct St0 {
  address payable[][] el0;
  address payable el1;
}
// ====
// ----
