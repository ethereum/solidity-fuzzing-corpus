==== Source:  ====

==== Source: su0.sol ====
function f0()     returns(int128 o0)
{
  0;
}
contract C0 {
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29, M30, M31,
    M32, M33, M34, M35, M36, M37
  }
  modifier m0(address i0,address payable i1) virtual
  {
    assembly
    {
      i0 := i1
      if mload(mod(xor(37520216755661941551837304991186916131351728241283952436182853312631890762154, 115792089237316195423570985008687907853269984665640564039457584007913129639935), 2048))
      {
        i0 := i0
        for 
        {
          {
            if 0
            {
            }
          }
        }
        mul(i1, 0)
        {
        }
        {
          break
          i1 := 19570582827514319661280167108757994201078456732563908242188044634703712987139
          if shr(94335519143310405879107374010277935735558613872027007362387060131594947265359, 0)
          {
            if 0
            {
              break
            }
            continue
            revert(i1, 115792089237316195423570985008687907853269984665640564039457584007913129639935)
          }
        }
      }
      {
      }
      let al0 := mload(mod(63989271106832785420031928451176094885028430808097435649677826731108972452264, 2048))
      function af0() -> ao0, ao1
      {
        return(115792089237316195423570985008687907853269984665640564039457584007913129639935, ao1)
        let al1, al2 := af0()
      }
    }
    (bool l0, bytes memory l1) = address(this).call(bytes("2621f7f3a53950209bd614ffffffffffffffffffffffffffffffffffffffffffff"));
    _;
  }
  uint232   s0;
  address payable   s1;
  constructor(uint232 i0,address payable i1)   {
    s0 &= (((uint232(1414111804631154837229918193553019208963133596250413222633630513771286) | (uint232(1436248663097056653870287793431043002933620960946813597529427092848957) | uint232(0))) + uint232(0)) - uint232(2847791297174169786616034078260341529993512041156314144134112989669951));
    s1 = payable(address(this));
    unchecked {
    }
  }
  event ev0(int104  ep0, bool  ep1);
  address public constant cons0 = 0x0000000000000000000000000000000000000000;
  function f1(function (uint240) external   i0,uint120 i1) public  m0(cons0,payable(address(this))) m0(cons0,payable(address(this)))  returns(bytes9 o0,address o1)
  {
    (int128 l0) = f0();
    return (bytes9(0xffffffffffffffffff), cons0);
    assembly
    {
      o1 := s1.offset
    }
  }
  event ev1(string  ep0, bool  ep1, bool  ep2, uint168  ep3);
  function f2(function (bytes16) external   returns (C0.EN0, function (address payable, bool, bytes1) external  ) i0) public  m0(cons0,payable(address(this))) payable returns(uint40 o0,bool o1,C0.EN0 o2)
  {
  }
  fallback() external   
  {
    for(    function (uint88, function (bool, uint240) external   returns (bytes18, function (bool, uint248, int248) external  )) external   returns (function (string memory, int32, uint32) external   returns (bool, bool, uint144), int152, int128[2] memory) l0;
;
)
    {
    }
    assert((int208(0) >= (int208(-67942288271687090785121935428888328418585154410688687818356652) * (~((~(int208(187298733587493417032731930440420084399771296604888742439605505))))))));
    if (true)
    {
    }
  }
  type T0 is int224;
}
type T1 is int8;
pragma solidity >= 0.0.0;
contract C1 {
  modifier m1() 
  {
    (bool l0, bytes memory l1) = address(this).call(bytes("00000000000000000000000000000000000000000000000000000000000000000000000000000000"));
    _;
  }
  mapping(bool => bool)   s2;
  address payable  public s3;
  bool   s4;
  address   s5 = address(this);
  constructor(address payable i0,bool i1)   {
    s3 = payable(address(this));
    s4 = false;
    s2[false] = (true || false);
    unchecked {
    }
  }
  error er0();
  T1 public constant cons1 = T1.wrap(int8(127));
}
// ----
// Warning 5740: (su0.sol:759-1154): Unreachable code.
// Warning 5740: (su0.sol:2447-2462): Unreachable code.
// Warning 6133: (su0.sol:41-42): Statement has no effect.
// Warning 5667: (su0.sol:26-35): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1682-1692): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:1693-1711): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2194-2226): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:2227-2237): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:2353-2362): Unused local variable.
// Warning 2072: (su0.sol:2788-3036): Unused local variable.
// Warning 5667: (su0.sol:3645-3663): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3664-3671): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2018: (su0.sol:0-45): Function state mutability can be restricted to pure
