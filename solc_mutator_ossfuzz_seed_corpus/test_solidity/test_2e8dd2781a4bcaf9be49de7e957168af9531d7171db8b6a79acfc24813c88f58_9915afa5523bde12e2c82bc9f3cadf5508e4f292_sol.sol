
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
function f0()      returns(address o0){
  o0 = address(0x0000000000000000000000000000000000000002);
  assert(o0 == address(0x0000000000000000000000000000000000000002));
  return (address(0x0000000000000000000000000000000000000006));
}
contract C0 {
  int256  public s0;
  bytes17  public s1 = bytes17(0xffffffffffffffffffffffffffffffffff);
  address payable   s2;
  address immutable  s3;
  constructor(int256 i0,address payable i1,address i2)   {
    s0 &= ((-(((int256(int8(127)) * int256(0)) ^ int256(0)))) | int256(57896044618658097711785492504343953926634992332820282019728792003956564819967));
    s2 = payable(address(this));
    s3 = address(this);
    unchecked {
    }
  }
  struct St0 {
    mapping(int200 => int208) el0;
    address el1;
  }
  receive() external   payable
  {
    if (false)
    {
    }
    if ((address(this) > address(this)))
    {
      address  l0 = s3;
      address  l1 = l0;
      assert(l1 == s3);
      if ((bytes8(0x0000000000000000) != bytes8(0x0000000000000000)))
      {
        return;
      }
      s2 = payable(address(this));
      assert(s2 == payable(address(this)));
    }
    int256  l2 = s0;
    int256  l3 = l2;
    assert(l3 == s0);
  }
  error er0(bool ep0);
}
struct St1 {
  bytes3 el0;
  function (uint8, uint160, bytes10) external   returns (string memory, address) el1;
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
// ====
// ----
