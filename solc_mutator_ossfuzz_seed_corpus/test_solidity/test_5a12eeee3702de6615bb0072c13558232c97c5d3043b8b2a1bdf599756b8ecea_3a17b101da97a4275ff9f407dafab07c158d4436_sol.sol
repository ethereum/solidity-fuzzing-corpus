
==== Source: su0.sol ====
address payable constant cons0 = payable(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);
error er0();
address payable constant cons1 = payable(0x6501f9c49fAeBc8c5269899fA5Fb05c765054CF1);
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  uint104 el0;
  bytes5 el1;
}
pragma solidity >= 0.0.0;
struct St1 {
  address payable el0;
  uint96[6] el1;
  bytes24 el2;
}
contract C0 {
  type T0 is bool;
  function f0(address i0,bytes21 i1,uint200 i2) external virtual    returns(int80 o0)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("f841a6b9ae481ea65cf97674da46bf17e7b75287eeffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
    if (i1 != bytes21(0xc18f0f4c6a63878243390711017205571bcab3383b))
    {
      (bool l2, bytes memory l3) = address(this).call(abi.encodeWithSelector((((((~(uint88(0))) + uint88(308021801468405410941227511)) ^ uint88(0)) > uint88(0)) ? bytes4(0x00000000) : bytes4(0x68d39cdf)), bytes9(0x000000000000000000), address(this), address(this)));
    }
    else
    {
      o0 += int80(0);
      o0 &= (-((int80(570450485962335876484066) * int80(350795769914250361835039))));
    }
  }
  mapping(address => C0.T0)   s0;
  int176   s1 = int176(0);
  constructor()   {
    s0[this.f0.address] = C0.T0.wrap(true);
    unchecked {
    }
  }
  function f1(uint16 i0) private      {
    (bool l0, bytes memory l1) = address(this).call(bytes("00000000000000000000000000000000000000000000000000ba2e7ffd5cce6d173a62"));
  }
  struct St2 {
    int136 el0;
  }
  function f2() public virtual  payable  returns(int16 o0)  {
  }
}
// ====
// ----
