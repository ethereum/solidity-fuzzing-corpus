
==== Source: su0.sol ====
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C0 {
  event ev0(bytes19  ep0, address payable  ep1);
  uint16   s0 = uint16(59186);
  function f0(uint16 i0) public     returns(uint256 o0,string[] memory o1)  {
    (bool l0, bytes memory l1) = address(this).call(((bytes26(0x0000000000000000000000000000000000000000000000000000) > (((int8(0) | int8(81)) > int8(60)) ? bytes26(0xa70c8d26f9ca7ed54905a55e14ae43018ed44283dff69e4b7813) : bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff))) ? bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") : bytes("afc62dbd6862359ca99ebab9982a66bdb6024e6cd696797b7f50de7edbffffffffffffffffffffffffffffffffffffffffffffff")));
    (o1[(uint256(61516289890507915498367245342511604059779491239789828230196780498657922706592) - uint256(0))], o0, o1[((((((uint256(17777132105011587518354888687516798776989824323151515633909203410338933704308) % uint256(0)) & uint256(106914939312581193728652264182479772766236280067564609561087025882592651761715)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(105222278957534865665312833537337419910169064657210456729952311279111631919159)) + uint256(96191983089924268884705730224734175061150711803429392225432301505122257804703)) & uint256(0))]) = (string("This is a really long string that must ideally be random but is currently hard coded"), payable(address(this)).balance, string("This is a really long string that must ideally be random but is currently hard coded"));
    assert(keccak256(bytes(o1[(uint256(61516289890507915498367245342511604059779491239789828230196780498657922706592) - uint256(0))])) == keccak256(bytes(string("This is a really long string that must ideally be random but is currently hard coded"))));
    assert(o0 == payable(address(this)).balance);
    assert(keccak256(bytes(o1[((((((uint256(17777132105011587518354888687516798776989824323151515633909203410338933704308) % uint256(0)) & uint256(106914939312581193728652264182479772766236280067564609561087025882592651761715)) ^ uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ^ uint256(105222278957534865665312833537337419910169064657210456729952311279111631919159)) + uint256(96191983089924268884705730224734175061150711803429392225432301505122257804703)) & uint256(0))])) == keccak256(bytes(string("This is a really long string that must ideally be random but is currently hard coded"))));
  }
  function f1(uint16 i0) external   payable  returns(function (uint40) external  [] memory o0)  {
    return (new function (uint40) external  [](8));
  }
  uint48 public constant cons0 = 122718003098713;
  function f2(uint16 i0) external   payable  returns(bytes13 o0,function () external   o1)  {
    uint16  l0 = s0;
    uint16  l1 = l0;
    assert(l1 == s0);
    emit ev0(bytes19(0xc4c13e59b45862e29aa622899523047998f8f8), payable(address(this)));
    (s0) = (uint16(38321));
    assert(s0 == uint16(38321));
  }
}
struct St0 {
  string el0;
  address el1;
  int184 el2;
}
pragma solidity >= 0.0.0;
// ====
// ----
