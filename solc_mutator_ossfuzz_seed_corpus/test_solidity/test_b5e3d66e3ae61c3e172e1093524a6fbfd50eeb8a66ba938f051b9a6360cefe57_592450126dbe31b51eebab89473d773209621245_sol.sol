
==== Source: su0.sol ====
function f0(function (bytes10, address payable, bytes4[] memory) external   returns (address, uint256[9] memory) i0)      returns(address o0,bytes1 o1){
  if (true)
  {
  }
}
struct St0 {
  bytes5 el0;
  bytes4 el1;
  bytes2 el2;
}
error er0();
contract C0 {
  function f1(address i0,bool i1) private      {
    uint160 l0 = uint160(1461501637330902918203684832716283019655932542975);
  }

	function compareMemoryAndCalldata(uint176[] memory v1, uint176[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f2(uint176[] calldata i0,bool i1) external      {
  }
  bytes22   s0;
  constructor(bytes22 i0)   {
    s0 = (~(bytes22(0x00000000000000000000000000000000000000000000)));
    unchecked {
    }
  }
  receive() external   payable
  {
    if ((true ? true : false))
    {
      require(false, string.concat(string("This is a really long string that must ideally be random but is currently hard coded")));
    }
    else if (true)
    {
      (bool l0) = payable(this).send(0);
    }
  }
  fallback() external   
  {
    if ((bytes4((~(bytes19(0xb5cea99ffd7158350197850ca93f27817569dc)))) > bytes4(bytes6(0x000000000000))))
    {
      revert er0();
    }
    bytes22  l0 = s0;
    bytes22  l1 = l0;
    assert(l1 == s0);
    assert((address(this) > address(this)));
  }
  struct St1 {
    int248 el0;
    bytes31 el1;
    St0 el2;
    bool el3;
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St2 {
  bytes18 el0;
  address el1;
  bytes22 el2;
}
pragma solidity >= 0.0.0;
error er1(int208 ep0, address payable ep1);
// ====
// ----
