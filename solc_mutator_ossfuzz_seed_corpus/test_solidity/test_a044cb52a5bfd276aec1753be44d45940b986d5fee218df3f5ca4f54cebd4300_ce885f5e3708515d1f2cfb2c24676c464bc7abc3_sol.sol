
==== Source: su0.sol ====
contract C0 {
  receive() external   payable
  {
    while (((-((int72(2058719624854062750996) ^ (int72(2361183241434822606847) + int72(0))))) >= int72(0)))
    {
      revert((false ? string("This is a really long string that must ideally be random but is currently hard coded") : string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"))));
    }
  }
  struct St0 {
    address el0;
    int232 el1;
    bytes22 el2;
  }
  error er0();
  function f1(bool i0) internal     returns(uint128 o0,uint184 o1)  {
    if (i0)
    {
      if (i0)
      {
        return (uint128(159672667784788617523061920300208233262), (uint184(0) % uint184(0)));
      }
      else
      {
        revert er0();
      }
    }
    return (uint128((uint128(((uint128(283728088547872903319266920356053814986) - uint128(0)) / uint128(340282366920938463463374607431768211455))) / uint128(311052226803156057317535504900162090597))), uint184(12390308558185085838238754151670840186601154618191347065));
  }
  bytes   s0;

	function compareMemoryAndStorage(bytes memory v1, bytes storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  bytes16 immutable public s1;
  uint128   s2 = uint128(340282366920938463463374607431768211455);
  string   s3;

	function compareMemoryAndStorage(string memory v1, string storage v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  constructor(bytes memory i0,bytes16 i1,string memory i2) payable  {
    s0 = bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    s1 = (bytes16(0x00000000000000000000000000000000) & bytes16(0x00000000000000000000000000000000));
    s3 = string("This is a really long string that must ideally be random but is currently hard coded");
    unchecked {
      payable(this).transfer(10567886566000170770);
    }
  }
}
struct St1 {
  function (C0.St0 memory, function (function (int88, bool) external   returns (string memory, function (int192) external   returns (address payable), int56)) external   returns (string memory, address payable, uint16)) external   returns (uint208)[5] el0;
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St2 {
  bytes7 el0;
  bytes8[] el1;
  function (address, address payable, function (bytes memory) external   returns (bool[1] memory)) external   returns (bool) el2;
  bytes9 el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
