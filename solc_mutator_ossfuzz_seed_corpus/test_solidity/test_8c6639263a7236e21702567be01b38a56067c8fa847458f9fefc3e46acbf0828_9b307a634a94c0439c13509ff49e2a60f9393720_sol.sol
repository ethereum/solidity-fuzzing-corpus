
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  function f0(int128 i0,address payable i1) external   payable   {
    while (((false ? bytes5(0x0000000000) : bytes23(0xffffffffffffffffffffffffffffffffffffffffffffff)) != bytes23(0x93a53c8d5f0b50de33d08cfa18a6cf5b426888d7d3a14b)))
    {
    }
  }
  event ev0();
  uint216   s0 = uint216(105312291668557186697918027683670432318895095400549111254310977535);
  uint16  public s1;
  uint144   s2 = uint144(21499823986578400865521929721328700883268073);
  constructor(uint16 i0)   {
    s1 |= ((uint16(65535) % ((uint16(int16(0)) & uint16(0)) % uint16(65535))) % uint16(65535));
    unchecked {
    }
  }
  struct St0 {
    bytes32 el0;
  }
}
contract C1 {
  function f1(uint120 i0) public virtual  payable  returns(int64 o0)  {
    (bool l0, bytes memory l1) = address(this).call(bytes("6c6cfbd584f6ea0b21181a6e6b1befd1a347f61476b001779523a115d118fe16ed6bc7ca3220a36f4d38ca65cdc7f5da23ae78"));
    (bool l2, bytes memory l3) = address(this).call(bytes(string("This is a really long string that must ideally be random but is currently hard coded")));
    for(uint solinit0 = 0; solinit0 < ((~(uint256(94763837218543347865398327684674563008202032650652322856233632100099766550616))) % 11); solinit0++)
    {
      return ((~((int64(0) % int64((int64(9223372036854775807) / int64(9223372036854775807)))))));
    }
  }
  C0.St0  public s3;

	function compareMemoryAndStorage(C0.St0 memory v1, C0.St0 storage v2) internal returns (bool) {

		if (v1.el0 != v2.el0)
			return false;

	return true;
	}  mapping(bytes17 => address)  public s4;
  constructor()   {
    s4[bytes17(0x0000000000000000000000000000000000)] = address(this);
    unchecked {
      s3.el0 = ((this.f1.address <= address(this)) ? bytes32(0x0000000000000000000000000000000000000000000000000000000000000000) : bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff));
      assert(s3.el0 == ((this.f1.address <= address(this)) ? bytes32(0x0000000000000000000000000000000000000000000000000000000000000000) : bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    }
  }
}

==== Source: su1.sol ====
struct St1 {
  bytes el0;
  bytes5 el1;
  mapping(address => bool) el2;
  address el3;
}
pragma solidity >= 0.0.0;
import "su0.sol";
contract C2 {
  bytes11  public s5 = bytes11(0x0000000000000000000000);
  function f2() public   payable  returns(C1 o0)  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
// ====
// ----
