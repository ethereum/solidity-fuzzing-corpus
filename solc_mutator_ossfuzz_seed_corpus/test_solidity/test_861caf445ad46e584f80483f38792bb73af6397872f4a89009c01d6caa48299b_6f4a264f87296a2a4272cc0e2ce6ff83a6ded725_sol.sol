
==== Source: su0.sol ====
function f0()     {
  if (true)
  {
  }
  else if (true)
  {
    for(uint solinit0 = 0; solinit0 < ((uint256(114097439988970483951819831946636111485706051707833702903722978252147348721691) ** uint176(uint176(0))) % 11); solinit0++)
    {
      if (true)
      {
        continue;
      }
      else
      {
        revert(hex"ffffffffffffffffffffffffffffffffffffffffffffffffffff" f1 /*suffix expr*/);
      }
    }
  }
}
pragma solidity >= 0.0.0;
function f2(uint40 i0,bool i1)      returns(bool o0){
}
function f1(bytes26 i0) pure suffix  returns(string memory o0)
{
  if (i0 != (false ? bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff) : (bytes22(0x00000000000000000000000000000000000000000000) & bytes26(0x0000000000000000000000000000000000000000000000000000))))
  {
    if (i0 != bytes26(0x0000000000000000000000000000000000000000000000000000))
    {
      return (string("This is a really long string that must ideally be random but is currently hard coded"));
    }
  }
  else if (i0 == ((bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff) & (~(bytes26(0xd2e7fc3289de76c2aa299883088d0bfcc01a33c896d6b4d79e50)))) ^ hex"03999d84fb8f2ae538832695dffb57777cb8f5135cb6ec1489a6fc25c2df5ef0" f3 /*suffix expr*/))
  {
  }
}
function f3(bytes32 i0) pure suffix  returns(bytes26 o0)
{
}

==== Source: su1.sol ====
function f4()     {
  for(;
true;
false)
  {
  }
  do
  {
    break;
  }
  while (3980669099045478956478 f5 /*suffix expr*/);
  while (false)
  {
  }
}
struct St0 {
  bytes el0;
  bytes el1;
  function (uint48) external   returns (uint128, address payable, address)[] el2;
}
error er0(function (uint32, bytes memory, address) external   returns (address payable)[7] ep0);
struct St1 {
  address payable el0;
  bytes4 el1;
  bool el2;
  bytes17 el3;
}
type T0 is int168;

using {
lt0 as <, gt0 as >, leq0 as <=, geq0 as >=,
bitor0 as |, bitand0 as &, bitxor0 as ^, bitnot0 as ~,
add0 as +, sub0 as -, mul0 as *, div0 as /, mod0 as %,
eq0 as ==, neq0 as !=,
unsub0 as -
} for T0 global;



function lt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) < T0.unwrap(y); }

function gt0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) > T0.unwrap(y); }

function leq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) <= T0.unwrap(y); }

function geq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) >= T0.unwrap(y); }




function bitor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) | T0.unwrap(y)); }

function bitand0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) & T0.unwrap(y)); }

function bitxor0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) ^ T0.unwrap(y)); }

function bitnot0(T0 x) pure returns (T0) { return T0.wrap(~T0.unwrap(x)); }




function add0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) + T0.unwrap(y)); }

function sub0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) - T0.unwrap(y)); }

function mul0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) * T0.unwrap(y)); }

function div0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) / T0.unwrap(y)); }

function mod0(T0 x, T0 y) pure returns (T0) { return T0.wrap(T0.unwrap(x) % T0.unwrap(y)); }



function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



function unsub0(T0 x) pure returns (T0) { return T0.wrap(-T0.unwrap(x)); }


pragma solidity >= 0.0.0;
function f5(uint72 i0) pure suffix  returns(bool o0)
{
}
// ====
// ----
