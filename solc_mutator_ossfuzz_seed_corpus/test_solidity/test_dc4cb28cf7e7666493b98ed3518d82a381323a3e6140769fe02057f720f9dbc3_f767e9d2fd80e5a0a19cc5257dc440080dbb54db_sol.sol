
==== Source: su0.sol ====
struct St0 {
  function (bool, address payable) external   returns (string memory, int24, bytes12) el0;
}
struct St1 {
  bytes8 el0;
}
contract C0 {
  event ev0();
  function f0(bytes22 i0,bytes20 i1) external virtual    returns(bytes22 o0)  {
    emit ev0();
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffff00000000000000"));
  }
  bytes16   s0 = bytes16(0x00000000000000000000000000000000);
  fallback() external virtual  
  {
    (s0, s0) = (bytes16(0x00000000000000000000000000000000), bytes16(0xffffffffffffffffffffffffffffffff));
    assert(s0 == bytes16(0x00000000000000000000000000000000));
    assert(s0 == bytes16(0xffffffffffffffffffffffffffffffff));
    (((int96(39614081257132168796771975167) - int96(39614081257132168796771975167)) * (int96(0) * int96(0))) < int96(29786319870004547953721035942));
    for(uint solinit0 = 0; solinit0 < (uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) % 11); solinit0++)
    {
      break;
    }
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
contract C1 {
  int232   s1 = int232(3238727691542582861934589752177154106964555324316023556558259154179841);
  address payable   s2;
  int32 immutable  s3;
  constructor(address payable i0,int32 i1)   {
    s2 = payable(msg.sender);
    s3 = ((-((int32(0) ^ int32((int32(0) / int32(0)))))) ^ int32(1991749040));
    unchecked {
    }
  }
  type T0 is bytes4;
  type T1 is uint224;
  function f2(int32 i0) public      {
  }
}
import "su0.sol";
pragma solidity >= 0.0.0;
error er0();
// ====
// ----
