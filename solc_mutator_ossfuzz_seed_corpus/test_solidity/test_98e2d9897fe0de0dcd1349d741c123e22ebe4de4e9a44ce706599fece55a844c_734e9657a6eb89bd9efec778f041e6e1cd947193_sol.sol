
==== Source: su0.sol ====
pragma solidity >= 0.0.0;
contract C0 {
  event ev0();
  uint72   s0 = uint72(2426733686287802243962);
  int16  public s1;
  constructor(int16 i0) payable  {
    s1 -= (((int16(32767) & (int16(32767) * int16(30027))) * int16(-29869)) ^ int16(-22445));
    {
      uint184 l0 = (((((uint184((uint184(8448620355021289108192371276099360179038259040527802926) / uint184(24519928653854221733733552434404946937899825954937634815))) - uint184(0)) ^ uint184(0)) + uint184(4958642921966992029327647736433781222896116017428492478)) & uint184(24519928653854221733733552434404946937899825954937634815)) % uint184(1573730209502645438410135461076250853772707968024786132));
      uint64 l1 = (((uint64(0) % ((uint64(15278155650022418526) << uint120(uint120(0))) >> uint208(uint208(411376139330301510538742295639337626245683966408394965837152255)))) << uint112(uint112(5192296858534827628530496329220095))) ^ uint64(18446744073709551615));
      for(;
;
)
      {
        if (false)
        {
        }
      }
    }
  }
  error er0(bytes23 ep0, bytes16 ep1);
  fallback() external virtual  
  {
    emit ev0();
    if (true)
    {
    }
  }
  type T0 is address payable;
  bytes25 public constant cons0 = (bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff) & (false ? bytes25(0xe1508b16be728387e528c806a2241d25a333f5f52741699765) : (bytes25(0xffffffffffffffffffffffffffffffffffffffffffffffffff) & bytes25(0x2f1b4f3358729165c405f233e7eb301027c68edfec85de8292))));
  function f1(uint16 i0,int152 i1) public   payable
  {
    for(;
;
uint184(0))
    {
      s1 |= int16(-23084);
      return;
    }
    do
    {
      if (true)
      {
        break;
      }
      emit ev0();
      s0 = (uint72(4722366482869645213695) >> uint56((((uint56((uint56(39221167525672099) / uint56(72057594037927935))) + uint56(72057594037927935)) % uint56(9943186049408579)) % uint56(0))));
    }
    while (true);
    assembly
    {
      i1 := 115792089237316195423570985008687907853269984665640564039457584007913129639935
    }
  }
  error er1();
}
library L0 {
  modifier m0(bytes10 i0,address i1) 
  {
    if (((true || false) && (false ? true : true)))
    {
      address payable l0 = payable(address(bytes20(address(0x0000000000000000000000000000000000000000))));
      _;
    }
    else
    {
      unchecked {
      }
    }
    do
    {
    }
    while (true);
  }
  function f2(function (address, function () external   returns (C0.T0, string memory, bool), function (bool) external   returns (bytes memory, bool[] memory, uint80)) external   returns (bytes10, string[] memory) i0) public  m0(bytes10(0xf8c1768b4e9240f696a6),address(0x0000000000000000000000000000000000000008))  returns(bytes memory o0)
  {
    assert(true);
  }
  using L0 for *;
  function f3(bool[2] memory i0,function (bytes7, bytes32, bool) external   returns (bool, int240, bool) i1,bytes memory i2) public  m0(bytes10(0xffffffffffffffffffff),address(0x0000000000000000000000000000000000000008))  returns(int184 o0)
  {
    i0[1] = ((int256(0) != int256(0)) || ((int152(0) == int152(1512537634310565925746459031409174439065549686)) && true));
    do
    {
      break;
    }
    while (false);
  }
  bool public constant cons1 = false;
  modifier m1() 
  {
    address l0 = address(0x0000000000000000000000000000000000000007);
    _;
  }
  error er2();
  enum EN0 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26
  }
  modifier m2(uint168[] memory i0,bool i1) 
  {
    _;
  }
}
type T1 is uint128;
error er3(bool ep0, bytes30 ep1);
int16 constant cons2 = (int16(32767) | (~(int16((((int16(0) ** uint256(uint256(76508440743323607011476556704570540971024165666822750598601425215300184502234))) | int16(-17889)) / int16(0))))));
// ====
// ----
