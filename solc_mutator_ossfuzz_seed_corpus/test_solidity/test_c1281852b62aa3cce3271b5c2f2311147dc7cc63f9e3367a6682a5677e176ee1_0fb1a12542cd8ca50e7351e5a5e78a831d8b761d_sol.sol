
==== Source: su0.sol ====
contract C0 {
  function f0() external     returns(int224 o0,int232 o1)  {
    return (int224((((((int224(13479973333575319897333507543509815336818572211270286240551805124607) % int224(0)) | int224(10565428568291343460892626169973042961549788336544670416973852445613)) - int224(-13401926122157313491758187338550277633143548252668773701671198062460)) % int224(0)) / int224(-9667138792344643758707786877052955493336665882743500915856240775765))), int232(0));
  }
  receive() external   payable
  {
    (bool l0) = payable(this).send(0);
  }
  type T0 is address;
  error er0(uint112 ep0);
  bool immutable  s0;
  bool  public s1 = false;
  constructor(bool i0) payable  {
    s0 = ((uint96(11824530300251010845852369280) < (uint96(40167792683946256933912027782) ^ uint96(52900571041588498197120660475))) ? false : false);
    unchecked {
      if (i0)
      {
        if (i0)
        {
          if (i0)
          {
            (s1, s1) = (true, (uint216(0) < ((uint216(105312291668557186697918027683670432318895095400549111254310977535) - (~(uint216(26329284453755744593219425488574087342986062541241433804726641535)))) | uint216(105312291668557186697918027683670432318895095400549111254310977535))));
            assert(s1 == true);
            assert(s1 == (uint216(0) < ((uint216(105312291668557186697918027683670432318895095400549111254310977535) - (~(uint216(26329284453755744593219425488574087342986062541241433804726641535)))) | uint216(105312291668557186697918027683670432318895095400549111254310977535))));
            for(uint solinit0 = 0; solinit0 < (address(this).balance % 11); solinit0++)
            {
              if (i0)
              {
                continue;
              }
              else if (i0)
              {
                (i0) = payable(this).send(0);
                continue;
              }
              if (i0)
              {
                try this.f0() returns (int224 l0, int232 l1)
                {
                  if (i0)
                  {
                    revert(string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), ((payable(address(this)) <= payable(address(this))) ? string("This is a really long string that must ideally be random but is currently hard coded") : string("This is a really long string that must ideally be random but is currently hard coded"))));
                  }
                  else
                  {
                    break;
                  }
                  if (i0)
                  {
                  }
                  else
                  {
                    if (i0)
                    {
                      (int224 l2, int232 l3) = this.f0();
                    }
                  }
                }
                catch
                {
                  continue;
                }
              }
              else
              {
              }
            }
          }
        }
        else if (i0)
        {
        }
      }
    }
  }
  struct St0 {
    address payable el0;
    C0.T0 el1;
    uint240 el2;
    bytes el3;
  }
}
pragma solidity >= 0.0.0;
contract C1 is C0 {
  function f2() public virtual     {
  }
  error er1();
  uint144   s2;
  constructor(uint144 i0)  C0(true)
  {
    s2 ^= uint144(9143853583364579708534403581429211925543808);
    {
    }
  }
}

==== Source: su1.sol ====
struct St1 {
  bytes22[1] el0;
  bytes12 el1;
  bytes10 el2;
}
bytes7 constant cons0 = bytes7(0x00000000000000);
pragma solidity >= 0.0.0;
import "su0.sol";
// ====
// ----
