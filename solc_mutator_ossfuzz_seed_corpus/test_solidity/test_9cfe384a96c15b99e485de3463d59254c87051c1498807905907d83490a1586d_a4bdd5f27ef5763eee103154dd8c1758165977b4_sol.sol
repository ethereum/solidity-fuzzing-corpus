
==== Source: su0.sol ====
contract C0 {
  fallback() external virtual  
  {
    return;
  }
  modifier m0() 
  {
    _;
  }
  function f1() public virtual m0() m0() 
  {
    unchecked {
      uint160 l0 = ((((uint160(((uint160(1461501637330902918203684832716283019655932542975) << uint144(uint144(14749291852127306046250560585388528966595328))) / uint160(1055539369064102671393495743993146363645022997239))) + uint160(0)) ** uint64(uint64(18446744073709551615))) % uint160(317650560867485824967672095318273681483721195759)) & uint160(555746396158566389921570403073731378087839964224));
      (bool l1, bytes memory l2) = address(this).call("ffffffffffffffffffffffffffffffffffffff");
      (bool l3, bytes memory l4) = address(this).call("d39effffffffffffffffffffffffffffffffffffffffffffffffffff");
    }
    if (((int256(57896044618658097711785492504343953926634992332820282019728792003956564819967) & int256(0)) >= int256(57896044618658097711785492504343953926634992332820282019728792003956564819967)))
    {
      assembly
      {
        let al0 := sload(115792089237316195423570985008687907853269984665640564039457584007913129639935)
      }
    }
  }
  modifier m1() 
  {
    _;
    unchecked {
      require((!(true)));
    }
  }
  mapping(address => int128)  public s0;
  int72   s1;
  int216 immutable  s2;
  address   s3;
  constructor(int72 i0,int216 i1,address i2) payable  {
    s1 += int72(1280620077439492489719);
    s2 = int216(0);
    s3 = address(this);
    s0[address(this)] %= int128((int128(0) / int128(170141183460469231731687303715884105727)));
    { }
  }
  bytes10 public constant cons0 = (bytes10(0xffffffffffffffffffff) ^ bytes10(0xffffffffffffffffffff));
  error er0();
}
pragma solidity >= 0.0.0;
library L0 {
  function f2() internal    returns(int72 o0,bytes30 o1)
  {
    (int72 l0, bytes30 l1) = f2();
    uint64 l2 = ((uint64(18446744073709551615) ** uint240((uint240(((uint240(0) + uint240(1700691836281812144464629690435509832723052010358469713180320823038365609)) / uint240(0))) >> uint184(uint184(0))))) % uint64(11127126730672405975));
  }
  modifier m2(address payable i0) 
  {
    _;
  }
  using L0 for *;
  function f3() external    returns(address o0)
  {
    if ((false && true))
    {
    }
  }
  bytes1 public constant cons1 = (true ? (((bytes1(0xff) | bytes1(0x00)) & bytes1(0x0e)) & bytes1(0x00)) : bytes1(0xff));
  type T0 is int136;
}
type T1 is int8;
struct St0 {
  address el0;
}
// ====
// ----
