
==== Source: su0.sol ====
uint8 constant cons0 = (((uint8((((uint8(0) << uint152(uint152(5708990770823839524233143877797980545530986495))) ^ uint8(0)) / uint8(0))) ^ uint8(170)) + uint8(164)) ^ uint8(255));
function f0()     returns(int184 o0,int24 o1)
{
  if (true)
  {
  }
  else
  {
  }
}
contract C0 {
  modifier m0() 
  {
    for(;
;
)
    {
      _;
      continue;
      (bool l0, bytes memory l1) = address(this).call("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    }
  }
  uint32 public constant cons1 = uint32(3113804550);
  struct St0 {
    uint112 el0;
    bool[] el1;
  }
  int64  public s0 = int64(9223372036854775807);
  uint80[]  public s1 = [uint80(0), uint80(0)];
  C0.St0   s2 = C0.St0(uint112(0), new bool[](2));
  uint72   s3 = uint72(4722366482869645213695);
  error er0();
  function f1() external  m0()  returns(int104 o0)
  {
    (int104 l0) = this.f1();
    delete s2.el1;
    return ((int104(0) ^ int104(0)));
    s1.pop();
    return (int104(318333582834660045960624843221));
  }
  function f2(bool i0,address payable i1,function (int72, string memory, bytes2) external   returns (bytes memory, bool) i2) external virtual m0() payable returns(int208 o0)
  {
    s1.push(uint80(606600481688209956999092));
  }
  type T0 is uint160;
  function f3() private  m0()  returns(function (uint16) external   returns (address payable) o0,C0.St0 memory o1,bool o2)
  {
  }
}
pragma solidity >= 0.0.0;
error er1();
// ====
// ----
