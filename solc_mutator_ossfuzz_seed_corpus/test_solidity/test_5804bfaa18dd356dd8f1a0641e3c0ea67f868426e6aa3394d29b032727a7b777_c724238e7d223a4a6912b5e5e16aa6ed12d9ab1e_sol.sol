
==== Source: su0.sol ====
library L0 {
  using L0 for *;
  modifier m0(bool i0,bytes24 i1) 
  {
    _;
  }
  function f0(bool i0,uint24 i1) public  m0(true,bytes24(0xffffffffffffffffffffffffffffffffffffffffffffffff))  returns(function (bytes29, function (address payable, bytes32, function (bytes25, uint120, bytes memory) external   returns (bool)) external   returns (uint104, address, bool)) external   returns (uint200) o0,string memory o1)
  {
    if (true)
    {
      if ((!(false)))
      {
      }
      else if (true)
      {
        revert("ffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000");
      }
      else if (true)
      {
        if (((i0 == true) && (bytes8(0x0000000000000000) < bytes8(0x0000000000000000))))
        {
        }
        else if ((true && (true || false)))
        {
        }
      }
    }
    else if ((true && false))
    {
    }
  }
  function f1() internal  m0((!(true)),bytes24(0x58f92787d086fd719ea5dd316c7ac769e5bc2ec0088c66d3)) 
  {
  }
  int16 public constant cons0 = (((int16((((int16(0) - int16(32767)) | int16(0)) / int16(0))) & int16(32767)) ** uint8(uint8(0))) + int16(32767));
  event ev0(uint168  ep0, bytes1  ep1, address payable  ep2) anonymous;
  error er0(bool ep0);
  bytes10 public constant cons1 = (((bytes10(0xffffffffffffffffffff) ^ ((bytes10(0x00000000000000000000) ^ bytes10(0xffffffffffffffffffff)) ^ bytes10(0x887e20827c15c8497a45))) & bytes10(0x00000000000000000000)) ^ bytes10(0x00000000000000000000));
}
type T0 is bool;
struct St0 {
  T0 el0;
  uint200 el1;
  bool el2;
  function () external   returns (function (uint240, uint120[2] memory) external   returns (T0))[2][] el3;
}
pragma solidity >= 0.0.0;
// ====
// ----
