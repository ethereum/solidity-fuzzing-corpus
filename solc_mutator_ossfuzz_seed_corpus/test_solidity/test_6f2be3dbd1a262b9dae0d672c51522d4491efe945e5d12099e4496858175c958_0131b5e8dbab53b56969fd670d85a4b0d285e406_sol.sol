
==== Source: su0.sol ====
struct St0 {
  uint232 el0;
  bytes22[1] el1;
  bool el2;
  bytes15 el3;
}
type T0 is int216;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27
}
function f0()    
{
}
contract C0 {
  modifier m0(function (uint224, function (St0 memory, int120, function () external   returns (function (string memory, uint120) external   returns (function (T0) external   returns (bool[] memory)), int72[2] memory)) external   returns (bytes memory)) external   returns (St0 memory, T0, bool) i0) virtual
  {
    _;
  }
  bool[]  public s0;
  T0   s1;
  constructor(bool[] memory i0,T0 i1)   {
    s0 = i0;
    s1 = T0.wrap(int216(38075197180846652069596534803360017587303298672371594555442957386));
    unchecked {
      (bool l0, bytes memory l1) = address(this).call("91adadf4ffffff");
      l1 = bytes("00000000000000000000000000000000000000000000000000000000000063aebf3cd0afe9");
      s0.pop();
    }
  }
  function f1(int248 i0) public   payable returns(bytes26 o0)
  {
    for(    0;
;
)
    {
      return (bytes26(0xffffffffffffffffffffffffffffffffffffffffffffffffffff));
      (bytes26 l0) = this.f1({i0: int248(0)});
    }
    (bool l1, bytes memory l2) = address(this).call(bytes("e432849c74cb7e8a6d31439b2666a2df8fe5c2922d462db2ddffffff"));
  }
  type T1 is int128;
  function f2(bool i0,bytes19 i1) internal virtual   returns(bool o0)
  {
    s0[0] = false;
    s1 = T0.wrap(int216(0));
    St0 storage l0;
  }
}
pragma solidity >= 0.0.0;
error er0();
library L0 {
  type T2 is address payable;
  function f3() internal   
  {
  }
  bool public constant cons0 = (true || ((((int72(2361183241434822606847) + int72(0)) ^ int72(-121357983367085216388)) == int72(2361183241434822606847)) ? true : false));
  enum EN1 {
    M0, M1, M2, M3, M4, M5, M6, M7,
    M8, M9, M10, M11, M12, M13, M14, M15,
    M16, M17, M18, M19, M20, M21, M22, M23,
    M24, M25, M26, M27, M28, M29
  }
  function f4(address i0) private    returns(string memory o0,function (address payable, bytes27) external   returns (address payable[2] memory, int8) o1)
  {
  }
  modifier m1(St0 memory i0) 
  {
    address payable l0 = payable(address(0x0000000000000000000000000000000000000004));
    _;
  }
  error er1();
  error er2(int160 ep0);
  L0.T2 public constant cons1 = L0.T2.wrap(payable(address(0x0000000000000000000000000000000000000006)));
  using L0 for *;
  modifier m2(function (bytes24) internal   returns (address payable, int160) i0) 
  {
    assembly
    {
      switch cons1
      case 26569721929021563095333588057418398713574007324852110978244891391537068314919
      {
      }
      function af0(ai0) -> ao0
      {
        if af0(ai0)
        {
        }
      }
    }
    _;
  }
}
L0.EN1 constant cons2 = L0.EN1.M28;
// ====
// ----
