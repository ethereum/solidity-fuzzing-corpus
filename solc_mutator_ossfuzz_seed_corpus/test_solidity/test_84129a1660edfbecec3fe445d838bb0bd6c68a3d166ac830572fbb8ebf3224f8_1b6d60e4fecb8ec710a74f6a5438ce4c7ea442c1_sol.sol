
==== Source: su0.sol ====
struct St0 {
  bytes el0;
  uint32 el1;
}
function f0()     {
  while (true)
  {
  }
}
contract C0 {
  struct St1 {
    address payable el0;
    address el1;
    bytes23 el2;
    bool el3;
  }
  receive() external   payable
  {
    if (false)
    {
      return;
    }
    return;
  }
  address payable  public s0;
  int160   s1 = int160(0);
  bytes2   s2 = bytes2(0xb8ec);
  constructor(address payable i0)   {
    s0 = payable(address(this));
    unchecked {
    }
  }
}
contract C1 {
  event ev0(uint192  ep0, address  ep1);
  function f2() internal     returns(bytes30 o0,bool o1)  {
    for(uint solinit0 = 0; solinit0 < (address(this).balance % 11); solinit0++)
    {
      break;
    }
    uint24 l0 = (false ? (uint24((uint24(16777215) / (uint24(16777215) ^ uint24(6940175)))) | uint24(0)) : uint24(0));
    assert(false);
  }
  int128   s3;
  uint176   s4;
  constructor(int128 i0,uint176 i1)   {
    s3 |= int128((int128(-53605276272473441592564666237317014322) / ((int128(0) % int128(-45582761368493785393975615872069358593)) + int128(0))));
    s4 %= uint176(27085725359796979637614553828775891952773691246547391);
    unchecked {
    }
  }
  struct St2 {
    function (C0) external   returns (bool, address, bytes28) el0;
  }
}
pragma solidity >= 0.0.0;
bool constant cons0 = false;

==== Source: su1.sol ====
struct St3 {
  bool[] el0;
}
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



type T1 is bool;

using {



eq1 as ==, neq1 as !=

} for T1 global;






function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }



pragma solidity >= 0.0.0;
// ====
// ----
