
==== Source: su0.sol ====
function f0()      returns(bool o0,int24 o1,bytes7 o2){
  o0 = true;
  assert(o0 == true);
}
type T0 is bool;

using {



eq0 as ==, neq0 as !=

} for T0 global;






function eq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) == T0.unwrap(y); }

function neq0(T0 x, T0 y) pure returns (bool) { return T0.unwrap(x) != T0.unwrap(y); }



pragma solidity >= 0.0.0;

==== Source: su1.sol ====
struct St0 {
  address payable el0;
  string el1;
  function (int128, address) external   returns (uint200, function () external   returns (bytes15, string memory, uint256)[9] memory, function (bool, address[] memory, bytes28) external   returns (int112, int248)) el2;
}
struct St1 {
  address el0;
  uint208 el1;
}
contract C0 {
  uint56   s0;
  constructor(uint56 i0)   {
    s0 >>= (uint56(0) - ((uint56(0) | (uint56(0) ^ uint56(0))) | uint56(0)));
    {
    }
  }
  receive() external virtual  payable
  {
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
  fallback() external virtual  
  {
  }
  function f3(uint56 i0,uint56 i1) internal virtual    returns(uint152 o0)  {
    (bool l0) = payable(this).send(5748925706883776764);
    if (i1 > uint56(72057594037927935))
    {
      assert(false);
    }
    else
    {
    }
  }
}
pragma solidity >= 0.0.0;
// ====
// ----
