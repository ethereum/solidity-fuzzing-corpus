
==== Source: su0.sol ====
contract C0 {
  struct St0 {
    bytes9 el0;
  }
  event ev0();
  fallback() external   
  {
    (bool l0, bytes memory l1) = address(this).call(0xE5316e418eEDB3ebc0EEAb52C7edB1585Ec6a5b7 f1 /*suffix expr*/);
  }
  function f2(uint104 i0) public   payable   {
    if (i0 < uint104(20282409603651670423947251286015))
    {
    }
    if (i0 <= (uint104(0) | uint104(20282409603651670423947251286015)))
    {
      (~((uint32(0) % (uint32(3274166252) % uint32(4294967295)))));
      if (i0 >= 0 f3 /*suffix expr*/)
      {
        do
        {
          if (i0 > uint104((((uint104(20282409603651670423947251286015) ** uint96(((uint96(79228162514264337593543950335) ^ uint96(51289655509061720701405466634)) ^ uint96(0)))) * uint104(20282409603651670423947251286015)) / uint104(20282409603651670423947251286015))))
          {
          }
        }
        while (true);
      }
    }
    else
    {
    }
  }
  bytes4   s0 = bytes4(0x5cdfa00d);
  int24   s1;
  uint64  public s2 = uint64(0);
  uint240   s3 = uint240(796291729735192222706746783287449182915603065551201697924509324886934216);
  constructor(int24 i0)   {
    s1 -= 115792089237316195423570985008687907853269984665640564039457584007913129639935 f4 /*suffix expr*/;
    unchecked {
      assert(false);
    }
  }
}
pragma solidity >= 0.0.0;
function f5()     {
  return;
}
struct St1 {
  address payable el0;
  int152 el1;
  bytes30 el2;
  C0.St0 el3;
}
function f6()     {
  return;
}
function f1(address i0) pure suffix  returns(bytes memory o0)
{
  if (i0 <= address(0x0000000000000000000000000000000000000008))
  {
    f5();
  }
}
function f3(uint160 i0) pure suffix  returns(uint104 o0)
{
  revert(string.concat(string("This is a really long string that must ideally be random but is currently hard coded"), string("This is a really long string that must ideally be random but is currently hard coded"), 0 f7 /*suffix expr*/, string(bytes("1c59b822f8093b08e1604f55de4013945dfd65313187b7823996bb000000000000000000000000000000000000000000000000000000"))));
}
function f4(uint256 i0) pure suffix  returns(int24 o0)
{
}
function f7(int16 i0) pure suffix  returns(string memory o0)
{
  if (i0 != ((int8(-61) ** uint128((true ? uint128(337805779161902096423877978172219130897) : uint128(0)))) - int8(32)))
  {
  }
  else if (i0 == ((int16((uint16(50850) | uint16(0))) & int16(3935)) - int16(0)))
  {
  }
}

==== Source: su1.sol ====
contract C1 {
  uint72   s4;
  uint104   s5;
  bytes4 immutable  s6;
  uint240   s7;
  constructor(uint72 i0,uint104 i1,bytes4 i2,uint240 i3) payable  {
    s4 /= (uint72(4722366482869645213695) + uint72(((((uint72(4722366482869645213695) ** uint248(uint248(252527867152409444858483889022749089534057816961230427104542756155727831221))) % uint72(926387494675420135508)) ^ uint72(4722366482869645213695)) / uint72(4722366482869645213695))));
    s5 *= (((false f8 /*suffix expr*/ | uint104(0)) - (uint104(20282409603651670423947251286015) >> uint192(uint192(3338600360355192122876592498330907947796295609365910971656)))) | uint104(20282409603651670423947251286015));
    s6 = bytes4(0x1a596b37);
    s7 ^= ((uint240(0) % uint240(0)) | uint240(0));
    unchecked {
    }
  }
  event ev1();
  function f9(bytes4 i0) public virtual    returns(function () external   returns (bool, int104, uint96) o0)  {
    do
    {
      if (i0 < bytes4(0xffffffff))
      {
        break;
      }
      (bool l0, bytes memory l1) = address(this).call(bytes("98cfc1429b811f0b37000000000000000000000000000000000000000000000000000000000000"));
    }
    while (0 f10 /*suffix expr*/);
    emit ev1();
  }
  type T0 is bytes5;
}
pragma solidity >= 0.0.0;
struct St2 {
  mapping(C1.T0 => address) el0;
  uint248 el1;
  int192 el2;
  int72 el3;
}
error er0(bytes14 ep0);
function f10(uint224 i0) pure suffix  returns(bool o0)
{
  o0 = true;
  assert(o0 == true);
  revert er0((bytes14(0xffffffffffffffffffffffffffff) ^ bytes14(0x0000000000000000000000000000)));
}
function f8(bool i0) pure suffix  returns(uint104 o0)
{
}
// ====
// ----
