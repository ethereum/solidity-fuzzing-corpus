
==== Source: su0.sol ====
contract C0 {
  function f0() private      {
    (bool l0, bytes memory l1) = address(this).call(bytes("ffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
  }
  function f1(uint152 i0,bool i1,bool i2) public virtual  payable  returns(bytes13 o0,function (address payable, bool, uint16) external   returns (address) o1)  {
    o0 &= bytes13(0x00000000000000000000000000);
    if (i0 > uint152(4742801284339925292786760997434601950368978766))
    {
      0;
    }
    else if (i2)
    {
      int224 l0 = int224(13479973333575319897333507543509815336818572211270286240551805124607);
    }
  }
  function f2(int152 i0,function (function (function (address, address, bytes11) external   returns (uint176, bytes24, bytes30), uint104, bytes memory) external  , bool) external   i1) external virtual    returns(function (int232) external   returns (uint72) o0,bool o1)  {
    o1 = (payable(address(this)) > payable(address(this)));
    assert(o1 == (payable(address(this)) > payable(address(this))));
    bytes23 l0 = (bytes23(0x0000000000000000000000000000000000000000000000) ^ bytes3(0x12d032));
  }
  function f3() internal     returns(uint152 o0,address payable o1)  {
    if (true)
    {
    }
  }
  bool   s0 = true;
  int80   s1;
  int32   s2 = int32(-2113192484);
  constructor(int80 i0)   {
    s1 = int80(604462909807314587353087);
    unchecked {
    }
  }
}
error er0(uint208 ep0, bool ep1);
bytes22 constant cons0 = bytes22(0x00000000000000000000000000000000000000000000);
contract C1 {
  function f4() external virtual     {
    for(uint solinit0 = 0; solinit0 < (uint256(66447653557920092282741122476581490386914517458525630189678782081508084897397) % 11); solinit0++)
    {
      try this.f4()
      {
        continue;
      }
      catch
      {
      }
      catch Panic(uint256 l0)
      {
        for(        bool l1 = false;
false;
)
        {
          continue;
        }
        revert(string("This is a really long string that must ideally be random but is currently hard coded"));
      }
      break;
    }
  }
  struct St0 {
    address el0;
    int8 el1;
    bytes8 el2;
    bytes12 el3;
  }
  struct St1 {
    address el0;
    bool el1;
  }
  address  public s3;
  bytes22   s4 = bytes22(0x4466fa44f8ed376a892c042d12be95bef93d8ebece13);
  constructor(address i0) payable  {
    s3 = address(this);
    unchecked {
    }
  }
  fallback() external   
  {
    if (true)
    {
      if ((true ? true : (payable(address(this)) < payable(address(this)))))
      {
        return;
      }
      else
      {
        this.f4();
      }
    }
    return;
  }
  function f6() public   payable  returns(C0 o0,function (C1.St1 memory) external   returns (C1.St0 memory, bytes memory) o1,uint104 o2)  {
    do
    {
      break;
    }
    while (false);
  }
}
pragma solidity >= 0.0.0;

==== Source: su1.sol ====
address constant cons1 = 0x75bBa9f55322207491e0c07604413CBc7418cd05;
pragma solidity >= 0.0.0;
// ====
// ----
