
==== Source: su0.sol ====
struct St0 {
  function (uint176, uint112) external   returns (uint104, bool, bytes1) el0;
  uint96 el1;
  bytes5 el2;
  address payable el3;
}
pragma solidity >= 0.0.0;
struct St1 {
  mapping(bytes2 => function (bytes memory, int24) internal   returns (string memory)[]) el0;
  bool el1;
}
contract C0 {

	function compareMemoryAndCalldata(bytes memory v1, bytes calldata v2) internal pure returns (bool) {
		return keccak256(bytes(v1)) == keccak256(bytes(v2));
	}
  function f0(bytes calldata i0,function (bytes12, St0 memory, bytes10[5] memory) external   returns (uint208, string memory, St0[1] memory) i1) public   payable  returns(string memory o0,bool o1,St0 memory o2)  {
    return (hex"ffffff" f1 /*suffix expr*/, true, o2);
  }
  receive() external virtual  payable
  {
    for(    address l0 = (((true ? 0 f3 /*suffix expr*/ : bytes7(0x4d34f48e3c56ea)) > bytes7(0x3b1f164401e193)) ? address(this) : address(this));
(((uint64(9464036001538048149) | (false ? uint64(18446744073709551615) : uint64(0))) % uint64(16224076548429410067)) != uint64(13192851146294900413));
uint160(22519574658856773345919393509043153051365654897))
    {
      payable(this).transfer(7879254617503638163);
    }
  }
  address  public s0;
  St1  public s1;
  constructor(address i0)   {
    s0 = address(this);
    unchecked {
    }
  }
  function f4(address i0) external   payable   {
    (bool l0, bytes memory l1) = payable(this).call{value: 0}("");
    revert(string("This is a really long string that must ideally be random but is currently hard coded"));
  }
}
function f1(bytes3 i0) pure suffix  returns(string memory o0)
{
}
function f3(int40 i0) pure suffix  returns(bytes7 o0)
{
  if (i0 != (int40(0) ** uint232(false f5 /*suffix expr*/)))
  {
    if (i0 != 340282366920938463463374607431768211455 f6 /*suffix expr*/)
    {
      if (i0 != int40(0))
      {
        for(;
;
)
        {
          return ((~(bytes7(0x00000000000000))));
        }
      }
      o0 &= bytes7(0x00000000000000);
      return ((((false f7 /*suffix expr*/ | (int256((int256(1028000954094840003456608373916747923082179814932029201864632618456357519495) / int256(-15770498590365924155655306398025678141528662925664670572164203197710542799479))) | int256(-52606134092320858586215623571169553622647395990252174268834303861063341306998))) <= int256(55927582836606321716306365065240274752299331848278522274173506509159118850286)) ? bytes7(0x00000000000000) : bytes7(0x8333e6d274bfdc)));
    }
    else if (i0 <= (int40((((false f8 /*suffix expr*/ % int40(int48(0))) & int40(-508624112014)) / int40(549755813887))) % int40(0)))
    {
    }
  }
}
function f5(bool i0) pure suffix  returns(uint232 o0)
{
}
function f6(uint128 i0) pure suffix  returns(int40 o0)
{
}
function f7(bool i0) pure suffix  returns(int256 o0)
{
}
function f8(bool i0) pure suffix  returns(int40 o0)
{
}

==== Source: su1.sol ====
struct St2 {
  uint64 el0;
}
pragma solidity >= 0.0.0;
contract C1 {
  function f9(bool i0) external virtual     {
  }
  mapping(int136 => bytes14)   s2;
  constructor()   {
    s2[(int136(43556142965880123323311949751266331066367) + ((int136(0) * (int136(0) | int136(0))) ^ int136(0)))] &= bytes14((false ? bytes8(0x4ff5370e58611f87) : bytes8(79228162514264337593543950335 f10 /*suffix expr*/)));
    unchecked {
    }
  }
  event ev0(int56  ep0);
}
function f10(uint96 i0) pure suffix  returns(bytes19 o0)
{
  for(uint solinit0 = 0; solinit0 < (uint256(80009289236629694852299756124842700860564270482652727240076676653118520534806) % 11); solinit0++)
  {
    break;
  }
}
// ====
// ----
