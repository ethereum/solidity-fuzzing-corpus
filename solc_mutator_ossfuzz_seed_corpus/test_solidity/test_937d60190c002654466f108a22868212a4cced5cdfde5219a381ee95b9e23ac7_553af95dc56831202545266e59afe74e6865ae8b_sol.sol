==== Source:  ====

==== Source: su0.sol ====
function f0(int240 i0)     {
}
pragma solidity >= 0.0.0;
function f1(bool i0,bytes memory i1)      returns(function (int48) external   o0){
  if (i1.length <= (payable(address(0x0000000000000000000000000000000000000008)).balance & uint256((uint104(20282409603651670423947251286015) / uint256(0)))))
  {
    if (i0)
    {
      int144 l0 = int144((int160(-128760487814892755167702873534942352135418748671) - (int160(((-(int160(0))) / int160(1972795412941712597988445674332425255332057539))) ^ int160(-157266534244821252574905814848113294137793748470))));
    }
    else
    {
      if (i0)
      {
        if (i1.length >= (((((uint24(0) & uint24(12240077)) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) - uint256(0)))
        {
          if (i0)
          {
          }
        }
        else
        {
          try o0((int48(17471944405662) * (int48(0) + int48(77889725897612))))
          {
          }
          catch
          {
            do
            {
              continue;
            }
            while (false);
          }
          catch Panic(uint256 l1)
          {
            int112 l2 = int112(0);
          }
        }
      }
      else
      {
      }
    }
  }
}
contract C0 {

	function compareMemoryAndCalldata(bool[] memory v1, bool[] calldata v2) internal returns (bool) {
		if (v1.length != v2.length)
			return false;
		for (uint i = 0; i < v1.length; i++)

			if (v1[i] != v2[i])

				return false;
		return true;
	}
  function f2(int24 i0,bool[] calldata i1) public   payable   {
    for(uint solinit0 = 0; solinit0 < (((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) << uint120(uint120(1329227995784915872903807060280344575))) * (i1[uint256(0)] ? uint256(80514303142218424224827149461014162740872199217219161470638875391142090119428) : uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935))) % 11); solinit0++)
    {
      new address payable[](3);
      delete i0;
    }
    if (i1.length >= ((true ? uint256(101723615483717342753452401044047837007492823625699377891633304403046564097065) : i1.length) | uint256(39783364364811736312635093097071056479612417059226777678435128775113695087939)))
    {
      for(uint solinit1 = 0; solinit1 < (((((((uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935) * uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) & uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) ** uint112(uint112(0))) | uint256(115792089237316195423570985008687907853269984665640564039457584007913129639935)) >> uint224(uint224(0))) ^ uint256(0)) % 11); solinit1++)
      {
        return;
      }
    }
  }
  function f3() internal     returns(bool o0)  {
    return (false);
  }
  bool   s0;
  constructor(bool i0)   {
    s0 = false;
    unchecked {
    }
  }
  function f4() public   payable  returns(address[] memory o0)  {
    (bool l0) = f3();
  }
  type T0 is uint232;
  event ev0(bool indexed ep0, C0.T0  ep1, address payable  ep2);
}

==== Source: su1.sol ====
import "su0.sol";
pragma solidity >= 0.0.0;
uint144 constant cons0 = 22300745198530623141535718272648361505980415;
// ----
// Warning 5740: (su0.sol:2915-2925): Unreachable code.
// Warning 2072: (su0.sol:327-336): Unused local variable.
// Warning 5667: (su0.sol:1289-1299): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:1325-1334): Unused local variable.
// Warning 6133: (su0.sol:2161-2185): Statement has no effect.
// Warning 5667: (su0.sol:3069-3076): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:3166-3185): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:3195-3202): Unused local variable.
// Warning 2018: (su0.sol:1433-1677): Function state mutability can be restricted to pure
// Warning 2018: (su0.sol:2971-3041): Function state mutability can be restricted to pure
