==== Source:  ====

==== Source: su0.sol ====
contract C0 {
  function f0() external   payable  returns(bool o0)  {
    try this.f0() returns (bool l0)
    {
      (bool l1, bytes memory l2) = payable(this).call{value: 0}("");
    }
    catch
    {
      o0 = false;
      assert(o0 == false);
      return (true);
    }
    if (((int112((((-(int96(39614081257132168796771975167))) + int112(0)) / int112(0))) ** uint16(uint16(0))) != int112(0)))
    {
      delete o0;
    }
  }
  int48  public s0;
  address   s1;
  int96  public s2;
  constructor(int48 i0,address i1,int96 i2)   {
    s0 -= int48(0);
    s1 = address(this);
    s2 *= ((~((int96(39614081257132168796771975167) % int96(39614081257132168796771975167)))) % (false ? int96(0) : int96(39614081257132168796771975167)));
    unchecked {
    }
  }
  struct St0 {
    bytes10 el0;
    address el1;
  }
  type T0 is uint136;
  receive() external   payable
  {
    address  l0 = s1;
    address  l1 = l0;
    assert(l1 == s1);
    (bool l2) = this.f0();
    if (this.f0())
    {
      (bool l3) = this.f0();
      if (this.f0())
      {
        do
        {
        }
        while (false);
      }
      else
      {
      }
    }
  }
}
pragma solidity >= 0.0.0;
enum EN0 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18, M19, M20, M21, M22, M23,
  M24, M25, M26, M27, M28, M29, M30, M31,
  M32, M33, M34, M35, M36, M37, M38, M39,
  M40, M41, M42, M43, M44, M45, M46, M47,
  M48, M49, M50, M51, M52, M53
}
type T1 is uint120;

using {
lt1 as <, gt1 as >, leq1 as <=, geq1 as >=,
bitor1 as |, bitand1 as &, bitxor1 as ^, bitnot1 as ~,
add1 as +, sub1 as -, mul1 as *, div1 as /, mod1 as %,
eq1 as ==, neq1 as !=

} for T1 global;



function lt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) < T1.unwrap(y); }

function gt1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) > T1.unwrap(y); }

function leq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) <= T1.unwrap(y); }

function geq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) >= T1.unwrap(y); }




function bitor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) | T1.unwrap(y)); }

function bitand1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) & T1.unwrap(y)); }

function bitxor1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) ^ T1.unwrap(y)); }

function bitnot1(T1 x) pure returns (T1) { return T1.wrap(~T1.unwrap(x)); }




function add1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) + T1.unwrap(y)); }

function sub1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) - T1.unwrap(y)); }

function mul1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) * T1.unwrap(y)); }

function div1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) / T1.unwrap(y)); }

function mod1(T1 x, T1 y) pure returns (T1) { return T1.wrap(T1.unwrap(x) % T1.unwrap(y)); }



function eq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) == T1.unwrap(y); }

function neq1(T1 x, T1 y) pure returns (bool) { return T1.unwrap(x) != T1.unwrap(y); }




==== Source: su1.sol ====
enum EN1 {
  M0, M1, M2, M3, M4, M5, M6, M7,
  M8, M9, M10, M11, M12, M13, M14, M15,
  M16, M17, M18
}
pragma solidity >= 0.0.0;
contract C1 {
  function f2() public      {
  }
  function f3() public     returns(EN1 o0,bytes18 o1)  {
    while ((uint24((((uint184(0) << uint144(uint144(9769169677768045961083173457408351718854413))) | uint184(0)) + uint184(7257031544834468686543235246401193180080356636827125813))) <= uint24(9712184)))
    {
      continue;
    }
    if (true)
    {
      o1 = bytes18(0xffffffffffffffffffffffffffffffffffff);
      assert(o1 == bytes18(0xffffffffffffffffffffffffffffffffffff));
    }
  }
  function f4() public      {
    (EN1 l0, bytes18 l1) = this.f3();
  }
  uint120   s3 = uint120(0);
  bool   s4 = true;
  struct St1 {
    uint40 el0;
    uint24 el1;
    address el2;
    function () external   returns (bytes2, bytes memory) el3;
  }
}
// ----
// Warning 5667: (su0.sol:97-104): Unused try/catch parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:119-126): Unused local variable.
// Warning 2072: (su0.sol:128-143): Unused local variable.
// Warning 5667: (su0.sol:503-511): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:512-522): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 5667: (su0.sol:523-531): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su0.sol:944-951): Unused local variable.
// Warning 2072: (su0.sol:998-1005): Unused local variable.
// Warning 5667: (su1.sol:212-218): Unused function parameter. Remove or comment out the variable name to silence this warning.
// Warning 2072: (su1.sol:659-665): Unused local variable.
// Warning 2072: (su1.sol:667-677): Unused local variable.
// Warning 2018: (su1.sol:179-623): Function state mutability can be restricted to pure
